{"version":3,"file":"static/js/151.bb275172.chunk.js","mappings":"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","sources":["../node_modules/nerdamer/Calculus.js","../node_modules/nerdamer/Algebra.js"],"sourcesContent":["/* global module */\r\n\r\n/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\nif((typeof module) !== 'undefined' && typeof nerdamer === 'undefined') {\r\n    var nerdamer = require('./nerdamer.core.js');\r\n    require('./Algebra.js');\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            Frac = core.Frac,\r\n            Settings = core.Settings,\r\n            isSymbol = core.Utils.isSymbol,\r\n            FN = core.groups.FN,\r\n            Symbol = core.Symbol,\r\n            text = core.Utils.text,\r\n            inBrackets = core.Utils.inBrackets,\r\n            isInt = core.Utils.isInt,\r\n            format = core.Utils.format,\r\n            even = core.Utils.even,\r\n            evaluate = core.Utils.evaluate,\r\n            N = core.groups.N,\r\n            S = core.groups.S,\r\n            FN = core.groups.FN,\r\n            PL = core.groups.PL,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            EX = core.groups.EX,\r\n            P = core.groups.P,\r\n            LOG = Settings.LOG,\r\n            EXP = 'exp',\r\n            ABS = 'abs',\r\n            SQRT = 'sqrt',\r\n            SIN = 'sin',\r\n            COS = 'cos',\r\n            TAN = 'tan',\r\n            SEC = 'sec',\r\n            CSC = 'csc',\r\n            COT = 'cot',\r\n            ASIN = 'asin',\r\n            ACOS = 'acos',\r\n            ATAN = 'atan',\r\n            ASEC = 'asec',\r\n            ACSC = 'acsc',\r\n            ACOT = 'acot',\r\n            SINH = 'sinh',\r\n            COSH = 'cosh',\r\n            TANH = 'tanh',\r\n            CSCH = 'csch',\r\n            SECH = 'sech',\r\n            COTH = 'coth',\r\n            ASECH = 'asech',\r\n            ACSCH = 'acsch',\r\n            ACOTH = 'acoth';\r\n\r\n    //custom errors\r\n    function NoIntegralFound(msg) {\r\n        this.message = msg || \"\";\r\n    }\r\n    NoIntegralFound.prototype = new Error();\r\n\r\n    //Preparations\r\n    Symbol.prototype.hasIntegral = function () {\r\n        return this.containsFunction('integrate');\r\n    };\r\n    //transforms a function\r\n    Symbol.prototype.fnTransform = function () {\r\n        if(this.group !== FN)\r\n            return this;\r\n        var retval, a = this.args[0];\r\n        var m = new Symbol(this.multiplier);\r\n        var sym = this.clone().toUnitMultiplier();\r\n        if(this.isLinear()) {\r\n            switch(this.fname) {\r\n                case SINH:\r\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/2', a));\r\n                    break;\r\n                case COSH:\r\n                    retval = _.parse(format('(e^({0})+e^(-({0})))/2', a));\r\n                    break;\r\n                case TANH:\r\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))', a));\r\n                    break;\r\n                case TAN:\r\n                    retval = _.parse(format('sin({0})/cos({0})', a));\r\n                    break;\r\n                case CSC:\r\n                    retval = _.parse(format('1/sin({0})', a));\r\n                    break;\r\n                case SEC:\r\n                    retval = _.parse(format('1/cos({0})', a));\r\n                    break;\r\n                default:\r\n                    retval = sym;\r\n            }\r\n        }\r\n        else if(this.power.equals(2)) {\r\n            switch(this.fname) {\r\n                case SIN:\r\n                    retval = _.parse(format('1/2-cos(2*({0}))/2', a));\r\n                    break;\r\n                case COS:\r\n                    retval = _.parse(format('1/2+cos(2*({0}))/2', a));\r\n                    break;\r\n                case TAN:\r\n                    //retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))', a));\r\n                    retval = _.parse(format('sin({0})^2/cos({0})^2', a));\r\n                    break;\r\n                case COSH:\r\n                    retval = _.parse(format('1/2+cosh(2*({0}))/2', a));\r\n                    break;\r\n                case SINH:\r\n                    retval = _.parse(format('-1/2+cosh(2*({0}))/2', a));\r\n                    break;\r\n                case TANH:\r\n                    retval = _.parse(format('(1+cosh(2*({0})))/(-1+cosh(2*({0})))', a));\r\n                    break;\r\n                case SEC:\r\n                    retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))+1', a));\r\n                    break;\r\n                default:\r\n                    retval = sym;\r\n            }\r\n        }\r\n        else if(this.fname === SEC) {\r\n            retval = _.parse(format('1/cos({0})^({1})', this.args[0], this.power));\r\n        }\r\n        else if(this.fname === CSC) {\r\n            retval = _.parse(format('1/sin({0})^({1})', this.args[0], this.power));\r\n        }\r\n        else if(this.fname === TAN) {\r\n            if(this.power.lessThan(0)) {\r\n                retval = _.parse(format('cos({0})^(-({1}))/sin({0})^({1})', this.args[0], this.power.negate()));\r\n            }\r\n            else {\r\n                retval = _.parse(format('sin({0})^({1})/cos({0})^({1})', this.args[0], this.power));\r\n            }\r\n        }\r\n        else if(this.fname === SIN && this.power.lessThan(0)) {\r\n            retval = _.parse(format('csc({0})^(-({1}))', this.args[0], this.power.negate()));\r\n        }\r\n        else if(this.fname === COS && this.power.lessThan(0)) {\r\n            retval = _.parse(format('sec({0})^(-({1}))', this.args[0], this.power.negate()));\r\n        }\r\n        else if(this.fname === SIN && this.power.equals(3)) {\r\n            retval = _.parse(format('(3*sin({0})-sin(3*({0})))/4', this.args[0]));\r\n        }\r\n        else if(this.fname === COS && this.power.equals(3)) {\r\n            retval = _.parse(format('(cos(3*({0}))+3*cos({0}))/4', this.args[0]));\r\n        }\r\n        //cos(a*x)^(2*n) or sin(a*x)^(2*n)\r\n        else if((this.fname === COS || this.fname === SIN) && even(this.power)) {\r\n            var n = this.power / 2;\r\n            //convert to a double angle\r\n            var double_angle = _.pow(this.clone().toLinear(), _.parse(2)).fnTransform();\r\n            //raise to the n and expand\r\n            var transformed = _.expand(_.pow(double_angle, _.parse(n)));\r\n\r\n            retval = new Symbol(0);\r\n\r\n            transformed.each(function (s) {\r\n                var t = s.fnTransform();\r\n                retval = _.add(retval, t);\r\n            }, true);\r\n        }\r\n        else\r\n            retval = sym;\r\n\r\n        return _.multiply(retval, m);\r\n    };\r\n\r\n    Symbol.prototype.hasTrig = function () {\r\n        if(this.isConstant(true) || this.group === S)\r\n            return false;\r\n        if(this.fname && (core.Utils.in_trig(this.fname) || core.Utils.in_inverse_trig(this.fname)))\r\n            return true;\r\n        if(this.symbols) {\r\n            for(var x in this.symbols)\r\n                if(this.symbols[x].hasTrig())\r\n                    return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    core.Expression.prototype.hasIntegral = function () {\r\n        return this.symbol.hasIntegral();\r\n    };\r\n    /**\r\n     * Attempts to rewrite a symbol under one common denominator\r\n     * @param {Symbol} symbol \r\n     */\r\n    core.Utils.toCommonDenominator = function (symbol) {\r\n        //transform x/a+x -> (ax+x)/a\r\n        if(symbol.isComposite() && symbol.isLinear()) {\r\n            var m = new Symbol(symbol.multiplier);\r\n            var denominator = new Symbol(1);\r\n            var numerator = new Symbol(0);\r\n            symbol.each(function (x) {\r\n                denominator = _.multiply(denominator, x.getDenom());\r\n            }, true);\r\n\r\n            //remove the denomitor in each term\r\n            symbol.each(function (x) {\r\n                var num = x.getNum();\r\n                var den = x.getDenom();\r\n                var factor = _.multiply(num, _.divide(denominator.clone(), den));\r\n                numerator = _.add(numerator, factor);\r\n            });\r\n            var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));\r\n            return retval;\r\n        }\r\n        return symbol;\r\n    };\r\n    //A function to check if a function name is an inverse trig function\r\n    core.Utils.in_inverse_trig = function (x) {\r\n        var inv_trig_fns = [ASIN, ACOS, ATAN, ACSC, ASEC, ACOT];\r\n        return inv_trig_fns.indexOf(x) !== -1;\r\n    };\r\n    //A function to check if a function name is a trig function\r\n    core.Utils.in_trig = function (x) {\r\n        var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];\r\n        return trig_fns.indexOf(x) !== -1;\r\n    };\r\n\r\n    core.Utils.in_htrig = function (x) {\r\n        var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];\r\n        return trig_fns.indexOf(x) !== -1;\r\n    };\r\n\r\n    // Matrix functions\r\n    core.Matrix.jacobian = function (eqns, vars) {\r\n        var jacobian = new core.Matrix();\r\n        //get the variables if not supplied\r\n        if(!vars) {\r\n            vars = core.Utils.arrayGetVariables(eqns);\r\n        }\r\n\r\n        vars.forEach(function (v, i) {\r\n            eqns.forEach(function (eq, j) {\r\n                var e = core.Calculus.diff(eq.clone(), v);\r\n                jacobian.set(j, i, e);\r\n            });\r\n        });\r\n\r\n        return jacobian;\r\n    };\r\n\r\n    core.Matrix.prototype.max = function () {\r\n        var max = new Symbol(0);\r\n        this.each(function (x) {\r\n            var e = x.abs();\r\n            if(e.gt(max))\r\n                max = e;\r\n        });\r\n        return max;\r\n    };\r\n\r\n    core.Matrix.cMatrix = function (value, vars) {\r\n        var m = new core.Matrix();\r\n        //make an initial guess\r\n        vars.forEach(function (v, i) {\r\n            m.set(i, 0, _.parse(value));\r\n        });\r\n        return m;\r\n    };\r\n\r\n    var all_functions = core.Utils.all_functions = function (arr) {\r\n        for(var i = 0, l = arr.length; i < l; i++)\r\n            if(arr[i].group !== FN)\r\n                return false;\r\n        return true;\r\n    },\r\n            cosAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\r\n                var a, b;\r\n                a = symbol1.args[0];\r\n                b = symbol2.args[0];\r\n                return _.parse(format('(sin(({0})+({1}))-sin(({0})-({1})))/2', a, b));\r\n            },\r\n            cosAsinAtransform = core.Utils.cosAsinAtranform = function (symbol1, symbol2) {\r\n                //TODO: temporary fix for integrate(e^x*sin(x)*cos(x)^2).\r\n                //we technically know how to do this transform but more is needed for correct output\r\n                if(Number(symbol2.power) !== 1)\r\n                    return _.multiply(symbol1, symbol2);\r\n                var a;\r\n                a = symbol1.args[0];\r\n                return _.parse(format('(sin(2*({0})))/2', a));\r\n            },\r\n            sinAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\r\n                var a, b;\r\n                a = symbol1.args[0];\r\n                b = symbol2.args[0];\r\n                return _.parse(format('(cos(({0})+({1}))-cos(({0})-({1})))/2', a, b));\r\n            },\r\n            trigTransform = core.Utils.trigTransform = function (arr) {\r\n                var map = {}, symbol, t,\r\n                        retval = new Symbol(1);\r\n                for(var i = 0, l = arr.length; i < l; i++) {\r\n                    symbol = arr[i];\r\n\r\n                    if(symbol.group === FN) {\r\n                        var fname = symbol.fname;\r\n\r\n                        if(fname === COS && map[SIN]) {\r\n\r\n                            if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = cosAsinBtransform(symbol, map[SIN]);\r\n                            }\r\n                            else {\r\n                                t = cosAsinAtransform(symbol, map[SIN]);\r\n                            }\r\n                            delete map[SIN];\r\n\r\n                            retval = _.multiply(retval, t);\r\n                        }\r\n                        else if(fname === SIN && map[COS]) {\r\n                            if(map[COS].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = cosAsinBtransform(symbol, map[COS]);\r\n                            }\r\n                            else {\r\n                                t = cosAsinAtransform(symbol, map[COS]);\r\n                            }\r\n                            delete map[COS];\r\n\r\n                            retval = _.multiply(retval, t);\r\n                        }\r\n                        else if(fname === SIN && map[SIN]) {\r\n                            if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = sinAsinBtransform(symbol, map[SIN]);\r\n                                delete map[SIN];\r\n                            }\r\n                            else {\r\n                                //This should actually be redundant code but let's put just in case\r\n                                t = _.multiply(symbol, map[SIN]);\r\n                                delete map[SIN];\r\n                            }\r\n\r\n                            retval = t;\r\n                        }\r\n                        else {\r\n                            map[fname] = symbol;\r\n                        }\r\n                    }\r\n                    else\r\n                        retval = _.multiply(retval, symbol);\r\n                }\r\n\r\n                //put back the remaining functions\r\n                for(var x in map)\r\n                    retval = _.multiply(retval, map[x]);\r\n\r\n                return retval;\r\n\r\n            };\r\n\r\n    core.Settings.integration_depth = 10;\r\n\r\n    core.Settings.max_lim_depth = 10;\r\n\r\n    var __ = core.Calculus = {\r\n\r\n        version: '1.4.6',\r\n\r\n        sum: function (fn, index, start, end) {\r\n            if(!(index.group === core.groups.S))\r\n                throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\r\n            index = index.value;\r\n            var retval;\r\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\r\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\r\n                start = Number(start);\r\n                end = Number(end);\r\n                retval = core.Utils.block(modifier, function () {\r\n                    var f = fn.text(),\r\n                            subs = {'~': true}, //lock subs. Is this even being used?\r\n                            retval = new core.Symbol(0);\r\n\r\n                    for(var i = start; i <= end; i++) {\r\n                        subs[index] = new Symbol(i);\r\n                        var ans = _.parse(f, subs);\r\n                        retval = _.add(retval, ans);\r\n                    }\r\n                    return retval;\r\n                });\r\n            }\r\n            else {\r\n                retval = _.symfunction('sum', arguments);\r\n            }\r\n\r\n            return retval;\r\n        },\r\n        product: function (fn, index, start, end) {\r\n            if(!(index.group === core.groups.S))\r\n                throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\r\n            index = index.value;\r\n            var retval;\r\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\r\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\r\n                retval = core.Utils.block(modifier, function () {\r\n                    start = Number(start);\r\n                    end = Number(end.multiplier);\r\n\r\n                    var f = fn.text(),\r\n                            subs = {},\r\n                            retval = new core.Symbol(1);\r\n\r\n                    for(var i = start; i <= end; i++) {\r\n                        subs[index] = new Symbol(i);\r\n                        retval = _.multiply(retval, _.parse(f, subs));\r\n                    }\r\n                    return retval;\r\n                });\r\n            }\r\n            else {\r\n                retval = _.symfunction('product', arguments);\r\n            }\r\n\r\n            return retval;\r\n        },\r\n        diff: function (symbol, wrt, nth) {\r\n            if(core.Utils.isVector(symbol)) {\r\n                var vector = new core.Vector([]);\r\n                symbol.each(function (x) {\r\n                    vector.elements.push(__.diff(x, wrt, nth));\r\n                });\r\n                return vector;\r\n            }\r\n            else if(core.Utils.isMatrix(symbol)) {\r\n                var matrix = new core.Matrix();\r\n                symbol.each(function (x, i, j) {\r\n                    matrix.set(i, j, __.diff(x, wrt, nth));\r\n                });\r\n                return matrix;\r\n            }\r\n\r\n            var d = isSymbol(wrt) ? wrt.text() : wrt;\r\n            //the nth derivative\r\n            nth = isSymbol(nth) ? nth.multiplier : nth || 1;\r\n\r\n            if(d === undefined)\r\n                d = core.Utils.variables(symbol)[0];\r\n\r\n            //unwrap sqrt\r\n            if(symbol.group === FN && symbol.fname === SQRT) {\r\n                var s = symbol.args[0],\r\n                        sp = symbol.power.clone();\r\n                //these groups go to zero anyway so why waste time?\r\n                if(s.group !== N || s.group !== P) {\r\n                    s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol(1 / 2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);\r\n                    s.multiplier = s.multiplier.multiply(symbol.multiplier);\r\n                }\r\n\r\n                symbol = s;\r\n            }\r\n\r\n            if(symbol.group === FN && !isSymbol(symbol.power)) {\r\n                var a = derive(_.parse(symbol));\r\n                var b = __.diff(symbol.args[0].clone(), d);\r\n                symbol = _.multiply(a, b);//chain rule\r\n            }\r\n            else {\r\n                symbol = derive(symbol);\r\n            }\r\n\r\n            if(nth > 1) {\r\n                nth--;\r\n                symbol = __.diff(symbol, wrt, nth);\r\n            }\r\n\r\n            return symbol;\r\n\r\n            // Equivalent to \"derivative of the outside\".\r\n            function polydiff(symbol) {\r\n                if(symbol.value === d || symbol.contains(d, true)) {\r\n                    symbol.multiplier = symbol.multiplier.multiply(symbol.power);\r\n                    symbol.power = symbol.power.subtract(new Frac(1));\r\n                    if(symbol.power.equals(0)) {\r\n                        symbol = Symbol(symbol.multiplier);\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            }\r\n            \r\n            function derive(symbol) {\r\n                var g = symbol.group, a, b, cp;\r\n\r\n                if(g === N || g === S && symbol.value !== d || g === P) {\r\n                    symbol = Symbol(0);\r\n                }\r\n                else if(g === S) {\r\n                    symbol = polydiff(symbol);\r\n                }\r\n                else if(g === CB) {\r\n                    var m = symbol.multiplier.clone();\r\n                    symbol.toUnitMultiplier();\r\n                    var retval = _.multiply(product_rule(symbol), polydiff(symbol));\r\n                    retval.multiplier = retval.multiplier.multiply(m);\r\n                    return retval;\r\n                }\r\n                else if(g === FN && symbol.power.equals(1)) {\r\n                    // Table of known derivatives\r\n                    switch(symbol.fname) {\r\n                        case LOG:\r\n                            cp = symbol.clone();\r\n                            symbol = symbol.args[0].clone();//get the arguments\r\n                            symbol.power = symbol.power.negate();\r\n                            symbol.multiplier = cp.multiplier.divide(symbol.multiplier);\r\n                            break;\r\n                        case COS:\r\n                            //cos -> -sin\r\n                            symbol.fname = SIN;\r\n                            symbol.multiplier.negate();\r\n                            break;\r\n                        case SIN:\r\n                            //sin -> cos\r\n                            symbol.fname = COS;\r\n                            break;\r\n                        case TAN:\r\n                            //tan -> sec^2\r\n                            symbol.fname = SEC;\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case SEC:\r\n                            // Use a clone if this gives errors\r\n                            symbol = qdiff(symbol, TAN);\r\n                            break;\r\n                        case CSC:\r\n                            symbol = qdiff(symbol, '-cot');\r\n                            break;\r\n                        case COT:\r\n                            symbol.fname = CSC;\r\n                            symbol.multiplier.negate();\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case ASIN:\r\n                            symbol = _.parse('(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case ACOS:\r\n                            symbol = _.parse('-(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case ATAN:\r\n                            symbol = _.parse('(1+(' + text(symbol.args[0]) + ')^2)^(-1)');\r\n                            break;\r\n                        case ABS:\r\n                            m = symbol.multiplier.clone();\r\n                            symbol.toUnitMultiplier();\r\n                            //depending on the complexity of the symbol it's easier to just parse it into a new symbol\r\n                            //this should really be readdressed soon\r\n                            b = symbol.args[0].clone();\r\n                            b.toUnitMultiplier();\r\n                            symbol = _.parse(inBrackets(text(symbol.args[0])) + '/abs' + inBrackets(text(b)));\r\n                            symbol.multiplier = m;\r\n                            break;\r\n                        case 'parens':\r\n                            //see product rule: f'.g goes to zero since f' will return zero. This way we only get back\r\n                            //1*g'\r\n                            symbol = Symbol(1);\r\n                            break;\r\n                        case 'cosh':\r\n                            //cosh -> -sinh\r\n                            symbol.fname = 'sinh';\r\n                            break;\r\n                        case 'sinh':\r\n                            //sinh -> cosh\r\n                            symbol.fname = 'cosh';\r\n                            break;\r\n                        case TANH:\r\n                            //tanh -> sech^2\r\n                            symbol.fname = SECH;\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case SECH:\r\n                            // Use a clone if this gives errors\r\n                            symbol = qdiff(symbol, '-tanh');\r\n                            break;\r\n                        case CSCH:\r\n                            var arg = String(symbol.args[0]);\r\n                            return _.parse('-coth(' + arg + ')*csch(' + arg + ')');\r\n                            break;\r\n                        case COTH:\r\n                            var arg = String(symbol.args[0]);\r\n                            return _.parse('-csch(' + arg + ')^2');\r\n                            break;\r\n                        case 'asinh':\r\n                            symbol = _.parse('(sqrt(1+(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case 'acosh':\r\n                            symbol = _.parse('(sqrt(-1+(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case 'atanh':\r\n                            symbol = _.parse('(1-(' + text(symbol.args[0]) + ')^2)^(-1)');\r\n                            break;\r\n                        case ASECH:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2-1)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACOTH:\r\n                            symbol = _.parse('-1/((' + symbol.args[0] + ')^2-1)');\r\n                            break;\r\n                        case ACSCH:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2+1)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ASEC:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACSC:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACOT:\r\n                            symbol = _.parse('-1/((' + symbol.args[0] + ')^2+1)');\r\n                            break;\r\n                        case 'S':\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('sin((pi*(' + arg + ')^2)/2)');\r\n                            break;\r\n                        case 'C':\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('cos((pi*(' + arg + ')^2)/2)');\r\n                            break;\r\n                        case 'Si':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('sin(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Shi':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('sinh(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Ci':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('cos(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Chi':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('cosh(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Ei':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('e^(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Li':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('1/' + Settings.LOG + '(' + arg + ')');\r\n                            break;\r\n                        case 'erf':\r\n                            symbol = _.parse('(2*e^(-(' + symbol.args[0] + ')^2))/sqrt(pi)');\r\n                            break;\r\n                        case 'atan2':\r\n                            var x_ = String(symbol.args[0]),\r\n                                    y_ = String(symbol.args[1]);\r\n                            symbol = _.parse('(' + y_ + ')/((' + y_ + ')^2+(' + x_ + ')^2)');\r\n                            break;\r\n                        case 'sign':\r\n                            symbol = new Symbol(0);\r\n                            break;\r\n                        case 'sinc':\r\n                            symbol = _.parse(format('(({0})*cos({0})-sin({0}))*({0})^(-2)', symbol.args[0]));\r\n                            break;\r\n                        case Settings.LOG10:\r\n                            symbol = _.parse('1/((' + symbol.args[0] + ')*' + Settings.LOG + '(10))');\r\n                            break;\r\n                        default:\r\n                            symbol = _.symfunction('diff', [symbol, wrt]);\r\n                    }\r\n                }\r\n                else if(g === EX || g === FN && isSymbol(symbol.power)) {\r\n                    var value;\r\n                    if(g === EX) {\r\n                        value = symbol.value;\r\n                    }\r\n                    else if(g === FN && symbol.contains(d)) {\r\n                        value = symbol.fname + inBrackets(text(symbol.args[0]));\r\n                    }\r\n                    else {\r\n                        value = symbol.value + inBrackets(text(symbol.args[0]));\r\n                    }\r\n                    a = _.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone());\r\n                    b = __.diff(_.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone()), d);\r\n                    symbol = _.multiply(symbol, b);\r\n                }\r\n                else if(g === FN && !symbol.power.equals(1)) {\r\n                    b = symbol.clone();\r\n                    b.toLinear();\r\n                    b.toUnitMultiplier();\r\n                    symbol = _.multiply(polydiff(symbol.clone()), derive(b));\r\n                }\r\n                else if(g === CP || g === PL) {\r\n                    // Note: Do not use `parse` since this puts back the sqrt and causes a bug as in #610. Use clone.\r\n                    var c = symbol.clone();\r\n                    var result = new Symbol(0);\r\n                    for(var x in symbol.symbols) {\r\n                        result = _.add(result, __.diff(symbol.symbols[x].clone(), d));\r\n                    }\r\n                    symbol = _.multiply(polydiff(c), result);\r\n                }\r\n\r\n                symbol.updateHash();\r\n\r\n                return symbol;\r\n            }\r\n            ;\r\n\r\n            function qdiff(symbol, val, altVal) {\r\n                return _.multiply(symbol, _.parse(val + inBrackets(altVal || text(symbol.args[0]))));\r\n            }\r\n            ;\r\n\r\n            function product_rule(symbol) {\r\n                //grab all the symbols within the CB symbol\r\n                var symbols = symbol.collectSymbols(),\r\n                        result = new Symbol(0),\r\n                        l = symbols.length;\r\n                //loop over all the symbols\r\n                for(var i = 0; i < l; i++) {\r\n                    var df = __.diff(symbols[i].clone(), d);\r\n                    for(var j = 0; j < l; j++) {\r\n                        //skip the symbol of which we just pulled the derivative\r\n                        if(i !== j) {\r\n                            //multiply out the remaining symbols\r\n                            df = _.multiply(df, symbols[j].clone());\r\n                        }\r\n                    }\r\n                    //add the derivative to the result\r\n                    result = _.add(result, df);\r\n                }\r\n                return result; //done\r\n            }\r\n            ;\r\n        },\r\n        integration: {\r\n            u_substitution: function (symbols, dx) {\r\n                function try_combo(a, b, f) {\r\n                    var d = __.diff(b, dx);\r\n                    var q = f ? f(a, b) : _.divide(a.clone(), d);\r\n                    if(!q.contains(dx, true))\r\n                        return q;\r\n                    return null;\r\n                }\r\n                function do_fn_sub(fname, arg) {\r\n                    var subbed = __.integrate(_.symfunction(fname, [new Symbol(u)]), u, 0);\r\n                    subbed = subbed.sub(new Symbol(u), arg);\r\n                    subbed.updateHash();\r\n                    return subbed;\r\n                }\r\n\r\n                var a = symbols[0].clone(),\r\n                        b = symbols[1].clone(),\r\n                        g1 = a.group,\r\n                        g2 = b.group,\r\n                        //may cause problems if person is using this already. Will need\r\n                        //to find algorithm for detecting conflict\r\n                        u = '__u__',\r\n                        Q;\r\n                if(g1 === FN && g2 !== FN) {\r\n                    //e.g. 2*x*cos(x^2)\r\n                    var arg = a.args[0];\r\n                    Q = try_combo(b, arg.clone());\r\n                    if(Q)\r\n                        return _.multiply(Q, do_fn_sub(a.fname, arg));\r\n                    Q = try_combo(b, a);\r\n                    if(Q) {\r\n                        return __.integration.poly_integrate(a);\r\n                    }\r\n                }\r\n                else if(g2 === FN && g1 !== FN) {\r\n                    //e.g. 2*(x+1)*cos((x+1)^2\r\n                    var arg = b.args[0];\r\n                    Q = try_combo(a, arg.clone());\r\n                    if(Q)\r\n                        return _.multiply(Q, do_fn_sub(b.fname, arg));\r\n                }\r\n                else if(g1 === FN && g2 === FN) {\r\n                    Q = try_combo(a.clone(), b.clone());\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                    Q = try_combo(b.clone(), a.clone());\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                }\r\n                else if(g1 === EX && g2 !== EX) {\r\n                    var p = a.power;\r\n                    Q = try_combo(b, p.clone());\r\n                    if(!Q) {\r\n                        //one more try\r\n                        var dc = __.integration.decompose_arg(p.clone(), dx);\r\n                        //consider the possibility of a^x^(n-1)*x^n dx\r\n                        var xp = __.diff(dc[2].clone(), dx);\r\n                        var dc2 = __.integration.decompose_arg(xp.clone(), dx);\r\n                        //if their powers equal, so if dx*p == b\r\n                        if(_.multiply(dc[1], dc2[1]).power.equals(b.power)) {\r\n                            var m = _.divide(dc[0].clone(), dc2[0].clone());\r\n\r\n                            var new_val = _.multiply(m.clone(), _.pow(new Symbol(a.value), _.multiply(dc[0], new Symbol(u))));\r\n                            new_val = _.multiply(new_val, new Symbol(u));\r\n                            return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());\r\n                        }\r\n\r\n                    }\r\n                    var integrated = __.integrate(a.sub(p.clone(), new Symbol(u)), u, 0),\r\n                            retval = _.multiply(integrated.sub(new Symbol(u), p), Q);\r\n\r\n\r\n                    return retval;\r\n                }\r\n                else if(g2 === EX && g1 !== EX) {\r\n                    var p = b.power;\r\n                    Q = try_combo(a, p.clone());\r\n                    var integrated = __.integrate(b.sub(p, new Symbol(u)), u, 0);\r\n                    return _.multiply(integrated.sub(new Symbol(u), p), Q);\r\n                }\r\n                else if(a.isComposite() || b.isComposite()) {\r\n                    var f = function (a, b) {\r\n                        var d = __.diff(b, dx);\r\n                        var A = core.Algebra.Factor.factor(a),\r\n                                B = core.Algebra.Factor.factor(d);\r\n                        var q = _.divide(A, B);\r\n                        return q;\r\n                    };\r\n                    var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(),\r\n                            f2 = b.isComposite() ? b.clone().toLinear() : b.clone();\r\n                    Q = try_combo(f1.clone(), f2.clone(), f);\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                    Q = try_combo(f2.clone(), f1.clone(), f);\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(a), Q);\r\n                }\r\n            },\r\n            //simple integration of a single polynomial x^(n+1)/(n+1)\r\n            poly_integrate: function (x) {\r\n                var p = x.power.toString(),\r\n                        m = x.multiplier.toDecimal(),\r\n                        s = x.toUnitMultiplier().toLinear();\r\n                if(Number(p) === -1) {\r\n                    return _.multiply(new Symbol(m), _.symfunction(LOG, [s]));\r\n                }\r\n                return _.parse(format('({0})*({1})^(({2})+1)/(({2})+1)', m, s, p));\r\n            },\r\n            //If we're just spinning wheels we want to stop. This is why we \r\n            //wrap integration in a try catch block and call this to stop.\r\n            stop: function (msg) {\r\n                msg = msg || 'Unable to compute integral!';\r\n                core.Utils.warn(msg);\r\n                throw new NoIntegralFound(msg);\r\n            },\r\n            partial_fraction: function (input, dx, depth, opt) {\r\n                //TODO: This whole thing needs to be rolled into one but for now I'll leave it as two separate parts\r\n                if(!isSymbol(dx))\r\n                    dx = _.parse(dx);\r\n\r\n                var result, partial_fractions;\r\n                result = new Symbol(0);\r\n                partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);\r\n\r\n                if(partial_fractions.group === CB && partial_fractions.isLinear()) {\r\n                    //perform a quick check to make sure that all partial fractions are linear\r\n                    partial_fractions.each(function (x) {\r\n                        if(!x.isLinear())\r\n                            __.integration.stop();\r\n                    });\r\n                    partial_fractions.each(function (x) {\r\n                        result = _.add(result, __.integrate(x, dx, depth, opt));\r\n                    });\r\n                }\r\n                else {\r\n                    result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));\r\n                }\r\n                return result;\r\n            },\r\n            get_udv: function (symbol) {\r\n                var parts = [[/*L*/], [/*I*/], [/*A*/], [/*T*/], [/*E*/]];\r\n                //first we sort them \r\n                var setSymbol = function (x) {\r\n                    var g = x.group;\r\n                    if(g === FN) {\r\n                        var fname = x.fname;\r\n                        if(core.Utils.in_trig(fname) || core.Utils.in_htrig(fname))\r\n                            parts[3].push(x);\r\n                        else if(core.Utils.in_inverse_trig(fname))\r\n                            parts[1].push(x);\r\n                        else if(fname === LOG)\r\n                            parts[0].push(x);\r\n                        else {\r\n                            __.integration.stop();\r\n                        }\r\n                    }\r\n                    else if(g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {\r\n                        parts[2].push(x);\r\n                    }\r\n                    else if(g === EX || x.isComposite() && !x.isLinear())\r\n                        parts[4].push(x);\r\n                    else\r\n                        __.integration.stop();\r\n                };\r\n\r\n                if(symbol.group === CB)\r\n                    symbol.each(function (x) {\r\n                        setSymbol(Symbol.unwrapSQRT(x, true));\r\n                    });\r\n                else\r\n                    setSymbol(symbol);\r\n                var u, dv = new Symbol(1);\r\n                //compile u and dv\r\n                for(var i = 0; i < 5; i++) {\r\n                    var part = parts[i], t,\r\n                            l = part.length;\r\n                    if(l > 0) {\r\n                        if(l > 1) {\r\n                            t = new Symbol(1);\r\n                            for(var j = 0; j < l; j++)\r\n                                t = _.multiply(t, part[j].clone());\r\n                        }\r\n                        else\r\n                            t = part[0].clone();\r\n\r\n                        if(!u) {\r\n                            u = t;//the first u encountered gets chosen\r\n                            u.multiplier = u.multiplier.multiply(symbol.multiplier); //the first one gets the mutliplier\r\n                        }\r\n                        else\r\n                            dv = _.multiply(dv, t); //everything else belongs to dv\r\n                    }\r\n                }\r\n\r\n                return [u, dv];\r\n            },\r\n\r\n            trig_sub: function (symbol, dx, depth, opt, parts, symbols) {\r\n                parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);\r\n                var b = parts[3],\r\n                        ax = parts[2],\r\n                        a = parts[0],\r\n                        x = parts[1];\r\n                if(x.power.equals(2) && a.greaterThan(0)) {\r\n                    //use tan(x)\r\n                    var t = core.Utils.getU(symbol), //get an appropriate u\r\n                            u = _.parse(TAN + inBrackets(t)), //u\r\n                            du = _.parse(SEC + inBrackets(t) + '^2'), //du\r\n                            f = _.multiply(symbol.sub(x, u), du);\r\n                    var integral = __.integrate(f, t, depth, opt).sub(u, x);\r\n                    core.Utils.clearU(u);\r\n                    return integral;\r\n                }\r\n            },\r\n\r\n            by_parts: function (symbol, dx, depth, o) {\r\n                o.previous = o.previous || [];\r\n                var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s;\r\n                //first LIATE\r\n                udv = __.integration.get_udv(symbol);\r\n                u = udv[0];\r\n                dv = udv[1];\r\n                du = Symbol.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true);\r\n                c = du.clone().stripVar(dx);\r\n                //strip any coefficients\r\n                du = _.divide(du, c.clone());\r\n                v = __.integrate(dv.clone(), dx, depth || 0);\r\n                vdu = _.multiply(v.clone(), du);\r\n                vdu_s = vdu.toString();\r\n                //currently only supports e^x*(some trig)\r\n                if(o.previous.indexOf(vdu_s) !== -1 && (core.Utils.in_trig(u.fname)) && dv.isE()) {\r\n                    //We're going to exploit the fact that vdu can never be constant\r\n                    //to work out way out of this cycle. We'll return the length of\r\n                    //the this.previous array until we're back at level one\r\n                    o.is_cyclic = true;\r\n                    //return the integral. \r\n                    return new Symbol(1);\r\n                }\r\n                else\r\n                    o.previous.push(vdu_s);\r\n\r\n                uv = _.multiply(u, v);\r\n                //clear the multiplier so we're dealing with a bare integral\r\n                m = vdu.multiplier.clone();\r\n                vdu.toUnitMultiplier();\r\n                integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c);\r\n                integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);\r\n                retval = _.subtract(uv, integral_vdu);\r\n                //we know that there cannot be constants so they're a holdover from a cyclic integral\r\n                if(o.is_cyclic) {\r\n                    //start popping the previous stack so we know how deep in we are\r\n                    o.previous.pop();\r\n                    if(o.previous.length === 0) {\r\n                        retval = _.expand(retval);\r\n                        var rem = new Symbol(0);\r\n                        retval.each(function (x) {\r\n                            if(!x.contains(dx))\r\n                                rem = _.add(rem, x.clone());\r\n                        });\r\n                        //get the actual uv\r\n                        retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol(1), rem));\r\n                    }\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            /*\r\n             * dependents: [Solve, integrate]\r\n             */\r\n            decompose_arg: core.Utils.decompose_fn\r\n        },\r\n        //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output\r\n        integrate: function (original_symbol, dt, depth, opt) {\r\n            //assume integration wrt independent variable if expression only has one variable\r\n            if(!dt) {\r\n                var vars = core.Utils.variables(original_symbol);\r\n                if(vars.length === 1)\r\n                    dt = vars[0];\r\n                //defaults to x\r\n                dt = dt || 'x';\r\n            }\r\n            //add support for integrating vectors\r\n            if(core.Utils.isVector(original_symbol)) {\r\n                var vector = new core.Vector([]);\r\n                original_symbol.each(function (x) {\r\n                    vector.elements.push(__.integrate(x, dt));\r\n                });\r\n                return vector;\r\n            }\r\n            if(!isNaN(dt))\r\n                _.error('variable expected but received ' + dt);\r\n            //get rid of constants right away\r\n            if(original_symbol.isConstant(true))\r\n                return _.multiply(original_symbol.clone(), _.parse(dt));\r\n\r\n            //configurations options for integral. This is needed for tracking extra options\r\n            //e.g. cyclic integrals or additional settings\r\n            opt = opt || {};\r\n            return core.Utils.block('PARSE2NUMBER', function () {\r\n                //make a note of the original symbol. Set only if undefined\r\n                depth = depth || 0;\r\n                var dx = isSymbol(dt) ? dt.toString() : dt,\r\n                        //we don't want the symbol in sqrt form. x^(1/2) is prefererred\r\n                        symbol = Symbol.unwrapSQRT(original_symbol.clone(), true),\r\n                        g = symbol.group,\r\n                        retval;\r\n\r\n                try {\r\n                    //We stop integration after x amount of recursive calls\r\n                    if(++depth > core.Settings.integration_depth)\r\n                        __.integration.stop('Maximum depth reached. Exiting!');\r\n\r\n                    //constants. We first eliminate anything that doesn't have dx. Everything after this has \r\n                    //to have dx or else it would have been taken care of below\r\n                    if(!symbol.contains(dx, true)) {\r\n                        retval = _.multiply(symbol.clone(), _.parse(dx));\r\n                    }\r\n                    //e.g. 2*x\r\n                    else if(g === S) {\r\n                        retval = __.integration.poly_integrate(symbol, dx, depth);\r\n                    }\r\n                    else if(g === EX) {\r\n                        if(symbol.previousGroup === FN && !(symbol.fname === 'sqrt' || symbol.fname === Settings.PARENTHESIS))\r\n                            __.integration.stop();\r\n                        //check the base\r\n                        if(symbol.contains(dx) && symbol.previousGroup !== FN) {\r\n                            //if the symbol also contains dx then we stop since we currently \r\n                            //don't know what to do with it e.g. x^x\r\n                            if(symbol.power.contains(dx))\r\n                                __.integration.stop();\r\n                            else {\r\n                                var t = __.diff(symbol.clone().toLinear(), dx);\r\n                                if(t.contains(dx))\r\n                                    __.integration.stop();\r\n                                //since at this point it's the base only then we do standard single poly integration\r\n                                //e.g. x^y\r\n                                retval = __.integration.poly_integrate(symbol, dx, depth);\r\n                            }\r\n                        }\r\n                        //e.g. a^x or 9^x\r\n                        else {\r\n                            var a = __.diff(symbol.power.clone(), dx);\r\n                            if(a.contains(dx)) {\r\n                                var aa = a.stripVar(dx),\r\n                                        x = _.divide(a.clone(), aa.clone());\r\n                                if(x.group === S && x.isLinear()) {\r\n                                    aa.multiplier = aa.multiplier.divide(new Frac(2));\r\n                                    return _.parse(format('({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))', aa, dx, symbol.multiplier));\r\n                                }\r\n                                else\r\n                                    __.integration.stop();\r\n                            }\r\n                            if(symbol.isE()) {\r\n                                if(a.isLinear())\r\n                                    retval = symbol;\r\n                                else {\r\n                                    if(a.isE() && a.power.group === S && a.power.power.equals(1))\r\n                                        retval = _.multiply(_.symfunction('Ei', [symbol.power.clone()]), symbol.power);\r\n                                    else\r\n                                        __.integration.stop();\r\n                                }\r\n                            }\r\n                            else {\r\n                                var d = _.symfunction(LOG, [_.parse(symbol.value)]);\r\n                                retval = _.divide(symbol, d);\r\n                            }\r\n                            retval = _.divide(retval, a);\r\n                        }\r\n                    }\r\n                    else if(symbol.isComposite() && symbol.isLinear()) {\r\n                        var m = _.parse(symbol.multiplier);\r\n                        symbol.toUnitMultiplier();\r\n                        retval = new Symbol(0);\r\n                        symbol.each(function (x) {\r\n                            retval = _.add(retval, __.integrate(x, dx, depth));\r\n                        });\r\n                        retval = _.multiply(m, retval);\r\n                    }\r\n                    else if(g === CP) {\r\n                        if(symbol.power.greaterThan(1))\r\n                            symbol = _.expand(symbol);\r\n                        if(symbol.power.equals(1)) {\r\n                            retval = new Symbol(0);\r\n                            symbol.each(function (x) {\r\n                                retval = _.add(retval, __.integrate(x, dx, depth));\r\n                            }, true);\r\n                        }\r\n                        else {\r\n                            var p = Number(symbol.power),\r\n                                    m = symbol.multiplier.clone();//temporarily remove the multiplier\r\n                            symbol.toUnitMultiplier();\r\n                            var //below we consider the form ax+b\r\n                                    fn = symbol.clone().toLinear(), //get just the pure function without the power\r\n                                    decomp = __.integration.decompose_arg(fn, dx),\r\n                                    //I have no idea why I used bx+a and not ax+b. TODO change this to something that makes sense\r\n                                    b = decomp[3],\r\n                                    ax = decomp[2],\r\n                                    a = decomp[0],\r\n                                    x = decomp[1];\r\n                            if(p === -1 && x.group !== PL && x.power.equals(2)) {\r\n                                var b_is_positive = isInt(b) ? b > 0 : true;\r\n                                //we can now check for atan\r\n                                if(x.group === S && x.power.equals(2) && b_is_positive) {\r\n                                    ////then we have atan\r\n                                    //abs is redundants since the sign appears in both denom and num.\r\n                                    var unwrapAbs = function (s) {\r\n                                        var result = new Symbol(1);\r\n                                        s.each(function (x) {\r\n                                            result = _.multiply(result, x.fname === 'abs' ? x.args[0] : x);\r\n                                        });\r\n                                        return result;\r\n                                    };\r\n                                    var A = a.clone(),\r\n                                            B = b.clone();\r\n                                    A = _.pow(A, new Symbol(1 / 2));\r\n                                    B = _.pow(B, new Symbol(1 / 2));\r\n                                    //unwrap abs\r\n\r\n                                    var d = _.multiply(unwrapAbs(B), unwrapAbs(A)),\r\n                                            f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);\r\n                                    retval = _.divide(f, d);\r\n                                }\r\n                                else if(x.group === S && x.isLinear()) {\r\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\r\n                                }\r\n                                else {\r\n                                    //1/(x^4+1)\r\n                                    if(x.power.equals(4)) {\r\n                                        //https://www.freemathhelp.com/forum/threads/55678-difficult-integration-int-1-(1-x-4)-dx\r\n                                        var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;\r\n                                        var br = inBrackets;\r\n                                        //apply rule: ax^4+b = (√ax^2+√2∜a∜bx+√b)(√ax^2-√2∜a∜bx+√b)\r\n                                        //get quadratic factors\r\n                                        A = _.parse(SQRT + br(a) + '*' + dx + '^2');\r\n                                        B = _.parse(SQRT + br(2) + '*' + br(a) + '^' + br('1/4') + '*' + br(b) + '^' + br('1/4') + '*' + dx);\r\n                                        C = _.parse(SQRT + br(b));\r\n                                        f1 = _.add(_.add(A.clone(), B.clone()), C.clone());\r\n                                        f2 = _.add(_.subtract(A, B), C);\r\n                                        //calculate numerators: [D+E, D-E] -> [√2*b^(3/4)+√b∜ax, √2*b^(3/4)-√b∜ax]\r\n                                        D = _.parse(SQRT + br(2) + '*' + br(b) + '^' + br('3/4'));\r\n                                        E = _.parse(SQRT + br(b) + '*' + br(b) + '^' + br('1/4') + '*' + dx);\r\n                                        //let F = 2b√2∜b\r\n                                        F = _.parse(2 + '*' + br(b) + '*' + SQRT + br(2) + '*' + br(b) + '^' + br('1/4'));\r\n                                        //calculate the factors\r\n                                        L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));\r\n                                        L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));\r\n                                        retval = _.add(\r\n                                                __.integrate(L1, dx, depth, opt),\r\n                                                __.integrate(L2, dx, depth, opt)\r\n                                                );\r\n                                    }\r\n                                    else\r\n                                        //let's try partial fractions\r\n                                        retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                }\r\n                            }\r\n                            else if(p === -1 / 2) {\r\n                                //detect asin and atan\r\n                                if(x.group === S && x.power.equals(2)) {\r\n                                    if(ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {\r\n                                        a.negate();\r\n                                        //it's asin\r\n                                        if(b.isConstant() && a.isConstant()) {\r\n                                            var d = _.symfunction(SQRT, [a.clone()]),\r\n                                                    d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);\r\n                                            retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);\r\n                                        }\r\n                                        //I'm not sure about this one. I'm trusting Wolfram Alpha here\r\n                                        else {\r\n                                            var sqrt_a = _.symfunction(SQRT, [a]),\r\n                                                    sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());\r\n                                            retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        /*WHAT HAPPENS HERE???? e.g. integrate(3/sqrt(-a+b*x^2),x) or integrate(3/sqrt(a+b*x^2),x)*/\r\n                                        __.integration.stop();\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    //This would be a case like 1/(sqrt(1-x^3) or 1/(1-(x+1)^2)\r\n                                    __.integration.stop();\r\n                                }\r\n                            }\r\n                            else if(p === 1/2 && x.power.equals(2) && a.greaterThan(0)) {\r\n                                // TODO: Revisit\r\n                                __.integration.stop();\r\n                            }\r\n                            else {\r\n                                if(x.isLinear() && x.group !== PL)\r\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\r\n                                else if(x.power.equals(2) && a.greaterThan(0)) {\r\n                                    var sqa, sqb, aob, bsqi, n, integral, u, v, uv;\r\n                                    //1/(a*x^2+b^2)^n\r\n                                    //strip the value of b so b = 1\r\n                                    sqa = _.parse(SQRT + inBrackets(a)); //strip a so b = 1\r\n                                    sqb = _.parse(SQRT + inBrackets(b));\r\n                                    aob = _.multiply(sqa.clone(), sqb.clone()).invert();\r\n                                    bsqi = _.pow(b, new Symbol(symbol.power));\r\n                                    uv = core.Utils.getU(symbol);\r\n                                    u = _.multiply(aob, x.clone().toLinear());\r\n                                    v = _.parse(ATAN + inBrackets(u));\r\n                                    //the conversion will be 1+tan(x)^2 -> sec(x)^2\r\n                                    //since the denominator is now (sec(x)^2)^n and the numerator is sec(x)^2 \r\n                                    //then the remaining sec will be (n-1)*2;\r\n                                    var n = (Math.abs(symbol.power) - 1) * 2;\r\n                                    //1/sec(x)^n can now be converted to cos(x)^n and we can pull the integral of that\r\n                                    var integral = __.integrate(_.parse(COS + inBrackets(uv) + '^' + n));\r\n                                    core.Utils.clearU(uv);\r\n                                    return _.multiply(integral.sub(uv, v), bsqi);\r\n                                }\r\n                                else {\r\n                                    if(symbol.group !== CB && !symbol.power.lessThan(0)) {\r\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                    }\r\n                                    else {\r\n                                        var f = symbol.clone().toLinear();\r\n                                        var factored = core.Algebra.Factor.factor(f);\r\n                                        var was_factored = factored.toString() !== f.toString();\r\n                                        if(core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) {\r\n                                            try {\r\n                                                var f1, fx, u, sq;\r\n                                                sq = core.Algebra.sqComplete(f, dx);\r\n                                                u = core.Utils.getU(f);\r\n                                                f1 = sq.f.sub(sq.a, u);\r\n                                                fx = _.pow(f1, _.parse(symbol.power));\r\n                                                retval = __.integrate(fx, u).sub(u, sq.a);\r\n                                            }\r\n                                            catch(e) {\r\n                                                __.integration.stop();\r\n                                            }\r\n                                        }\r\n                                        else\r\n                                            retval = __.integration.partial_fraction(symbol, dx, depth, opt);\r\n                                    }\r\n                                }\r\n                            }\r\n                            retval.multiplier = retval.multiplier.multiply(m);\r\n                        }\r\n                    }\r\n                    else if(g === FN) {\r\n                        var arg = symbol.args[0],\r\n                                m = symbol.multiplier.clone();\r\n                        symbol.toUnitMultiplier();\r\n                        var decomp = __.integration.decompose_arg(arg, dx);\r\n                        //easies way I can think of to get the coefficient and to make sure\r\n                        //that the symbol is linear wrt dx. I'm not actually trying to get the \r\n                        //derivative\r\n                        var a = decomp[0],\r\n                                x = decomp[1],\r\n                                fname = symbol.fname;\r\n                        //log is a special case that can be handled with integration by parts\r\n                        if(fname === LOG || (fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear())) {\r\n                            /*integration by parts */\r\n                            var p = symbol.power.toString();\r\n                            if(isInt(p))\r\n                                depth = depth - p; //it needs more room to find the integral\r\n\r\n                            if(!arg.isComposite())\r\n                                retval = _.multiply(_.parse(m), __.integration.by_parts(symbol, dx, depth, opt));\r\n                            else {\r\n                                //integral u du\r\n                                var u = core.Utils.getU(symbol);\r\n                                var f = _.pow(_.parse(LOG + inBrackets(u)), new Symbol(p));\r\n                                var du = __.diff(arg, dx);\r\n                                var u_du = _.multiply(f, du);\r\n                                var integral = __.integrate(u_du, u, depth, opt);\r\n                                retval = _.multiply(_.parse(m), integral.sub(u, arg));\r\n                            }\r\n\r\n                        }\r\n                        else if(fname === TAN && symbol.power.lessThan(0)) {\r\n                            //convert to cotangent\r\n                            var sym = symbol.clone();\r\n                            sym.power.negate();\r\n                            sym.fname = COT;\r\n                            return _.multiply(_.parse(m), __.integrate(sym, dx, depth));\r\n                        }\r\n                        else {\r\n                            if(!a.contains(dx, true) && symbol.isLinear()) { //perform a deep search for safety\r\n                                //first handle the special cases \r\n                                if(fname === ABS) {\r\n                                    //REVISIT **TODO**\r\n                                    var x = _.divide(arg.clone(), a.clone());\r\n                                    if(x.group === S && !x.power.lessThan(0)) {\r\n                                        if(core.Utils.even(x.power)) {\r\n                                            retval = __.integrate(arg, dx, depth);\r\n                                        }\r\n                                        else {\r\n                                            var integrated = __.integrate(x, dx, depth);\r\n                                            integrated.power = integrated.power.subtract(new Frac(1));\r\n                                            retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);\r\n                                        }\r\n                                    }\r\n                                    else\r\n                                        __.integration.stop();\r\n                                }\r\n                                else {\r\n                                    var ag = symbol.args[0].group,\r\n                                            decomposed = __.integration.decompose_arg(arg, dx);\r\n\r\n                                    if(!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc())\r\n                                        __.integration.stop();\r\n                                    /**TODO**/ //ASIN, ACOS, ATAN\r\n                                    switch(fname) {\r\n                                        case COS:\r\n                                            retval = _.symfunction(SIN, [arg]);\r\n                                            break;\r\n                                        case SIN:\r\n                                            retval = _.symfunction(COS, [arg]);\r\n                                            retval.negate();\r\n                                            break;\r\n                                        case TAN:\r\n                                            retval = _.parse(format(Settings.LOG + '(sec({0}))', arg));\r\n                                            break;\r\n                                        case SEC:\r\n                                            retval = _.parse(format(Settings.LOG + '(tan({0})+sec({0}))', arg));\r\n                                            break;\r\n                                        case CSC:\r\n                                            retval = _.parse(format('-' + Settings.LOG + '(csc({0})+cot({0}))', arg));\r\n                                            break;\r\n                                        case COT:\r\n                                            retval = _.parse(format(Settings.LOG + '(sin({0}))', arg));\r\n                                            break;\r\n                                        case SINH:\r\n                                            retval = _.symfunction(COSH, [arg]);\r\n                                            break;\r\n                                        case COSH:\r\n                                            retval = _.symfunction(SINH, [arg]);\r\n                                            break;\r\n                                        case TANH:\r\n                                            retval = _.parse(format(Settings.LOG + '(cosh({0}))', arg));\r\n                                            break;\r\n                                        case ASEC:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACSC:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACOT:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                            //inverse htrig\r\n                                        case ASECH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACSCH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACOTH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                            //end inverse htrig\r\n                                            //htrigh\r\n                                        case SECH:\r\n                                            retval = _.parse(format('atan(sinh({0}))', arg));\r\n                                            break;\r\n                                        case CSCH:\r\n                                            retval = _.parse(format(Settings.LOG + '(tanh(({0})/2))', arg));\r\n                                            break;\r\n                                        case COTH:\r\n                                            retval = _.parse(format(Settings.LOG + '(sinh({0}))', arg));\r\n                                            break;\r\n                                            //end htrig\r\n                                        case EXP:\r\n                                            retval = __.integrate(_.parse(format('e^({0})', arg)), dx, depth);\r\n                                            break;\r\n                                        case 'S':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            var b_ = dc[3];\r\n                                            retval = _.parse(format('(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)', a_, b_, x));\r\n                                            break;\r\n                                        case 'C':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            var b_ = dc[3];\r\n                                            retval = _.parse(format('(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)', a_, b_, x_));\r\n                                            break;\r\n                                        case 'erf':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            retval = _.parse(format('e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))', a_, x_, arg));\r\n                                            break;\r\n                                        case 'sign':\r\n                                            retval = _.multiply(symbol.clone(), arg.clone());\r\n                                            break;\r\n                                        default:\r\n                                            __.integration.stop();\r\n                                    }\r\n\r\n                                    retval = _.divide(retval, a);\r\n                                }\r\n                            }\r\n                            else if(x.isLinear()) {\r\n                                if(fname === COS || fname === SIN) {\r\n                                    var p = Number(symbol.power);\r\n                                    //check to see if it's negative and then just transform it to sec or csc\r\n                                    if(p < 0) {\r\n                                        symbol.fname = fname === SIN ? CSC : SEC;\r\n                                        symbol.invert().updateHash();\r\n                                        retval = __.integrate(symbol, dx, depth);\r\n                                    }\r\n                                    else {\r\n                                        var arg = symbol.args[0],\r\n                                                rd = symbol.clone(), //cos^(n-1)\r\n                                                rd2 = symbol.clone(), //cos^(n-2)\r\n                                                q = new Symbol((p - 1) / p), //\r\n                                                na = _.multiply(a.clone(), new Symbol(p)).invert(); //1/(n*a)\r\n                                        rd.power = rd.power.subtract(new Frac(1));\r\n                                        rd2.power = rd2.power.subtract(new Frac(2));\r\n\r\n                                        var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);\r\n                                        if(fname === SIN)\r\n                                            t.negate();\r\n                                        retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));\r\n                                    }\r\n                                }\r\n                                //tan(x)^n or cot(x)^n\r\n                                else if(fname === TAN || fname === COT) {\r\n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\r\n                                    if(symbol.args[0].isLinear(dx)) {\r\n                                        var n = symbol.power.subtract(new Frac(1)).toString(),\r\n                                                r = symbol.clone().toUnitMultiplier(),\r\n                                                w = _.parse(format((fname === COT ? '-' : '') + '1/({2}*{0})*{3}({1})^({0})', n, arg, a, fname));\r\n                                        r.power = r.power.subtract(new Frac(2));\r\n                                        if(r.power.equals(0))\r\n                                            r = _.parse(r);\r\n                                        retval = _.subtract(w, __.integrate(r, dx, depth));\r\n                                    }\r\n                                }\r\n                                //sec(x)^n or csc(x)^n\r\n                                else if(fname === SEC || fname === CSC) {\r\n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\r\n                                    var n1 = symbol.power.subtract(new Frac(1)).toString(),\r\n                                            n2 = symbol.power.subtract(new Frac(2)).toString(),\r\n                                            f2 = fname === SEC ? TAN : COT,\r\n                                            r = symbol.clone().toUnitMultiplier(),\r\n                                            parse_str = format((fname === CSC ? '-' : '') + '1/({0}*{1})*{4}({3})^({2})*{5}({3})', a, n1, n2, arg, fname, f2),\r\n                                            w = _.parse(parse_str);\r\n                                    r.power = r.power.subtract(new Frac(2));\r\n                                    if(r.power.equals(0))\r\n                                        r = _.parse(r);\r\n                                    retval = _.add(w, _.multiply(new Symbol(n2 / n1), __.integrate(r, dx, depth)));\r\n                                }\r\n                                else if((fname === COSH || fname === SINH) && symbol.power.equals(2)) {\r\n                                    retval = __.integrate(symbol.fnTransform(), dx, depth);\r\n                                }\r\n                                else\r\n                                    __.integration.stop();\r\n                            }\r\n                            else\r\n                                __.integration.stop();\r\n\r\n                            retval.multiplier = retval.multiplier.multiply(m);\r\n                        }\r\n                    }\r\n                    else if(g === PL) {\r\n                        retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                    }\r\n                    else if(g === CB) {\r\n                        var den = symbol.getDenom();\r\n                        if(den.group === S)\r\n                            symbol = _.expand(symbol);\r\n\r\n                        //separate the coefficient since all we care about are symbols containing dx\r\n                        var coeff = symbol.stripVar(dx);\r\n                        //now get only those that apply\r\n                        var cfsymbol = _.divide(symbol.clone(), coeff.clone()); //a coeff free symbol\r\n                        //peform a correction for stripVar. This is a serious TODO!\r\n                        if(coeff.contains(dx)) {\r\n                            cfsymbol = _.multiply(cfsymbol, coeff);\r\n                            coeff = new Symbol(1);\r\n                        }\r\n\r\n                        //if we only have one symbol left then let's not waste time. Just pull the integral\r\n                        //and let the chips fall where they may\r\n                        if(cfsymbol.group !== CB) {\r\n                            if(cfsymbol.equals(1)) {\r\n                                return __.integrate(_.expand(symbol), dx, depth);\r\n                            }\r\n\r\n                            //only factor for multivariate which are polynomials\r\n                            if(cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {\r\n                                cfsymbol = core.Algebra.Factor.factor(cfsymbol);\r\n                            }\r\n\r\n                            retval = __.integrate(cfsymbol, dx, depth);\r\n                        }\r\n                        else {\r\n                            //we collect the symbols and sort them descending group, descending power, descending alpabethically\r\n                            var symbols = cfsymbol.collectSymbols().sort(function (a, b) {\r\n                                if(a.group === b.group) {\r\n                                    if(Number(a.power) === Number(b.power))\r\n                                        if(a < b)\r\n                                            return 1; //I want sin first\r\n                                        else\r\n                                            return -1;\r\n                                    return b.power - a.power; //descending power\r\n                                }\r\n                                return b.group - a.group; //descending groups\r\n                            }).map(function (x) {\r\n                                var unwrapped = Symbol.unwrapSQRT(x, true);\r\n                                if(unwrapped.fname === EXP) {\r\n                                    return _.parse(format('({1})*e^({0})', unwrapped.args[0], unwrapped.multiplier));\r\n                                }\r\n                                return unwrapped;\r\n                            });\r\n                            var l = symbols.length;\r\n                            if(symbol.power < 0) {\r\n                                if(l === 2) {\r\n                                    return __.integrate(_.expand(symbol), dx, depth, opt);\r\n                                }\r\n                            }\r\n                            //otherwise the denominator is one lumped together symbol \r\n                            else {\r\n                                //generate an image for \r\n                                if(l === 2) {\r\n                                    //try u substitution\r\n                                    try {\r\n                                        retval = __.integration.u_substitution(symbols, dx);\r\n                                    }\r\n                                    catch(e) {/* failed :`(*/\r\n                                        ;\r\n                                    }\r\n\r\n                                    if(!retval) {\r\n                                        //no success with u substitution so let's try known combinations\r\n                                        //are they two functions\r\n                                        var g1 = symbols[0].group,\r\n                                                g2 = symbols[1].group,\r\n                                                sym1 = symbols[0],\r\n                                                sym2 = symbols[1],\r\n                                                fn1 = sym1.fname,\r\n                                                fn2 = sym2.fname;\r\n                                        //reset the symbol minus the coeff\r\n                                        symbol = _.multiply(sym1.clone(), sym2.clone());\r\n                                        if(g1 === FN && g2 === FN) {\r\n                                            if(fn1 === LOG || fn2 === LOG) {\r\n                                                retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);\r\n                                            }\r\n                                            else {\r\n                                                symbols.sort(function (a, b) {\r\n                                                    return b.fname > a.fname;\r\n                                                });\r\n                                                var arg1 = sym1.args[0];\r\n                                                //make sure the arguments are suitable. We don't know how to integrate non-linear arguments\r\n                                                if(!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S))\r\n                                                    __.integration.stop();\r\n\r\n                                                var decomp = __.integration.decompose_arg(arg1, dx);\r\n                                                x = decomp[1],\r\n                                                        a = decomp[0];\r\n                                                if(!x.isLinear()) //again... linear arguments only wrt x\r\n                                                    __.integration.stop();\r\n\r\n                                                //they have to have the same arguments and then we have cleared all the check to \r\n                                                //make sure we can integrate FN & FN\r\n                                                var arg2 = sym2.args[0];\r\n                                                //make sure that their argument matches\r\n                                                if(arg1.equals(arg2)) {\r\n                                                    if(fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) {\r\n                                                        if(sym1.power.lessThan(0))\r\n                                                            __.integration.stop();//we don't know how to handle, sin(x)^n/cos(x)^m where m > n,  yet\r\n                                                        //if it's in the form sin(x)^n*cos(x)^n then we can just return tan(x)^n which we know how to integrate\r\n                                                        if(fn1 === SIN && sym1.power.add(sym2.power).equals(0)) {\r\n                                                            sym1.fname = TAN;\r\n                                                            sym1.updateHash();\r\n                                                            retval = __.integrate(sym1, dx, depth);\r\n                                                        }\r\n                                                        else {\r\n                                                            if(even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {\r\n                                                                //transform sin^(2*n) to (1-cos^2)^n\r\n                                                                var n = Number(sym1.power) / 2,\r\n                                                                        new_sym = _.parse(format('(1-cos({0})^2)^({1})', sym1.args[0], n));\r\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\r\n                                                            }\r\n                                                            else if(even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {\r\n                                                                //transform cos^(2*n) to (1-sin^2)^n\r\n                                                                var n = Number(sym1.power) / 2,\r\n                                                                        new_sym = _.parse(format('(1-sin({0})^2)^({1})', sym1.args[0], n));\r\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\r\n                                                            }\r\n                                                            else {\r\n                                                                var p1_even = core.Utils.even(sym1.power),\r\n                                                                        p2_even = core.Utils.even(sym2.power);\r\n                                                                retval = new Symbol(0);\r\n                                                                if(!p1_even || !p2_even) {\r\n                                                                    var u, r, trans;\r\n                                                                    //since cos(x) is odd it carries du. If sin was odd then it would be the other way around\r\n                                                                    //know that p1 satifies the odd portion in this case. If p2 did than it would contain r\r\n                                                                    if(!p1_even) {\r\n                                                                        //u = sin(x)\r\n                                                                        u = sym2;\r\n                                                                        r = sym1;\r\n                                                                    }\r\n                                                                    else {\r\n                                                                        u = sym1;\r\n                                                                        r = sym2;\r\n                                                                    }\r\n                                                                    //get the sign of du. In this case r carries du as stated before and D(cos(x),x) = -sin(x)\r\n                                                                    var sign = u.fname === COS ? -1 : 1,\r\n                                                                            n = r.power,\r\n                                                                            //remove the du e.g. cos(x)^2*sin(x)^3 dx -> cos(x)^2*sin(x)^2*sin(x). We're left with two \r\n                                                                            //even powers afterwards which can be transformed\r\n                                                                            k = (n - 1) / 2,\r\n                                                                            //make the transformation cos(x)^2 = 1 - sin(x)^2\r\n                                                                            trans = _.parse('(1-' + u.fname + core.Utils.inBrackets(arg1) + '^2)^' + k),\r\n                                                                            sym = _.expand(_.multiply(new Symbol(sign), _.multiply(u.clone(), trans)));\r\n                                                                    //we can now just loop through and integrate each since it's now just a polynomial with functions\r\n                                                                    sym.each(function (x) {\r\n                                                                        retval = _.add(retval, __.integration.poly_integrate(x.clone()));\r\n                                                                    });\r\n                                                                }\r\n                                                                else {\r\n                                                                    //performs double angle transformation\r\n                                                                    var double_angle = function (symbol) {\r\n                                                                        var p = symbol.power,\r\n                                                                                k = p / 2, e;\r\n                                                                        if(symbol.fname === COS)\r\n                                                                            e = '((1/2)+(cos(2*(' + symbol.args[0] + '))/2))^' + k;\r\n                                                                        else\r\n                                                                            e = '((1/2)-(cos(2*(' + symbol.args[0] + '))/2))^' + k;\r\n\r\n                                                                        return _.parse(e);\r\n                                                                    };\r\n                                                                    //they're both even so transform both using double angle identities and we'll just\r\n                                                                    //be able to integrate by the sum of integrals\r\n                                                                    var a = double_angle(sym1),\r\n                                                                            b = double_angle(sym2),\r\n                                                                            t = _.multiply(a, b);\r\n                                                                    var sym = _.expand(t);\r\n                                                                    sym.each(function (x) {\r\n                                                                        retval = _.add(retval, __.integrate(x, dx, depth));\r\n                                                                    });\r\n                                                                    return _.multiply(retval, coeff);\r\n                                                                }\r\n                                                            }\r\n                                                        }\r\n                                                    }\r\n                                                    //tan(x)*sec(x)^n \r\n                                                    else if(fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) {\r\n                                                        retval = _.parse(format('sec({0})^({1})/({1})', sym1.args[0], sym1.power));\r\n                                                    }\r\n                                                    else if(fn1 === TAN && fn2 === SEC && x.isLinear()) {\r\n                                                        //remaining: tan(x)^3*sec(x)^6\r\n                                                        if(sym1.isLinear() && sym2.isLinear()) {\r\n                                                            retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);\r\n                                                        }\r\n                                                        else if(even(sym1.power)) {\r\n                                                            var p = Number(sym1.power) / 2;\r\n                                                            //transform tangent\r\n                                                            var t = _.parse(format('(sec({0})^2-1)^({1})', sym1.args[0], p));\r\n                                                            retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);\r\n                                                        }\r\n                                                        else\r\n                                                            __.integration.stop();\r\n                                                    }\r\n                                                    else if(fn1 === SEC && fn2 === COS) {\r\n                                                        sym1.fname = COS;\r\n                                                        sym1.invert().updateHash();\r\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\r\n                                                    }\r\n                                                    else if(fn1 === SIN && fn2 === CSC) {\r\n                                                        sym2.fname = SIN;\r\n                                                        sym2.invert().updateHash();\r\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\r\n                                                    }\r\n                                                    //tan/cos\r\n                                                    else if(fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {\r\n                                                        var t = _.multiply(sym1.fnTransform(), sym2);\r\n                                                        retval = __.integrate(_.expand(t), dx, depth);\r\n                                                    }\r\n                                                    else {\r\n                                                        var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());\r\n                                                        retval = __.integrate(_.expand(t), dx, depth);\r\n                                                    }\r\n                                                }\r\n                                                //TODO: In progress\r\n                                                else if((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {\r\n\r\n                                                    if(sym1.isLinear() && sym2.isLinear()) {\r\n                                                        //if in the form cos(a*x)*sin(b*x)\r\n                                                        if(sym1.args[0].isLinear() && sym2.args[0].isLinear()) {\r\n                                                            //use identity (sin(b*x+a*x)+sin(b*x-a*x))/2\r\n                                                            var ax, bx;\r\n                                                            if(fn2 === SIN) {\r\n                                                                ax = sym1.args[0];\r\n                                                                bx = sym2.args[0];\r\n                                                            }\r\n                                                            else {\r\n                                                                bx = sym1.args[0];\r\n                                                                ax = sym2.args[0];\r\n                                                            }\r\n\r\n                                                            //make the transformation\r\n                                                            f = _.parse(format('(sin(({1})+({0}))+sin(({1})-({0})))/2', ax.toString(), bx.toString()));\r\n\r\n                                                            //integrate it\r\n                                                            retval = __.integrate(f, dx, depth);\r\n                                                        }\r\n                                                        else {\r\n                                                            var transformed = trigTransform(symbols);\r\n                                                            retval = __.integrate(_.expand(transformed), dx, depth);\r\n                                                        }\r\n                                                    }\r\n                                                    else {\r\n                                                        var transformed = new Symbol(1);\r\n                                                        symbols.map(function (sym) {\r\n                                                            var s = sym.fnTransform();\r\n                                                            transformed = _.multiply(transformed, s);\r\n                                                        });\r\n                                                        var t = _.expand(transformed);\r\n\r\n                                                        retval = __.integrate(t, dx, depth);\r\n\r\n                                                        if(retval.hasIntegral()) {\r\n                                                            retval = __.integrate(trigTransform(transformed.collectSymbols()), dx, depth);\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                                else {\r\n                                                    __.integration.stop();\r\n                                                }\r\n\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === FN && g2 === S) {\r\n                                            var sym1_is_linear = sym1.isLinear();\r\n                                            if(sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Ci', [sym1.args[0]]);\r\n                                            else if(sym1.fname === COS && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Chi', [sym1.args[0]]);\r\n                                            else if(sym1.fname === COSH && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Si', [sym1.args[0]]);\r\n                                            else if(sym1.fname === SIN && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Shi', [sym1.args[0]]);\r\n                                            else if(sym1.fname === SINH && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === LOG && sym2.power.equals(-1)) {\r\n                                                //log(x)^n/x = log(x)^(n+1)/(n+1)\r\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === 'erf') {\r\n                                                if(sym2.power.equals(1)) {\r\n                                                    var dc = __.integration.decompose_arg(sym1.args[0], dx),\r\n                                                            a_ = dc[0],\r\n                                                            x_ = dc[1],\r\n                                                            arg = sym1.args[0].toString();\r\n                                                    retval = _.parse(format('(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)', a_, x_, arg))\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                //since group S is guaranteed convergence we need not worry about tracking depth of integration\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === EX && g2 === S) {\r\n                                            var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;\r\n                                            if(sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {\r\n                                                retval = _.symfunction('Ei', [sym1.power.clone()]);\r\n                                            }\r\n                                            else if(fn1 === LOG && x.value === sym2.value) {\r\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\r\n                                            }\r\n                                            else\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                        }\r\n                                        else if(g1 === PL && g2 === S) {\r\n                                            //first try to reduce the top\r\n                                            if(sym2.value === sym1.value && sym1.power.equals(-1)) {\r\n                                                //find the lowest power in the denominator\r\n                                                var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols));\r\n                                                //get the lowest common value between denominator and numerator\r\n                                                var pc = Math.min(pd, sym2.power);\r\n                                                //reduce both denominator and numerator by that factor\r\n                                                var factor = sym2.clone();\r\n                                                factor.power = new Frac(pc);\r\n                                                sym2 = _.divide(sym2, factor.clone()); //reduce the denominator\r\n                                                var t = new Symbol(0);\r\n                                                sym1.each(function (x) {\r\n                                                    t = _.add(t, _.divide(x.clone(), factor.clone()));\r\n                                                });\r\n                                                t.multiplier = sym1.multiplier;\r\n                                                symbol = _.divide(sym2, t);\r\n                                            }\r\n                                            else {\r\n                                                symbol = _.expand(symbol);\r\n                                            }\r\n                                            retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                        }\r\n                                        else if(g1 === CP && g2 === S) {\r\n                                            var f = sym1.clone().toLinear(),\r\n                                                    f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1);\r\n                                            //handle cases x^(2*n)/sqrt(1-x^2)\r\n                                            if(sym1.power.equals(-1 / 2)) {\r\n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);\r\n                                                var a = decomp[0].negate(),\r\n                                                        x = decomp[1],\r\n                                                        b = decomp[3],\r\n                                                        p1 = Number(sym1.power),\r\n                                                        p2 = Number(sym2.power);\r\n                                                if(isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {\r\n                                                    //if the substitution \r\n                                                    var c = _.divide(_.multiply(_.pow(b.clone(), new Symbol(2)),\r\n                                                            _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])),\r\n                                                            _.pow(a.clone(), new Symbol(2)));\r\n                                                    c = _.multiply(c, _.symfunction(SQRT, [b]).invert());\r\n                                                    var dummy = _.parse('sin(u)');\r\n                                                    dummy.power = dummy.power.multiply(sym2.power);\r\n                                                    var integral = __.integrate(dummy, 'u', depth);\r\n                                                    var bksub = _.parse(ASIN + '(' + SQRT + '(' + a + '/' + b + ')*' + dx + ')');\r\n                                                    retval = _.multiply(c, integral.sub(new Symbol('u'), bksub));\r\n                                                }\r\n                                                else if(p1 === -1 / 2) {\r\n                                                    var u_transform = function (f, u) {\r\n                                                        var integral = _.parse(__.integrate(f, dx, depth, opt).sub(dx, format(u, dx)));\r\n                                                        if(!integral.hasIntegral())\r\n                                                            return integral;\r\n                                                    }\r\n                                                    if(p2 === -1) {\r\n                                                        retval = u_transform(\r\n                                                                _.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol(2)))).invert(),\r\n                                                                'sqrt(1-1/({0})^2)'\r\n                                                                );\r\n                                                    }\r\n                                                    else if(p2 === -2) {\r\n                                                        //apply transformation to see if it matches asin(x)\r\n                                                        retval = u_transform(\r\n                                                                _.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol(2)).invert(), _.pow(new Symbol(dx), new Symbol(2))).negate())).invert(),\r\n                                                                'sqrt(1-1/({0})^2)'\r\n                                                                );\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                            else if(sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) {\r\n                                                retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                            }\r\n                                            else if(!sym1.power.lessThan(0) && isInt(sym1.power)) {\r\n                                                //sum of integrals\r\n                                                var expanded = _.expand(sym1);\r\n                                                retval = new Symbol(0);\r\n                                                expanded.each(function (x) {\r\n                                                    if(x.group === PL) {\r\n                                                        x.each(function (y) {\r\n                                                            retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));\r\n                                                        });\r\n                                                    }\r\n                                                    else\r\n                                                        retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x), dx, depth));\r\n                                                });\r\n                                            }\r\n                                            else if(sym1.power.lessThan(-2)) {\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                            else if(sym1.power.lessThan(0) && sym2.power.greaterThan(1)) {\r\n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\r\n                                                        a = decomp[0].negate(),\r\n                                                        x = decomp[1],\r\n                                                        b = decomp[3],\r\n                                                        fn = sym1.clone().toLinear();\r\n\r\n                                                if(x.group !== PL && x.isLinear()) {\r\n                                                    var p = Number(sym2.power),\r\n                                                            du = '_u_',\r\n                                                            u = new Symbol(du),\r\n                                                            //pull the integral with the subsitution\r\n                                                            U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol(p)), u.clone())),\r\n                                                            scope = {};\r\n\r\n                                                    //generate a scope for resubbing the symbol\r\n                                                    scope[du] = fn;\r\n                                                    var U2 = _.parse(U, scope);\r\n                                                    retval = __.integrate(U2, dx, 0);\r\n                                                }\r\n                                                else if(sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) {\r\n\r\n                                                    //factor out coefficients\r\n                                                    var factors = new core.Algebra.Classes.Factors();\r\n                                                    sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);\r\n                                                    var div = core.Algebra.divide(sym2, sym1);\r\n                                                    //it assumed that the result will be of group CB\r\n                                                    if(div.group !== CB) {\r\n                                                        retval = new Symbol(0);\r\n                                                        div.each(function (t) {\r\n                                                            retval = _.add(retval, __.integrate(t, dx, depth));\r\n                                                        });\r\n                                                        //put back the factors\r\n                                                        factors.each(function (factor) {\r\n                                                            retval = _.divide(retval, factor);\r\n                                                        });\r\n\r\n                                                        retval = _.expand(retval);\r\n                                                    }\r\n                                                    else {\r\n                                                        //try something else\r\n                                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                                    }\r\n                                                }\r\n                                                else\r\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                            }\r\n                                            else {\r\n                                                //handle cases such as (1-x^2)^(n/2)*x^(m) where n is odd ___ cracking knuckles... This can get a little hairy \r\n                                                if(sym1.power.den.equals(2)) {\r\n                                                    //assume the function is in the form (a^2-b*x^n)^(m/2)\r\n                                                    var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\r\n                                                            //using the above definition\r\n                                                            a = dc[3], x = dc[1], b = dc[0], bx = dc[2];\r\n                                                    if(x.power.equals(2) && b.lessThan(0)) { //if n is even && b is negative\r\n                                                        //make a equal 1 so we can do a trig sub\r\n                                                        if(!a.equals(1)) { //divide a out of everything\r\n                                                            //move a to the coeff\r\n                                                            coeff = _.multiply(coeff, _.pow(a, new Symbol(2)));\r\n                                                        }\r\n                                                        var u = dx;\r\n                                                        var c = _.divide(_.pow(b.clone().negate(), new Symbol(1 / 2)), _.pow(a, new Symbol(1 / 2))),\r\n                                                                du = _.symfunction(COS, [new Symbol(u)]),\r\n                                                                cosn = _.pow(_.symfunction(COS, [new Symbol(u)]), new Symbol(sym1.power.num)),\r\n                                                                X = _.pow(_.symfunction(SIN, [new Symbol(u)]), new Symbol(sym2.power)),\r\n                                                                val = _.multiply(_.multiply(cosn, du), X),\r\n                                                                integral = __.integrate(val, u, depth);\r\n                                                        //but remember that u = asin(sqrt(b)*a*x)\r\n                                                        retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol(dx), c)]));\r\n                                                    }\r\n                                                    else {\r\n                                                        retval = __.integration.partial_fraction(symbol, dx, depth, opt);\r\n                                                    }\r\n                                                }\r\n                                                else if(f_is_linear) {\r\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                                }\r\n                                            }\r\n\r\n                                        }\r\n                                        else if(sym1.isComposite() && sym2.isComposite()) {\r\n                                            //sum of integrals\r\n                                            retval = new Symbol(0);\r\n                                            if(sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {\r\n                                                //combine and pull the integral of each\r\n                                                var sym = _.expand(symbol);\r\n                                                sym.each(function (x) {\r\n                                                    retval = _.add(retval, __.integrate(x, dx, depth));\r\n                                                }, true);\r\n                                            }\r\n                                            else {\r\n                                                var p1 = Number(sym1.power),\r\n                                                        p2 = Number(sym2.power);\r\n                                                if(p1 < 0 && p2 > 0) {\r\n                                                    //swap\r\n                                                    var t = sym1;\r\n                                                    sym1 = sym2;\r\n                                                    sym2 = t;\r\n                                                }\r\n                                                if(p1 === -1 && p2 === -1) {\r\n                                                    retval = __.integration.partial_fraction(symbol, dx);\r\n                                                }\r\n                                                else {\r\n                                                    sym1.each(function (x) {\r\n                                                        var k = _.multiply(x, sym2.clone());\r\n                                                        var integral = __.integrate(k, dx, depth);\r\n                                                        retval = _.add(retval, integral);\r\n                                                    });\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === CP && symbols[0].power.greaterThan(0)) {\r\n                                            sym1 = _.expand(sym1);\r\n                                            retval = new Symbol(0);\r\n                                            sym1.each(function (x) {\r\n                                                retval = _.add(retval, __.integrate(_.multiply(x, sym2.clone()), dx, depth));\r\n                                            }, true);\r\n                                        }\r\n                                        else if(g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {\r\n                                            sym1 = sym1.fnTransform();\r\n                                            retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);\r\n                                        }\r\n                                        else if(g1 === FN && g2 === CP || g2 === FN && g1 === CP) {\r\n                                            if(g2 === FN && g1 === CP) {\r\n                                                var t = sym1;\r\n                                                sym1 = sym2;\r\n                                                sym2 = t; //swap\r\n                                            }\r\n                                            var du, sym2_clone, p, q, sa, sb;\r\n                                            du = Symbol.unwrapSQRT(__.diff(sym1.clone(), dx), true);\r\n                                            sym2_clone = Symbol.unwrapSQRT(sym2, true);\r\n                                            if(du.power.equals(sym2_clone.power)) {\r\n                                                p = new Symbol(sym2.power);\r\n                                                sa = du.clone().toLinear();\r\n                                                sb = sym2.clone().toLinear();\r\n                                                q = core.Algebra.divide(sa.toLinear(), sb);\r\n                                                if(q.isConstant()) {\r\n                                                    var nq = _.pow(q, p.negate());\r\n                                                    retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            var syma = sym1.clone().toLinear();\r\n                                            var symb = sym2.clone().toLinear();\r\n                                            if(g1 === EX && g2 === EX && sym1.power.contains(dx) && sym2.power.contains(dx)\r\n                                                    && !syma.contains(dx) && !symb.contains(dx)) {\r\n                                                retval = _.parse(format('(({0})^(({2})*({4}))*({1})^(({3})*({4})))/(log(({0})^({2}))+log(({1})^({3})))',\r\n                                                        syma.toString(),\r\n                                                        symb.toString(),\r\n                                                        sym1.power.multiplier.toString(),\r\n                                                        sym2.power.multiplier.toString(),\r\n                                                        dx\r\n                                                        ));\r\n                                            }\r\n                                            else\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) {\r\n                                    var first = symbols[0];\r\n                                    if(first.group === CP) { //TODO {support higher powers of x in the future}\r\n                                        if(first.power.greaterThan(1))\r\n                                            first = _.expand(first);\r\n                                        var r = _.multiply(symbols[1], symbols[2]);\r\n                                        retval = new Symbol(0);\r\n                                        first.each(function (x) {\r\n                                            var t = _.multiply(x, r.clone());\r\n                                            var intg = __.integrate(t, dx, depth);\r\n                                            retval = _.add(retval, intg);\r\n                                        }, true);\r\n                                    }\r\n                                    else {\r\n                                        //try integration by parts although technically it will never work\r\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                    }\r\n\r\n                                }\r\n                                else if(all_functions(symbols)) {\r\n                                    var t = new Symbol(1);\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        t = _.multiply(t, symbols[i].fnTransform());\r\n                                    }\r\n                                    t = _.expand(t);\r\n                                    retval = __.integrate(t, dx, depth);\r\n                                }\r\n                                else {\r\n                                    //one more go\r\n                                    var transformed = trigTransform(symbols);\r\n                                    retval = __.integrate(_.expand(transformed), dx, depth);\r\n                                }\r\n                            }\r\n\r\n                        }\r\n\r\n                        retval = _.multiply(retval, coeff);\r\n                    }\r\n                    //if an integral was found then we return it\r\n                    if(retval)\r\n                        return retval;\r\n                }\r\n\r\n                catch(error) {\r\n                    //do nothing if it's a NoIntegralFound error otherwise let it bubble\r\n                    if(!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero))\r\n                        throw error;\r\n                }\r\n\r\n                //no symbol found so we return the integral again\r\n                return _.symfunction('integrate', [original_symbol, dt]);\r\n            }, false);\r\n        },\r\n        defint: function (symbol, from, to, dx) {\r\n            dx = dx || 'x'; //make x the default variable of integration\r\n            var get_value = function (integral, vars, point) {\r\n                try {\r\n                    return _.parse(integral, vars);\r\n                }\r\n                catch(e) {\r\n                    //it failed for some reason so return the limit\r\n                    var lim = __.Limit.limit(integral, dx, point);\r\n                    return lim;\r\n                }\r\n            };\r\n\r\n            var vars = core.Utils.variables(symbol),\r\n                    hasTrig = symbol.hasTrig();\r\n            var retval, integral;\r\n\r\n            // Fix #593 - Only assume the first variable if dx is not defined.\r\n            if(vars.length === 1 && !dx)\r\n                dx = vars[0];\r\n\r\n            if(!hasTrig) {\r\n                integral = __.integrate(symbol, dx);\r\n            }\r\n\r\n            if(!hasTrig && !integral.hasIntegral()) {\r\n                var upper = {},\r\n                        lower = {},\r\n                        a, b;\r\n                upper[dx] = to;\r\n                lower[dx] = from;\r\n\r\n                a = get_value(integral, upper, to, dx);\r\n                b = get_value(integral, lower, from, dx);\r\n                retval = _.subtract(a, b);\r\n            }\r\n            else if(vars.length === 1 && from.isConstant() && to.isConstant()) {\r\n\r\n                var f = core.Utils.build(symbol);\r\n                retval = new Symbol(core.Math2.num_integrate(f, Number(from), Number(to)));\r\n            }\r\n            else\r\n                retval = _.symfunction('defint', [symbol, from, to, dx]);\r\n            return retval;\r\n        },\r\n\r\n        Limit: {\r\n            interval: function (start, end) {\r\n                return _.parse(format('[{0}, {1}]', start, end));\r\n            },\r\n            diverges: function () {\r\n                return __.Limit.interval('-Infinity', 'Infinity');\r\n            },\r\n            divide: function (f, g, x, lim, depth) {\r\n                if(depth++ > Settings.max_lim_depth) {\r\n                    return;\r\n                }\r\n\r\n                var fin = f.clone(), gin = g.clone();\r\n\r\n                //But first a little \"cheating\". x/|x| ends up in an infinite loop since the d/dx |x| -> x/|x|\r\n                //To break this loop we simply provide the answer. Keep in mind that currently limit only provides\r\n                //the two-sided limit.\r\n                //Known limit\r\n                if(g.fname === ABS) {\r\n                    var sign = f.sign();\r\n                    var lim_sign = lim.sign();\r\n\r\n                    if(lim.isInfinity)\r\n                        return _.multiply(new Symbol(sign), new Symbol(lim_sign));\r\n\r\n                    else if(lim.equals(0)) {\r\n                        var fm = _.parse(f.multiplier);\r\n                        var gm = _.parse(g.multiplier);\r\n                        return _.divide(_.multiply(fm, __.Limit.interval('-1', '1')), gm);\r\n                    }\r\n                    else {\r\n                        //TODO: Support more limits\r\n                        __.Limit.diverges();\r\n                    }\r\n                }\r\n\r\n                var isInfinity = function (L) {\r\n                    if(core.Utils.isVector(L)) {\r\n                        for(var i = 0; i < L.elements.length; i++)\r\n                            if(!L.elements[i].isInfinity)\r\n                                return false;\r\n                        return true;\r\n                    }\r\n                    return L.isInfinity;\r\n                };\r\n\r\n                var equals = function (L, v) {\r\n                    if(core.Utils.isVector(L)) {\r\n                        return false;\r\n                    }\r\n                    return L.equals(v);\r\n                };\r\n\r\n                var retval;\r\n                do {\r\n                    var lim1 = evaluate(__.Limit.limit(f.clone(), x, lim, depth));\r\n                    var lim2 = evaluate(__.Limit.limit(g.clone(), x, lim, depth));\r\n\r\n                    //if it's in indeterminate form apply L'Hospital's rule\r\n                    var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0);\r\n                    //pull the derivatives\r\n                    if(indeterminate) {\r\n                        var ft = __.diff(f.clone(), x);\r\n                        var gt = __.diff(g.clone(), x);\r\n\r\n                        var t_symbol = _.expand(_.divide(ft, gt));\r\n                        f = t_symbol.getNum();\r\n                        g = t_symbol.getDenom();\r\n\r\n                    }\r\n                }\r\n                while(indeterminate)\r\n\r\n                //REMEMBER: \r\n                //- 1/cos(x)\r\n                //n/0 is still possible since we only checked for 0/0\r\n                var den_is_zero = lim2.equals(0);\r\n                var p = Number(gin.power);\r\n\r\n                if(lim.isConstant(true) && den_is_zero) {\r\n                    retval = Symbol.infinity(core.Utils.even(p) && lim1.lessThan(0) ? -1 : undefined);\r\n                }\r\n                else if(den_is_zero) {\r\n                    retval = __.Limit.diverges();\r\n                }\r\n                else {\r\n                    retval = _.divide(lim1, lim2);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            rewriteToLog: function (symbol) {\r\n                var p = symbol.power.clone();\r\n                symbol.toLinear();\r\n                return _.pow(new Symbol('e'), _.multiply(p, _.symfunction(Settings.LOG + '', [symbol])));\r\n            },\r\n            getSubbed: function (f, x, lim) {\r\n                var retval;\r\n                //1. rewrite EX with base e\r\n                if(f.group === EX) {\r\n                    f = __.rewriteToLog(f);\r\n                }\r\n                //2. try simple substitution\r\n                try {\r\n                    retval = f.sub(x, lim);\r\n                }\r\n                catch(e) {\r\n                    //Nope. No go, so just return the unsubbed function so we can test the limit instead.\r\n                    retval = f;\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            isInterval: function (limit) {\r\n                return core.Utils.isVector(limit);\r\n            },\r\n            isConvergent: function (limit) {\r\n                //it's not convergent if it lies on the interval -Infinity to Infinity\r\n                if(\r\n                        //It lies on the interval -Infinity to Infinity\r\n                        __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity ||\r\n                        //We weren't able to calculate the limit\r\n                        limit.containsFunction('limit')\r\n                        ) {\r\n                    return false; //Then no\r\n                }\r\n                return true; //It is\r\n            },\r\n            limit: function (symbol, x, lim, depth) {\r\n                //Simplify the symbol\r\n                if(symbol.isLinear() && symbol.isComposite()) {\r\n\r\n                    //Apply sum of limits\r\n                    var limit = new Symbol(0);\r\n                    symbol.each(function (s) {\r\n                        limit = _.add(limit, __.Limit.limit(s, x, lim, depth));\r\n                    }, true);\r\n\r\n                    return limit;\r\n                }\r\n                ;\r\n\r\n                symbol = core.Algebra.Simplify.simplify(symbol);\r\n\r\n                depth = depth || 1;\r\n\r\n                if(depth++ > Settings.max_lim_depth) {\r\n                    return;\r\n                }\r\n\r\n                //store the multiplier\r\n                var m = _.parse(symbol.multiplier);\r\n                //strip the multiplier\r\n                symbol.toUnitMultiplier();\r\n                try {\r\n                    //https://en.wikipedia.org/wiki/List_of_limits\r\n                    var retval;\r\n                    //we try the simplest option first where c is some limit\r\n                    //lim a as x->c = a where c \r\n                    if(symbol.isConstant(true)) {\r\n                        retval = symbol;\r\n                    }\r\n                    else {\r\n                        var point = {};\r\n                        point[x] = lim;\r\n                        //lim x as x->c = c where c\r\n\r\n                        try {\r\n\r\n                            //evaluate the function at the given limit\r\n                            var t = _.parse(symbol.sub(x, lim), point);\r\n\r\n                            //a constant or infinity is known so we're done\r\n                            if(t.isConstant(true) || t.isInfinity)\r\n                                retval = t;\r\n\r\n                        }\r\n                        catch(e) { /*Nothing. Maybe we tried to divide by zero.*/\r\n                        }\r\n                        ;\r\n\r\n                        if(!retval) {\r\n                            //split the symbol in the numerator and the denominator\r\n                            var num = symbol.getNum();\r\n                            var den = symbol.getDenom();\r\n\r\n                            if(den.isConstant(true)) {\r\n                                //We still don't have a limit so we generate tests.\r\n                                if(symbol.group === EX) {\r\n                                    //https://en.wikipedia.org/wiki/List_of_limits\r\n                                    //Speed boost for exponentials by detecting patterns\r\n                                    var f = symbol.clone().toLinear();\r\n                                    var p = symbol.power.clone();\r\n                                    var _num = f.getNum();\r\n                                    var _den = f.getDenom();\r\n                                    var fn = core.Utils.decompose_fn(_den, x, true);\r\n                                    //start detection of pattern (x/(x+1))^x\r\n                                    if(_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {\r\n                                        retval = _.parse(format('(1/e^({0}))', fn.b));\r\n                                    }\r\n                                    else {\r\n                                        var symbol_ = __.Limit.rewriteToLog(symbol.clone());\r\n                                        //get the base\r\n                                        var pow = symbol_.power.clone();\r\n                                        var base = symbol_.clone().toLinear();\r\n                                        var lim_base = __.Limit.limit(base, x, lim, depth);\r\n                                        var lim_pow = __.Limit.limit(pow, x, lim, depth);\r\n                                        retval = _.pow(lim_base, lim_pow);\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === FN && symbol.args.length === 1) {\r\n                                    var evaluates;\r\n                                    //Squeeze theorem lim f(g(x)) = lim f(lim g))\r\n                                    var arg = __.Limit.limit(symbol.args[0], x, lim, depth);\r\n                                    if(core.Utils.isVector(arg)) {\r\n                                        //get the limit over that interval\r\n                                        retval = arg.map(function (e) {\r\n                                            var clone = symbol.clone();\r\n                                            clone.args[0] = e;\r\n                                            return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim, depth);\r\n                                        });\r\n\r\n                                        return _.multiply(m, retval);\r\n                                    }\r\n                                    //if the argument is constant then we're done\r\n                                    else if(arg.isConstant(true)) {\r\n\r\n                                        //double check that it evaluates\r\n                                        var trial = _.symfunction(symbol.fname, [arg]);\r\n                                        //trial evaluation\r\n                                        try {\r\n                                            evaluate(trial);\r\n                                            evaluates = true;\r\n                                        }\r\n                                        catch(e) {\r\n\r\n                                            evaluates = false;\r\n                                        }\r\n                                    }\r\n                                    if(evaluates) {\r\n                                        retval = trial;\r\n                                    }\r\n                                    else {\r\n                                        //if the limit converges. We'll deal with non-convergent ones later\r\n                                        if(__.Limit.isConvergent(arg)) {\r\n                                            if(symbol.fname === LOG) {\r\n                                                switch(arg.toString()) {\r\n                                                    //lim -> 0\r\n                                                    case '0':\r\n                                                        retval = Symbol.infinity().negate();\r\n                                                        break;\r\n                                                    case 'Infinity':\r\n                                                        retval = Symbol.infinity();\r\n                                                        break;\r\n                                                    case '-Infinity':\r\n                                                        retval = Symbol.infinity();\r\n                                                        break;\r\n                                                }\r\n                                            }\r\n                                            else if((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {\r\n                                                retval = __.Limit.interval(-1, 1);\r\n                                            }\r\n                                            else if((symbol.fname === TAN)) {\r\n                                                var s_arg = symbol.args[0];\r\n                                                var n = s_arg.getNum();\r\n                                                var d = s_arg.getDenom();\r\n                                                var pi = n.toUnitMultiplier();\r\n                                                if(lim.isInfinity || pi.equals('pi') && d.equals(2)) {\r\n                                                    retval = divergent();\r\n                                                }\r\n                                            }\r\n                                            else if(symbol.fname === Settings.FACTORIAL) {\r\n                                                if(arg.isInfinity)\r\n                                                    return Symbol.infinity();\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === S) {\r\n                                    if(symbol.power > 0)\r\n                                        //these functions always converge to the limit\r\n                                        return _.parse(symbol, point);\r\n                                    else {\r\n                                        //we're dealing with 1/x^n but remember that infinity has already been dealt\r\n                                        //with by substitution\r\n                                        if(core.Utils.even(symbol.power)) {\r\n                                            //even powers converge to infinity\r\n                                            retval = Symbol.infinity();\r\n                                        }\r\n                                        else {\r\n                                            //odd ones don't\r\n                                            retval = __.Limit.diverges();\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === CB) {\r\n\r\n                                    var lim1, lim2;\r\n                                    //loop through all the symbols\r\n                                    //thus => lim f*g*h = lim (f*g)*h = (lim f*g)*(lim h)\r\n                                    //symbols of lower groups are generally easier to differentiatee so get them to the right by first sorting\r\n                                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                                        return a.group - b.group;\r\n                                    });\r\n\r\n                                    var f = symbols.pop();\r\n                                    //calculate the first limit so we can keep going down the list\r\n                                    lim1 = evaluate(__.Limit.limit(f, x, lim, depth));\r\n\r\n                                    //reduces all the limits one at a time\r\n                                    while(symbols.length) {\r\n                                        //get the second limit\r\n                                        var g = symbols.pop();\r\n                                        //get the limit of g\r\n                                        lim2 = evaluate(__.Limit.limit(g, x, lim, depth));\r\n\r\n                                        //if the limit is in indeterminate form aplly L'Hospital by inverting g and then f/(1/g)\r\n                                        if((lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2))) {\r\n                                            if(g.containsFunction(LOG)) {\r\n                                                //swap them\r\n                                                g = [f, f = g][0];\r\n                                            }\r\n                                            //invert the symbol\r\n                                            g.invert();\r\n\r\n                                            // Product of infinities\r\n                                            if(lim1.isInfinity && lim2.isInfinity) {\r\n                                                lim1 = Symbol.infinity()\r\n                                            }\r\n                                            else {\r\n                                                lim1 = __.Limit.divide(f, g, x, lim, depth);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            //lim f*g = (lim f)*(lim g)\r\n                                            lim1 = _.multiply(lim1, lim2);\r\n                                            //let f*g equal f and h equal g \r\n                                            f = _.multiply(f, g);\r\n                                        }\r\n                                    }\r\n\r\n                                    //Done, lim1 is the limit we're looking for     \r\n                                    retval = lim1;\r\n                                }\r\n                                else if(symbol.isComposite()) {\r\n                                    var _lim;\r\n                                    if(!symbol.isLinear())\r\n                                        symbol = _.expand(symbol);\r\n                                    //Apply lim f+g = (lim f)+(lim g)\r\n                                    retval = new Symbol(0);\r\n\r\n                                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                                        return b.group - a.group;\r\n                                    });\r\n\r\n                                    var _symbols = [];\r\n                                    //Analyze the functions first\r\n                                    var fns = new Symbol(0);\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        var sym = symbols[i].clone();\r\n                                        if(sym.group === FN || sym.group === CB && sym.hasFunc()) {\r\n                                            fns = _.add(fns, sym);\r\n                                        }\r\n                                        else\r\n                                            _symbols.push(sym);\r\n                                    }\r\n                                    _symbols.unshift(fns);\r\n\r\n                                    //make sure that we didn't just repackage the exact same symbol\r\n                                    if(_symbols.length !== 1) {\r\n                                        symbols = _symbols;\r\n                                    }\r\n\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        var sym = symbols[i];\r\n                                        //If the addition of the limits is undefined then the limit diverges so return -infinity to infinity\r\n                                        try {\r\n                                            _lim = __.Limit.limit(sym, x, lim, depth);\r\n                                        }\r\n                                        catch(e) {\r\n                                            _lim = __.Limit.diverges();\r\n                                        }\r\n\r\n                                        try {\r\n                                            retval = _.add(retval, _lim);\r\n                                        }\r\n                                        catch(e) {\r\n                                            if(depth++ > Settings.max_lim_depth) {\r\n                                                return;\r\n                                            }\r\n                                            ;\r\n                                            retval = __.Limit.limit(__.diff(symbol, x), x, lim, depth);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                retval = __.Limit.divide(num, den, x, lim, depth);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //if we still don't have a solution\r\n                    if(!retval)\r\n                        //return it symbolically\r\n                        retval = _.symfunction('limit', [symbol, x, lim]);\r\n                }\r\n                catch(e) {\r\n                    //if all else fails return the symbolic function\r\n                    retval = _.symfunction('limit', [symbol, x, lim]);\r\n                }\r\n\r\n                return _.multiply(m, retval);\r\n            }\r\n        },\r\n        Fresnel: {\r\n            S: function (x) {\r\n                if(x.isConstant(true)) {\r\n                    return __.defint(_.parse('sin(pi*x^2/2)'), Symbol(0), x, 'x');\r\n                }\r\n                return _.symfunction('S', arguments);\r\n            },\r\n            C: function (x) {\r\n                if(x.isConstant(true)) {\r\n                    return __.defint(_.parse('cos(pi*x^2/2)'), Symbol(0), x, 'x');\r\n                }\r\n                return _.symfunction('C', arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'diff',\r\n            visible: true,\r\n            numargs: [1, 3],\r\n            build: function () {\r\n                return __.diff;\r\n            }\r\n        },\r\n        {\r\n            name: 'sum',\r\n            visible: true,\r\n            numargs: 4,\r\n            build: function () {\r\n                return __.sum;\r\n            }\r\n        },\r\n        {\r\n            name: 'product',\r\n            visible: true,\r\n            numargs: 4,\r\n            build: function () {\r\n                return __.product;\r\n            }\r\n        },\r\n        {\r\n            name: 'integrate',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.integrate;\r\n            }\r\n        },\r\n        {\r\n            name: 'defint',\r\n            visible: true,\r\n            numargs: [3, 4],\r\n            build: function () {\r\n                return __.defint;\r\n            }\r\n        },\r\n        {\r\n            name: 'S',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Fresnel.S;\r\n            }\r\n        },\r\n        {\r\n            name: 'C',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Fresnel.C;\r\n            }\r\n        },\r\n        {\r\n            name: 'limit',\r\n            visible: true,\r\n            numargs: [3, 4],\r\n            build: function () {\r\n                return __.Limit.limit;\r\n            }\r\n        }\r\n    ]);\r\n    //link registered functions externally\r\n    nerdamer.updateAPI();\r\n\r\n})();","/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * License : MIT\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\n/* global module, Function */\r\n\r\nif((typeof module) !== 'undefined') {\r\n    var nerdamer = require('./nerdamer.core.js');\r\n    require('./Calculus.js');\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    /*shortcuts*/\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            N = core.groups.N,\r\n            P = core.groups.P,\r\n            S = core.groups.S,\r\n            EX = core.groups.EX,\r\n            FN = core.groups.FN,\r\n            PL = core.groups.PL,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            keys = core.Utils.keys,\r\n            even = core.Utils.even,\r\n            variables = core.Utils.variables,\r\n            format = core.Utils.format,\r\n            round = core.Utils.round,\r\n            Frac = core.Frac,\r\n            isInt = core.Utils.isInt,\r\n            Symbol = core.Symbol,\r\n            CONST_HASH = core.Settings.CONST_HASH,\r\n            math = core.Utils.importFunctions(),\r\n            evaluate = core.Utils.evaluate;\r\n    //*************** CLASSES ***************//\r\n    /**\r\n     * Converts a symbol into an equivalent polynomial arrays of \r\n     * the form [[coefficient_1, power_1],[coefficient_2, power_2], ... ]\r\n     * Univariate polymials only. \r\n     * @param {Symbol|Number} symbol\r\n     * @param {String} variable The variable name of the polynomial\r\n     * @param {int} order\r\n     */\r\n    function Polynomial(symbol, variable, order) {\r\n        if(core.Utils.isSymbol(symbol)) {\r\n            this.parse(symbol);\r\n            this.variable = this.variable || variable;\r\n        }\r\n        else if(!isNaN(symbol)) {\r\n            order = order || 0;\r\n            if(variable === undefined)\r\n                throw new core.exceptions.InvalidVariableNameError('Polynomial expects a variable name when creating using order');\r\n            this.coeffs = [];\r\n            this.coeffs[order] = symbol;\r\n            this.fill(symbol);\r\n        }\r\n        else if(typeof symbol === 'string') {\r\n            this.parse(_.parse(symbol));\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Polynomial given an array of coefficients\r\n     * @param {int[]} arr\r\n     * @param {String} variable\r\n     * @returns {Polynomial}\r\n     */\r\n    Polynomial.fromArray = function (arr, variable) {\r\n        if(typeof variable === 'undefined')\r\n            throw new core.exceptions.InvalidVariableNameError('A variable name must be specified when creating polynomial from array');\r\n        var p = new Polynomial();\r\n        p.coeffs = arr;\r\n        p.variable = variable;\r\n        return p;\r\n    };\r\n\r\n    Polynomial.fit = function (c1, c2, n, base, p, variable) {\r\n        //after having looped through and mod 10 the number to get the matching factor\r\n        var terms = new Array(p + 1),\r\n                t = n - c2;\r\n        terms[0] = c2; //the constants is assumed to be correct\r\n        //constant for x^p is also assumed know so add\r\n        terms[p] = c1;\r\n        t -= c1 * Math.pow(base, p);\r\n        //start fitting\r\n        for(var i = p - 1; i > 0; i--) {\r\n            var b = Math.pow(base, i), //we want as many wholes as possible\r\n                    q = t / b,\r\n                    sign = Math.sign(q);\r\n            var c = sign * Math.floor(Math.abs(q));\r\n            t -= c * b;\r\n            terms[i] = c;\r\n        }\r\n        if(t !== 0)\r\n            return null;\r\n        for(var i = 0; i < terms.length; i++)\r\n            terms[i] = new Frac(terms[i]);\r\n\r\n        return Polynomial.fromArray(terms, variable);\r\n    };\r\n\r\n    Polynomial.prototype = {\r\n        /**\r\n         * Converts Symbol to Polynomial\r\n         * @param {Symbol} symbol\r\n         * @param {Array} c - a collector array\r\n         * @returns {Polynomial}\r\n         */\r\n        parse: function (symbol, c) {\r\n            this.variable = variables(symbol)[0];\r\n            if(!symbol.isPoly())\r\n                throw core.exceptions.NerdamerTypeError('Polynomial Expected! Received ' + core.Utils.text(symbol));\r\n            c = c || [];\r\n            if(!symbol.power.absEquals(1))\r\n                symbol = _.expand(symbol);\r\n\r\n            if(symbol.group === core.groups.N) {\r\n                c[0] = symbol.multiplier;\r\n            }\r\n            else if(symbol.group === core.groups.S) {\r\n                c[symbol.power.toDecimal()] = symbol.multiplier;\r\n            }\r\n            else {\r\n                for(var x in symbol.symbols) {\r\n                    var sub = symbol.symbols[x],\r\n                            p = sub.power;\r\n                    if(core.Utils.isSymbol(p))\r\n                        throw new core.exceptions.NerdamerTypeError('power cannot be a Symbol');\r\n\r\n                    p = sub.group === N ? 0 : p.toDecimal();\r\n                    if(sub.symbols) {\r\n                        this.parse(sub, c);\r\n                    }\r\n                    else {\r\n                        c[p] = sub.multiplier;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.coeffs = c;\r\n\r\n            this.fill();\r\n        },\r\n        /**\r\n         * Fills in the holes in a polynomial with zeroes\r\n         * @param {Number} x - The number to fill the holes with\r\n         */\r\n        fill: function (x) {\r\n            x = Number(x) || 0;\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                if(this.coeffs[i] === undefined) {\r\n                    this.coeffs[i] = new Frac(x);\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Removes higher order zeros or a specific coefficient\r\n         * @returns {Array}\r\n         */\r\n        trim: function () {\r\n            var l = this.coeffs.length;\r\n            while(l--) {\r\n                var c = this.coeffs[l];\r\n                var equalsZero = c.equals(0);\r\n                if(c && equalsZero) {\r\n                    if(l === 0)\r\n                        break;\r\n                    this.coeffs.pop();\r\n                }\r\n                else\r\n                    break;\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /*\r\n         * Returns polynomial mod p **currently fails**\r\n         * @param {Number} p\r\n         * @returns {Polynomial}\r\n         */\r\n        modP: function (p) {\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var c = this.coeffs[i];\r\n                if(c < 0) { //go borrow\r\n                    var b; //a coefficient > 0\r\n                    for(var j = i; j < l; j++) {//starting from where we left off\r\n                        if(this.coeffs[j] > 0) {\r\n                            b = this.coeffs[j];\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if(b) { //if such a coefficient exists\r\n                        for(j; j > i; j--) { //go down the line and adjust using p\r\n                            this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));\r\n                            this.coeffs[j - 1] = this.coeffs[j - 1].add(new Frac(p));\r\n                        }\r\n                        c = this.coeffs[i]; //reset c\r\n                    }\r\n                }\r\n\r\n                var d = c.mod(p);\r\n                var w = c.subtract(d).divide(p);\r\n                if(!w.equals(0)) {\r\n                    var up_one = i + 1;\r\n                    var next = this.coeffs[up_one] || new Frac(0);\r\n                    next = next.add(w);\r\n                    this.coeffs[up_one] = new Frac(next);\r\n                    this.coeffs[i] = new Frac(d);\r\n                }\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /**\r\n         * Adds together 2 polynomials\r\n         * @param {Polynomial} poly\r\n         */\r\n        add: function (poly) {\r\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\r\n            for(var i = 0; i < l; i++) {\r\n                var a = (this.coeffs[i] || new Frac(0)),\r\n                        b = (poly.coeffs[i] || new Frac(0));\r\n                this.coeffs[i] = a.add(b);\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Adds together 2 polynomials\r\n         * @param {Polynomial} poly\r\n         */\r\n        subtract: function (poly) {\r\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\r\n            for(var i = 0; i < l; i++) {\r\n                var a = (this.coeffs[i] || new Frac(0)),\r\n                        b = (poly.coeffs[i] || new Frac(0));\r\n                this.coeffs[i] = a.subtract(b);\r\n            }\r\n            return this;\r\n        },\r\n        divide: function (poly) {\r\n            var variable = this.variable,\r\n                    dividend = core.Utils.arrayClone(this.coeffs),\r\n                    divisor = core.Utils.arrayClone(poly.coeffs),\r\n                    n = dividend.length,\r\n                    mp = divisor.length - 1,\r\n                    quotient = [];\r\n\r\n            //loop through the dividend\r\n            for(var i = 0; i < n; i++) {\r\n                var p = n - (i + 1);\r\n                //get the difference of the powers\r\n                var d = p - mp;\r\n                //get the quotient of the coefficients\r\n                var q = dividend[p].divide(divisor[mp]);\r\n\r\n                if(d < 0)\r\n                    break;//the divisor is not greater than the dividend\r\n                //place it in the quotient\r\n                quotient[d] = q;\r\n\r\n                for(var j = 0; j <= mp; j++) {\r\n                    //reduce the dividend\r\n                    dividend[j + d] = dividend[j + d].subtract((divisor[j].multiply(q)));\r\n                }\r\n            }\r\n\r\n            //clean up\r\n            var p1 = Polynomial.fromArray(dividend, variable || 'x').trim(), //pass in x for safety\r\n                    p2 = Polynomial.fromArray(quotient, variable || 'x');\r\n            return [p2, p1];\r\n        },\r\n        multiply: function (poly) {\r\n            var l1 = this.coeffs.length, l2 = poly.coeffs.length,\r\n                    c = []; //array to be returned\r\n            for(var i = 0; i < l1; i++) {\r\n                var x1 = this.coeffs[i];\r\n                for(var j = 0; j < l2; j++) {\r\n                    var k = i + j, //add the powers together\r\n                            x2 = poly.coeffs[j],\r\n                            e = c[k] || new Frac(0); //get the existing term from the new array\r\n                    c[k] = e.add(x1.multiply(x2)); //multiply the coefficients and add to new polynomial array\r\n                }\r\n            }\r\n            this.coeffs = c;\r\n            return this;\r\n        },\r\n        /**\r\n         * Checks if a polynomial is zero\r\n         * @returns {Boolean}\r\n         */\r\n        isZero: function () {\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var e = this.coeffs[i];\r\n                if(!e.equals(0))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        /** \r\n         * Substitutes in a number n into the polynomial p(n)\r\n         * @param {Number} n\r\n         * @returns {Frac}\r\n         */\r\n        sub: function (n) {\r\n            var sum = new Frac(0), l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var t = this.coeffs[i];\r\n                if(!t.equals(0))\r\n                    sum = sum.add(t.multiply(new Frac(Math.pow(n, i))));\r\n            }\r\n            return sum;\r\n        },\r\n        /**\r\n         * Returns a clone of the polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        clone: function () {\r\n            var p = new Polynomial();\r\n            p.coeffs = this.coeffs;\r\n            p.variable = this.variable;\r\n            return p;\r\n        },\r\n        /**\r\n         * Gets the degree of the polynomial\r\n         * @returns {Number}\r\n         */\r\n        deg: function () {\r\n            this.trim();\r\n            return this.coeffs.length - 1;\r\n        },\r\n        /**\r\n         * Returns a lead coefficient\r\n         * @returns {Frac}\r\n         */\r\n        lc: function () {\r\n            return this.coeffs[this.deg()].clone();\r\n        },\r\n        /**\r\n         * Converts polynomial into a monic polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        monic: function () {\r\n            var lc = this.lc(), l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++)\r\n                this.coeffs[i] = this.coeffs[i].divide(lc);\r\n            return this;\r\n        },\r\n        /**\r\n         * Returns the GCD of two polynomials\r\n         * @param {Polynomial} poly\r\n         * @returns {Polynomial}\r\n         */\r\n        gcd: function (poly) {\r\n            //get the maximum power of each\r\n            var mp1 = this.coeffs.length - 1,\r\n                    mp2 = poly.coeffs.length - 1,\r\n                    T;\r\n            //swap so we always have the greater power first\r\n            if(mp1 < mp2) {\r\n                return poly.gcd(this);\r\n            }\r\n            var a = this;\r\n\r\n            while(!poly.isZero()) {\r\n                var t = poly.clone();\r\n                a = a.clone();\r\n                T = a.divide(t);\r\n                poly = T[1];\r\n                a = t;\r\n            }\r\n\r\n            var gcd = core.Math2.QGCD.apply(null, a.coeffs);\r\n            if(!gcd.equals(1)) {\r\n                var l = a.coeffs.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    a.coeffs[i] = a.coeffs[i].divide(gcd);\r\n                }\r\n            }\r\n            return a;\r\n        },\r\n        /**\r\n         * Differentiates the polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        diff: function () {\r\n            var new_array = [], l = this.coeffs.length;\r\n            for(var i = 1; i < l; i++)\r\n                new_array.push(this.coeffs[i].multiply(new Frac(i)));\r\n            this.coeffs = new_array;\r\n            return this;\r\n        },\r\n        /**\r\n         * Integrates the polynomial\r\n         * @returns {Polynomial} \r\n         */\r\n        integrate: function () {\r\n            var new_array = [0], l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var c = new Frac(i + 1);\r\n                new_array[c] = this.coeffs[i].divide(c);\r\n            }\r\n            this.coeffs = new_array;\r\n            return this;\r\n        },\r\n        /**\r\n         * Returns the Greatest common factor of the polynomial\r\n         * @param {bool} toPolynomial - true if a polynomial is wanted\r\n         * @returns {Frac|Polynomial}\r\n         */\r\n        gcf: function (toPolynomial) {\r\n            //get the first nozero coefficient and returns its power\r\n            var fnz = function (a) {\r\n                for(var i = 0; i < a.length; i++)\r\n                    if(!a[i].equals(0))\r\n                        return i;\r\n            },\r\n                    ca = [];\r\n            for(var i = 0; i < this.coeffs.length; i++) {\r\n                var c = this.coeffs[i];\r\n                if(!c.equals(0) && ca.indexOf(c) === -1)\r\n                    ca.push(c);\r\n            }\r\n            var p = [core.Math2.QGCD.apply(undefined, ca), fnz(this.coeffs)].toDecimal();\r\n\r\n            if(toPolynomial) {\r\n                var parr = [];\r\n                parr[p[1] - 1] = p[0];\r\n                p = Polynomial.fromArray(parr, this.variable).fill();\r\n            }\r\n\r\n            return p;\r\n        },\r\n        /**\r\n         * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2\r\n         * @param {bool} incl_img - Include imaginary numbers \r\n         */\r\n        quad: function (incl_img) {\r\n            var roots = [];\r\n            if(this.coeffs.length > 3)\r\n                throw new Error('Cannot calculate quadratic order of ' + (this.coeffs.length - 1));\r\n            if(this.coeffs.length === 0)\r\n                throw new Error('Polynomial array has no terms');\r\n            var a = this.coeffs[2] || 0, b = this.coeffs[1] || 0, c = this.coeffs[0];\r\n            var dsc = b * b - 4 * a * c;\r\n            if(dsc < 0 && !incl_img)\r\n                return roots;\r\n            else {\r\n                roots[0] = (-b + Math.sqrt(dsc)) / (2 * a);\r\n                roots[1] = (-b - Math.sqrt(dsc)) / (2 * a);\r\n            }\r\n            return roots;\r\n        },\r\n        /**\r\n         * Makes polynomial square free\r\n         * @returns {Array}\r\n         */\r\n        squareFree: function () {\r\n\r\n            var a = this.clone(),\r\n                    i = 1,\r\n                    b = a.clone().diff(),\r\n                    c = a.clone().gcd(b),\r\n                    w = a.divide(c)[0];\r\n            var output = Polynomial.fromArray([new Frac(1)], a.variable);\r\n            while(!c.equalsNumber(1)) {\r\n                var y = w.gcd(c);\r\n                var z = w.divide(y)[0];\r\n                //one of the factors may have shown up since it's square but smaller than the \r\n                //one where finding\r\n                if(!z.equalsNumber(1) && i > 1) {\r\n                    var t = z.clone();\r\n                    for(var j = 1; j < i; j++)\r\n                        t.multiply(z.clone());\r\n                    z = t;\r\n                }\r\n                output = output.multiply(z);\r\n                i++;\r\n                w = y;\r\n                c = c.divide(y)[0];\r\n            }\r\n\r\n            return [output, w, i];\r\n        },\r\n        /**\r\n         * Converts polynomial to Symbol\r\n         * @returns {Symbol}\r\n         */\r\n        toSymbol: function () {\r\n            var l = this.coeffs.length,\r\n                    variable = this.variable;\r\n            if(l === 0)\r\n                return new core.Symbol(0);\r\n            var end = l - 1, str = '';\r\n\r\n            for(var i = 0; i < l; i++) {\r\n                //place the plus sign for all but the last one\r\n                var plus = i === end ? '' : '+',\r\n                        e = this.coeffs[i];\r\n                if(!e.equals(0))\r\n                    str += (e + '*' + variable + '^' + i + plus);\r\n            }\r\n            return _.parse(str);\r\n        },\r\n        /**\r\n         * Checks if polynomial is equal to a number\r\n         * @param {Number} x\r\n         * @returns {Boolean}\r\n         */\r\n        equalsNumber: function (x) {\r\n            this.trim();\r\n            return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);\r\n        },\r\n        toString: function () {\r\n            return this.toSymbol().toString();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * TODO\r\n     * ===================================================================================\r\n     * THIS METHOD HAS A NASTY HIDDEN BUG. IT HAS INCONSISTENT RETURN TYPES PRIMARILY DUE TO \r\n     * WRONG ASSUMPTIONS AT THE BEGINNING. THE ASSUMPTION WAS THAT COEFFS WERE ALWAYS GOING BE NUMBERS\r\n     * NOT TAKING INTO ACCOUNT THAT IMAGINARY NUMBERS. FIXING THIS BREAKS WAY TOO MANY TESTS \r\n     * AT THEM MOMENT WHICH I DON'T HAVE TO FIX\r\n     * ===================================================================================\r\n     * If the symbols is of group PL or CP it will return the multipliers of each symbol\r\n     * as these are polynomial coefficients. CB symbols are glued together by multiplication\r\n     * so the symbol multiplier carries the coefficients for all contained symbols.\r\n     * For S it just returns it's own multiplier. This function doesn't care if it's a polynomial or not\r\n     * @param {Array} c The coefficient array\r\n     * @param {boolean} with_order \r\n     * @return {Array}\r\n     */\r\n    Symbol.prototype.coeffs = function (c, with_order) {\r\n        if(with_order && !this.isPoly(true))\r\n            _.error('Polynomial expected when requesting coefficients with order');\r\n        c = c || [];\r\n        var s = this.clone().distributeMultiplier();\r\n        if(s.isComposite()) {\r\n            for(var x in s.symbols) {\r\n                var sub = s.symbols[x];\r\n                if(sub.isComposite()) {\r\n                    sub.clone().distributeMultiplier().coeffs(c, with_order);\r\n                }\r\n                else {\r\n                    if(with_order)\r\n                        c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;\r\n                    else {\r\n                        c.push(sub.multiplier);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if(with_order)\r\n                c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;\r\n            else {\r\n                if(s.group === CB && s.isImaginary()) {\r\n                    var m = new Symbol(s.multiplier);\r\n                    s.each(function (x) {\r\n                        //add the imaginary part\r\n                        if(x.isConstant(true) || x.imaginary)\r\n                            m = _.multiply(m, x);\r\n                    });\r\n                    c.push(m);\r\n                }\r\n                else\r\n                    c.push(s.multiplier);\r\n            }\r\n        }\r\n        //fill the holes\r\n        if(with_order) {\r\n            for(var i = 0; i < c.length; i++)\r\n                if(c[i] === undefined)\r\n                    c[i] = new Symbol(0);\r\n        }\r\n        return c;\r\n    };\r\n    Symbol.prototype.tBase = function (map) {\r\n        if(typeof map === 'undefined')\r\n            throw new Error('Symbol.tBase requires a map object!');\r\n        var terms = [];\r\n        var symbols = this.collectSymbols(null, null, null, true),\r\n                l = symbols.length;\r\n        for(var i = 0; i < l; i++) {\r\n            var symbol = symbols[i],\r\n                    g = symbol.group,\r\n                    nterm = new MVTerm(symbol.multiplier, [], map);\r\n            if(g === CB) {\r\n                for(var x in symbol.symbols) {\r\n                    var sym = symbol.symbols[x];\r\n                    nterm.terms[map[x]] = sym.power;\r\n                }\r\n            }\r\n            else {\r\n                nterm.terms[map[symbol.value]] = symbol.power;\r\n            }\r\n\r\n            terms.push(nterm.fill());\r\n            nterm.updateCount();\r\n        }\r\n        return terms;\r\n    };\r\n    Symbol.prototype.altVar = function (x) {\r\n        var m = this.multiplier.toString(), p = this.power.toString();\r\n        return (m === '1' ? '' : m + '*') + x + (p === '1' ? '' : '^' + p);\r\n    };\r\n    /**\r\n     * Checks to see if the symbols contain the same variables\r\n     * @param {Symbol} symbol\r\n     * @returns {Boolean}\r\n     */\r\n    Symbol.prototype.sameVars = function (symbol) {\r\n        if(!(this.symbols || this.group === symbol.group))\r\n            return false;\r\n        for(var x in this.symbols) {\r\n            var a = this.symbols[x], b = symbol.symbols[x];\r\n            if(!b)\r\n                return false;\r\n            if(a.value !== b.value)\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Groups the terms in a symbol with respect to a variable\r\n     * For instance the symbol {a*b^2*x^2+a*b*x^2+x+6} returns [6,1,a*b+a*b^2]\r\n     * @returns {Factors}\r\n     */\r\n    Symbol.prototype.groupTerms = function (x) {\r\n        x = String(x);\r\n        var f, p, egrouped;\r\n        var grouped = [];\r\n        this.each(function (e) {\r\n            if(e.group === PL) {\r\n                egrouped = e.groupTerms(x);\r\n                for(var i = 0; i < egrouped.length; i++) {\r\n                    var el = egrouped[i];\r\n                    if(el)\r\n                        grouped[i] = el;\r\n                }\r\n            }\r\n            else {\r\n                f = core.Utils.decompose_fn(e, x, true);\r\n                p = f.x.value === x ? Number(f.x.power) : 0;\r\n                //check if there's an existing value\r\n                grouped[p] = _.add(grouped[p] || new Symbol(0), f.a);\r\n            }\r\n        });\r\n        return grouped;\r\n    };\r\n    /**\r\n     * Use this to collect Factors\r\n     * @returns {Symbol[]}\r\n     */\r\n    Symbol.prototype.collectFactors = function () {\r\n        var factors = [];\r\n        if(this.group === CB)\r\n            this.each(function (x) {\r\n                factors.push(x.clone());\r\n            });\r\n        else\r\n            factors.push(this.clone());\r\n        return factors;\r\n    };\r\n    /**\r\n     * A container class for factors\r\n     * @returns {Factors}\r\n     */\r\n    function Factors() {\r\n        this.factors = {};\r\n        this.length = 0;\r\n    }\r\n    ;\r\n    Factors.prototype.getNumberSymbolics = function () {\r\n        var n = 0;\r\n        this.each(function (x) {\r\n            if(!x.isConstant(true))\r\n                n++;\r\n        });\r\n        return n;\r\n    };\r\n    /**\r\n     * Adds the factors to the factor object\r\n     * @param {Symbo} s\r\n     * @returns {Factors}\r\n     */\r\n    Factors.prototype.add = function (s) {\r\n        if(s.equals(0))\r\n            return this; //nothing to add\r\n\r\n        //we don't want to carry -1 as a factor. If a factor already exists,\r\n        //then add the minus one to that factor and return.\r\n        if(s.equals(-1) && this.length > 0) {\r\n            var fo = core.Utils.firstObject(this.factors, null, true);\r\n            this.add(_.symfunction(core.Settings.PARENTHESIS, [fo.obj]).negate());\r\n            delete this.factors[fo.key];\r\n            this.length--;\r\n            return this;\r\n        }\r\n\r\n        if(s.group === CB) {\r\n            var factors = this;\r\n            if(!s.multiplier.equals(1))\r\n                factors.add(new Symbol(s.multiplier));\r\n            s.each(function (x) {\r\n                factors.add(x);\r\n            });\r\n        }\r\n        else {\r\n            if(this.preAdd) //if a preAdd function was defined call it to do prep\r\n                s = this.preAdd(s);\r\n            if(this.pFactor) //if the symbol isn't linear add back the power\r\n                s = _.pow(s, new Symbol(this.pFactor));\r\n\r\n            var is_constant = s.isConstant();\r\n            if(is_constant && s.equals(1))\r\n                return this; //don't add 1\r\n            var v = is_constant ? s.value : s.text();\r\n            if(v in this.factors) {\r\n                this.factors[v] = _.multiply(this.factors[v], s);\r\n                //did the addition cancel out the existing factor? If so remove it and decrement the length\r\n                if(this.factors[v].equals(1)) {\r\n                    delete this.factors[v];\r\n                    this.length--;\r\n                }\r\n            }\r\n            else {\r\n                this.factors[v] = s;\r\n                this.length++;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Converts the factor object to a Symbol\r\n     * @returns {Symbol}\r\n     */\r\n    Factors.prototype.toSymbol = function () {\r\n        var factored = new Symbol(1);\r\n        var factors = Object.values(this.factors).sort(function (a, b) {\r\n            return a.group > b.group;\r\n        });\r\n\r\n        for(var i = 0, l = factors.length; i < l; i++) {\r\n            var f = factors[i];\r\n\r\n            //don't wrap group S or FN\r\n            var factor = f.power.equals(1) && f.fname !== '' /* don't wrap it twice */ ?\r\n                    _.symfunction(core.PARENTHESIS, [f]) : f;\r\n\r\n            factored = _.multiply(factored, factor);\r\n        }\r\n        if(factored.fname === '')\r\n            factored = Symbol.unwrapPARENS(factored);\r\n        return factored;\r\n    };\r\n    /**\r\n     * Merges 2 factor objects into one\r\n     * @param {Factor} o\r\n     * @returns {Factors}\r\n     */\r\n    Factors.prototype.merge = function (o) {\r\n        for(var x in o) {\r\n            if(x in this.factors)\r\n                this.factors[x] = _.multiply(this.factors[x], o[x]);\r\n            else\r\n                this.factors[x] = o[x];\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * The iterator for the factor object\r\n     * @param {Function} f - callback\r\n     * @returns {Factor}\r\n     */\r\n    Factors.prototype.each = function (f) {\r\n        for(var x in this.factors) {\r\n            var factor = this.factors[x];\r\n            if(factor.fname === core.PARENTHESIS && factor.isLinear())\r\n                factor = factor.args[0];\r\n            f.call(this, factor, x);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Return the number of factors contained in the factor object\r\n     * @returns {int}\r\n     */\r\n    Factors.prototype.count = function () {\r\n        return keys(this.factors).length;\r\n    };\r\n    /**\r\n     * Cleans up factors from -1\r\n     * @returns {undefined}\r\n     */\r\n    Factors.prototype.clean = function () {\r\n        try {\r\n            var h = core.Settings.CONST_HASH;\r\n            if(this.factors[h].lessThan(0)) {\r\n                if(this.factors[h].equals(-1))\r\n                    delete this.factors[h];\r\n                else\r\n                    this.factors[h].negate();\r\n                this.each(function (x) {\r\n                    x.negate();\r\n                });\r\n            }\r\n        }\r\n        catch(e) {\r\n        }\r\n        ;\r\n    };\r\n    Factors.prototype.toString = function () {\r\n        return this.toSymbol().toString();\r\n    };\r\n\r\n    //a wrapper for performing multivariate division\r\n    function MVTerm(coeff, terms, map) {\r\n        this.terms = terms || [];\r\n        this.coeff = coeff;\r\n        this.map = map; //careful! all maps are the same object\r\n        this.sum = new core.Frac(0);\r\n        this.image = undefined;\r\n    }\r\n    ;\r\n    MVTerm.prototype.updateCount = function () {\r\n        this.count = this.count || 0;\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            if(!this.terms[i].equals(0))\r\n                this.count++;\r\n        }\r\n        return this;\r\n    };\r\n    MVTerm.prototype.getVars = function () {\r\n        var vars = [];\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            var term = this.terms[i],\r\n                    rev_map = this.getRevMap();\r\n            if(!term.equals(0))\r\n                vars.push(this.rev_map[i]);\r\n        }\r\n        return vars.join(' ');\r\n    };\r\n    MVTerm.prototype.len = function () {\r\n        if(typeof this.count === 'undefined') {\r\n            this.updateCount();\r\n        }\r\n        return this.count;\r\n    };\r\n    MVTerm.prototype.toSymbol = function (rev_map) {\r\n        rev_map = rev_map || this.getRevMap();\r\n        var symbol = new Symbol(this.coeff);\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            var v = rev_map[i],\r\n                    t = this.terms[i];\r\n            if(t.equals(0) || v === CONST_HASH)\r\n                continue;\r\n            var mapped = new Symbol(v);\r\n            mapped.power = t;\r\n            symbol = _.multiply(symbol, mapped);\r\n        }\r\n        return symbol;\r\n    };\r\n    MVTerm.prototype.getRevMap = function () {\r\n        if(this.rev_map)\r\n            return this.rev_map;\r\n        var o = {};\r\n        for(var x in this.map)\r\n            o[this.map[x]] = x;\r\n        this.rev_map = o;\r\n        return o;\r\n    };\r\n    MVTerm.prototype.generateImage = function () {\r\n        this.image = this.terms.join(' ');\r\n        return this;\r\n    },\r\n            MVTerm.prototype.getImg = function () {\r\n                if(!this.image)\r\n                    this.generateImage();\r\n                return this.image;\r\n            },\r\n            MVTerm.prototype.fill = function () {\r\n                var l = this.map.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    if(typeof this.terms[i] === 'undefined')\r\n                        this.terms[i] = new core.Frac(0);\r\n                    else {\r\n                        this.sum = this.sum.add(this.terms[i]);\r\n                    }\r\n                }\r\n                return this;\r\n            };\r\n    MVTerm.prototype.divide = function (mvterm) {\r\n        var c = this.coeff.divide(mvterm.coeff),\r\n                l = this.terms.length,\r\n                new_mvterm = new MVTerm(c, [], this.map);\r\n        for(var i = 0; i < l; i++) {\r\n            new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);\r\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\r\n        }\r\n        return new_mvterm;\r\n    };\r\n    MVTerm.prototype.multiply = function (mvterm) {\r\n        var c = this.coeff.multiply(mvterm.coeff),\r\n                l = this.terms.length,\r\n                new_mvterm = new MVTerm(c, [], this.map);\r\n        for(var i = 0; i < l; i++) {\r\n            new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);\r\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\r\n        }\r\n        return new_mvterm;\r\n    };\r\n    MVTerm.prototype.isZero = function () {\r\n        return this.coeff.equals(0);\r\n    };\r\n    MVTerm.prototype.toString = function () {\r\n        return '{ coeff: ' + this.coeff.toString() + ', terms: [' +\r\n                this.terms.join(',') + ']: sum: ' + this.sum.toString() + ', count: ' + this.count + '}';\r\n    };\r\n\r\n    core.Utils.toMapObj = function (arr) {\r\n        var c = 0, o = {};\r\n        for(var i = 0; i < arr.length; i++) {\r\n            var v = arr[i];\r\n            if(typeof o[v] === 'undefined') {\r\n                o[v] = c;\r\n                c++;\r\n            }\r\n        }\r\n        o.length = c;\r\n        return o;\r\n    };\r\n    core.Utils.filledArray = function (v, n, clss) {\r\n        var a = [];\r\n        while(n--) {\r\n            a[n] = clss ? new clss(v) : v;\r\n        }\r\n        return a;\r\n    };\r\n    core.Utils.arrSum = function (arr) {\r\n        var sum = 0, l = arr.length;\r\n        for(var i = 0; i < l; i++)\r\n            sum += arr[i];\r\n        return sum;\r\n    };\r\n    /**\r\n     * Determines if 2 arrays have intersecting elements.\r\n     * @param {Array} a\r\n     * @param {Array} b\r\n     * @returns {Boolean} True if a and b have intersecting elements.\r\n     */\r\n    core.Utils.haveIntersection = function (a, b) {\r\n        var t;\r\n        if(b.length > a.length)\r\n            t = b, b = a, a = t; // indexOf to loop over shorter\r\n        return a.some(function (e) {\r\n            return b.indexOf(e) > -1;\r\n        });\r\n    };\r\n    /**\r\n     * Substitutes out functions as variables so they can be used in regular algorithms\r\n     * @param {Symbol} symbol\r\n     * @param {Object} map\r\n     * @returns {String} The expression string\r\n     */\r\n    core.Utils.subFunctions = function (symbol, map) {\r\n        map = map || {};\r\n        var subbed = [];\r\n        symbol.each(function (x) {\r\n            if(x.group === FN || x.previousGroup === FN) {\r\n                //we need a new variable name so why not use one of the existing\r\n                var val = core.Utils.text(x, 'hash'), tvar = map[val];\r\n                if(!tvar) {\r\n                    //generate a unique enough name\r\n                    var t = x.fname + keys(map).length;\r\n                    map[val] = t;\r\n                    subbed.push(x.altVar(t));\r\n                }\r\n                else\r\n                    subbed.push(x.altVar(tvar));\r\n            }\r\n            else if(x.group === CB || x.group === PL || x.group === CP) {\r\n                subbed.push(core.Utils.subFunctions(x, map));\r\n            }\r\n            else\r\n                subbed.push(x.text());\r\n        });\r\n        if(symbol.group === CP || symbol.group === PL)\r\n            return symbol.altVar(core.Utils.inBrackets(subbed.join('+')));\r\n        ;\r\n        if(symbol.group === CB)\r\n            return symbol.altVar(core.Utils.inBrackets(subbed.join('*')));\r\n        return symbol.text();\r\n    };\r\n    core.Utils.getFunctionsSubs = function (map) {\r\n        var subs = {};\r\n        //prepare substitutions\r\n        for(var x in map)\r\n            subs[map[x]] = _.parse(x);\r\n        return subs;\r\n    };\r\n\r\n    var __ = core.Algebra = {\r\n        version: '1.4.6',\r\n        proots: function (symbol, decp) {\r\n            //the roots will be rounded up to 7 decimal places.\r\n            //if this causes trouble you can explicitly pass in a different number of places\r\n            //rarr for polynomial of power n is of format [n, coeff x^n, coeff x^(n-1), ..., coeff x^0]\r\n            decp = decp || 7;\r\n            var zeros = 0;\r\n            var known_roots = [];\r\n            var get_roots = function (rarr, powers, max) {\r\n                var roots = calcroots(rarr, powers, max).concat(known_roots);\r\n                for(var i = 0; i < zeros; i++)\r\n                    roots.unshift(0);\r\n                return roots;\r\n            };\r\n\r\n            if(symbol instanceof Symbol && symbol.isPoly()) {\r\n                symbol.distributeMultiplier();\r\n                //make it so the symbol has a constants as the lowest term\r\n                if(symbol.group === PL) {\r\n                    var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));\r\n                    var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();\r\n                    symbol = _.expand(_.divide(symbol, lowest_symbol));\r\n                    known_roots.push(0); //add zero since this is a known root\r\n                }\r\n                if(symbol.group === core.groups.S) {\r\n                    return [0];\r\n                }\r\n                else if(symbol.group === core.groups.PL) {\r\n                    var powers = keys(symbol.symbols),\r\n                            minpower = core.Utils.arrayMin(powers),\r\n                            symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value + '^' + minpower));\r\n                }\r\n\r\n                var variable = keys(symbol.symbols).sort().pop(),\r\n                        sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable],\r\n                        g = sym.group,\r\n                        powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols),\r\n                        rarr = [],\r\n                        max = core.Utils.arrayMax(powers); //maximum power and degree of polynomial to be solved\r\n\r\n                // Prepare the data\r\n                for(var i = 1; i <= max; i++) {\r\n                    var c = 0; //if there is no power then the hole must be filled with a zero\r\n                    if(powers.indexOf(i + '') !== -1) {\r\n                        if(g === S) {\r\n                            c = sym.multiplier;\r\n                        }\r\n                        else {\r\n                            c = sym.symbols[i].multiplier;\r\n                        }\r\n                    }\r\n                    // Insert the coeffient but from the front\r\n                    rarr.unshift(c);\r\n                }\r\n\r\n                rarr.push(symbol.symbols[CONST_HASH].multiplier);\r\n\r\n                if(sym.group === S)\r\n                    rarr[0] = sym.multiplier;//the symbol maybe of group CP with one variable\r\n\r\n                return get_roots(rarr, powers, max);\r\n            }\r\n            else if(core.Utils.isArray(symbol)) {\r\n                var parr = symbol;\r\n                var rarr = [],\r\n                        powers = [],\r\n                        last_power = 0;\r\n                for(var i = 0; i < parr.length; i++) {\r\n\r\n                    var coeff = parr[i][0],\r\n                            pow = parr[i][1],\r\n                            d = pow - last_power - 1;\r\n                    //insert the zeros\r\n                    for(var j = 0; j < d; j++)\r\n                        rarr.unshift(0);\r\n\r\n                    rarr.unshift(coeff);\r\n                    if(pow !== 0)\r\n                        powers.push(pow);\r\n                    last_power = pow;\r\n                }\r\n                var max = Math.max.apply(undefined, powers);\r\n\r\n                return get_roots(rarr, powers, max);\r\n            }\r\n            else {\r\n                throw new core.exceptions.NerdamerTypeError('Cannot calculate roots. Symbol must be a polynomial!');\r\n            }\r\n\r\n            function calcroots(rarr, powers, max) {\r\n                var MAXDEGREE = 100; // Degree of largest polynomial accepted by this script.\r\n\r\n                // Make a clone of the coefficients before appending the max power\r\n                var p = rarr.slice(0);\r\n\r\n                // Divide the string up into its individual entries, which--presumably--are separated by whitespace\r\n                rarr.unshift(max);\r\n\r\n                if(max > MAXDEGREE) {\r\n                    throw new core.exceptions.ValueLimitExceededError(\"This utility accepts polynomials of degree up to \" + MAXDEGREE + \". \");\r\n                }\r\n\r\n                var zeroi = [], // Vector of imaginary components of roots\r\n                        degreePar = {};    // degreePar is a dummy variable for passing the parameter POLYDEGREE by reference\r\n                degreePar.Degree = max;\r\n\r\n                for(i = 0; i < max; i++) {\r\n                    zeroi.push(0);\r\n                }\r\n                var zeror = zeroi.slice(0); // Vector of real components of roots\r\n\r\n                // Find the roots\r\n                //--> Begin Jenkins-Traub\r\n\r\n                /*\r\n                 * A verbatim copy of Mr. David Binner's Jenkins-Traub port\r\n                 */\r\n                function QuadSD_ak1(NN, u, v, p, q, iPar) {\r\n                    // Divides p by the quadratic 1, u, v placing the quotient in q and the remainder in a, b\r\n                    // iPar is a dummy variable for passing in the two parameters--a and b--by reference\r\n                    q[0] = iPar.b = p[0];\r\n                    q[1] = iPar.a = -(u * iPar.b) + p[1];\r\n\r\n                    for(var i = 2; i < NN; i++) {\r\n                        q[i] = -(u * iPar.a + v * iPar.b) + p[i];\r\n                        iPar.b = iPar.a;\r\n                        iPar.a = q[i];\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function calcSC_ak1(DBL_EPSILON, N, a, b, iPar, K, u, v, qk) {\r\n                    // This routine calculates scalar quantities used to compute the next K polynomial and\r\n                    // new estimates of the quadratic coefficients.\r\n                    // calcSC -\tinteger variable set here indicating how the calculations are normalized\r\n                    // to avoid overflow.\r\n                    // iPar is a dummy variable for passing in the nine parameters--a1, a3, a7, c, d, e, f, g, and h --by reference\r\n\r\n                    // sdPar is a dummy variable for passing the two parameters--c and d--into QuadSD_ak1 by reference\r\n                    var sdPar = new Object(),\r\n                            // TYPE = 3 indicates the quadratic is almost a factor of K\r\n                            dumFlag = 3;\r\n\r\n                    // Synthetic division of K by the quadratic 1, u, v\r\n                    sdPar.b = sdPar.a = 0.0;\r\n                    QuadSD_ak1(N, u, v, K, qk, sdPar);\r\n                    iPar.c = sdPar.a;\r\n                    iPar.d = sdPar.b;\r\n\r\n                    if(Math.abs(iPar.c) <= (100.0 * DBL_EPSILON * Math.abs(K[N - 1]))) {\r\n                        if(Math.abs(iPar.d) <= (100.0 * DBL_EPSILON * Math.abs(K[N - 2])))\r\n                            return dumFlag;\r\n                    }\r\n\r\n                    iPar.h = v * b;\r\n                    if(Math.abs(iPar.d) >= Math.abs(iPar.c)) {\r\n                        // TYPE = 2 indicates that all formulas are divided by d\r\n                        dumFlag = 2;\r\n                        iPar.e = a / (iPar.d);\r\n                        iPar.f = (iPar.c) / (iPar.d);\r\n                        iPar.g = u * b;\r\n                        iPar.a3 = (iPar.e) * ((iPar.g) + a) + (iPar.h) * (b / (iPar.d));\r\n                        iPar.a1 = -a + (iPar.f) * b;\r\n                        iPar.a7 = (iPar.h) + ((iPar.f) + u) * a;\r\n                    }\r\n                    else {\r\n                        // TYPE = 1 indicates that all formulas are divided by c;\r\n                        dumFlag = 1;\r\n                        iPar.e = a / (iPar.c);\r\n                        iPar.f = (iPar.d) / (iPar.c);\r\n                        iPar.g = (iPar.e) * u;\r\n                        iPar.a3 = (iPar.e) * a + ((iPar.g) + (iPar.h) / (iPar.c)) * b;\r\n                        iPar.a1 = -(a * ((iPar.d) / (iPar.c))) + b;\r\n                        iPar.a7 = (iPar.g) * (iPar.d) + (iPar.h) * (iPar.f) + a;\r\n                    }\r\n                    return dumFlag;\r\n                }\r\n\r\n                function nextK_ak1(DBL_EPSILON, N, tFlag, a, b, iPar, K, qk, qp) {\r\n                    // Computes the next K polynomials using the scalars computed in calcSC_ak1\r\n                    // iPar is a dummy variable for passing in three parameters--a1, a3, and a7\r\n                    var temp;\r\n                    if(tFlag == 3) {\t// Use unscaled form of the recurrence\r\n                        K[1] = K[0] = 0.0;\r\n                        for(var i = 2; i < N; i++) {\r\n                            K[i] = qk[i - 2];\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    temp = ((tFlag == 1) ? b : a);\r\n                    if(Math.abs(iPar.a1) > (10.0 * DBL_EPSILON * Math.abs(temp))) {\r\n                        // Use scaled form of the recurrence\r\n                        iPar.a7 /= iPar.a1;\r\n                        iPar.a3 /= iPar.a1;\r\n                        K[0] = qp[0];\r\n                        K[1] = -(qp[0] * iPar.a7) + qp[1];\r\n                        for(var i = 2; i < N; i++)\r\n                            K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3 + qp[i];\r\n                    }\r\n                    else {\r\n                        // If a1 is nearly zero, then use a special form of the recurrence\r\n                        K[0] = 0.0;\r\n                        K[1] = -(qp[0] * iPar.a7);\r\n                        for(var i = 2; i < N; i++) {\r\n                            K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3;\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c, d, f, g, h, u, v, K, N, p) {\r\n                    // Compute new estimates of the quadratic coefficients using the scalars computed in calcSC_ak1\r\n                    // iPar is a dummy variable for passing in the two parameters--uu and vv--by reference\r\n                    // iPar.a = uu, iPar.b = vv\r\n\r\n                    var a4, a5, b1, b2, c1, c2, c3, c4, temp;\r\n                    iPar.b = iPar.a = 0.0;// The quadratic is zeroed\r\n\r\n                    if(tFlag != 3) {\r\n                        if(tFlag != 2) {\r\n                            a4 = a + u * b + h * f;\r\n                            a5 = c + (u + v * f) * d;\r\n                        }\r\n                        else {\r\n                            a4 = (a + g) * f + h;\r\n                            a5 = (f + u) * c + v * d;\r\n                        }\r\n\r\n                        // Evaluate new quadratic coefficients\r\n                        b1 = -(K[N - 1] / p[N]);\r\n                        b2 = -(K[N - 2] + b1 * p[N - 1]) / p[N];\r\n                        c1 = v * b2 * a1;\r\n                        c2 = b1 * a7;\r\n                        c3 = b1 * b1 * a3;\r\n                        c4 = -(c2 + c3) + c1;\r\n                        temp = -c4 + a5 + b1 * a4;\r\n                        if(temp != 0.0) {\r\n                            iPar.a = -((u * (c3 + c2) + v * (b1 * a1 + b2 * a7)) / temp) + u;\r\n                            iPar.b = v * (1.0 + c4 / temp);\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function Quad_ak1(a, b1, c, iPar) {\r\n                    // Calculates the zeros of the quadratic a*Z^2 + b1*Z + c\r\n                    // The quadratic formula, modified to avoid overflow, is used to find the larger zero if the\r\n                    // zeros are real and both zeros are complex. The smaller real zero is found directly from\r\n                    // the product of the zeros c/a.\r\n\r\n                    // iPar is a dummy variable for passing in the four parameters--sr, si, lr, and li--by reference\r\n\r\n                    var b, d, e;\r\n                    iPar.sr = iPar.si = iPar.lr = iPar.li = 0.0;\r\n\r\n                    if(a == 0) {\r\n                        iPar.sr = ((b1 != 0) ? -(c / b1) : iPar.sr);\r\n                        return;\r\n                    }\r\n                    if(c == 0) {\r\n                        iPar.lr = -(b1 / a);\r\n                        return;\r\n                    }\r\n\r\n                    // Compute discriminant avoiding overflow\r\n                    b = b1 / 2.0;\r\n                    if(Math.abs(b) < Math.abs(c)) {\r\n                        e = ((c >= 0) ? a : -a);\r\n                        e = -e + b * (b / Math.abs(c));\r\n                        d = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c));\r\n                    }\r\n                    else {\r\n                        e = -((a / b) * (c / b)) + 1.0;\r\n                        d = Math.sqrt(Math.abs(e)) * (Math.abs(b));\r\n                    }\r\n\r\n                    if(e >= 0) {\r\n                        // Real zeros\r\n                        d = ((b >= 0) ? -d : d);\r\n                        iPar.lr = (-b + d) / a;\r\n                        iPar.sr = ((iPar.lr != 0) ? (c / (iPar.lr)) / a : iPar.sr);\r\n                    }\r\n                    else {\r\n                        // Complex conjugate zeros\r\n                        iPar.lr = iPar.sr = -(b / a);\r\n                        iPar.si = Math.abs(d / a);\r\n                        iPar.li = -(iPar.si);\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function QuadIT_ak1(DBL_EPSILON, N, iPar, uu, vv, qp, NN, sdPar, p, qk, calcPar, K) {\r\n                    // Variable-shift K-polynomial iteration for a quadratic factor converges only if the\r\n                    // zeros are equimodular or nearly so.\r\n                    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\r\n                    // sdPar is a dummy variable for passing the two parameters--a and b--in by reference\r\n                    // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --in by reference\r\n\r\n                    // qPar is a dummy variable for passing the four parameters--szr, szi, lzr, and lzi--into Quad_ak1 by reference\r\n                    var qPar = new Object(),\r\n                            ee, mp, omp, relstp, t, u, ui, v, vi, zm,\r\n                            i, j = 0, tFlag, triedFlag = 0;   // Integer variables\r\n\r\n                    iPar.NZ = 0;// Number of zeros found\r\n                    u = uu; // uu and vv are coefficients of the starting quadratic\r\n                    v = vv;\r\n\r\n                    do {\r\n                        qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\r\n                        Quad_ak1(1.0, u, v, qPar);\r\n                        iPar.szr = qPar.sr;\r\n                        iPar.szi = qPar.si;\r\n                        iPar.lzr = qPar.lr;\r\n                        iPar.lzi = qPar.li;\r\n\r\n                        // Return if roots of the quadratic are real and not close to multiple or nearly\r\n                        // equal and of opposite sign.\r\n                        if(Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr))\r\n                            break;\r\n\r\n                        // Evaluate polynomial by quadratic synthetic division\r\n\r\n                        QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n\r\n                        mp = Math.abs(-((iPar.szr) * (sdPar.b)) + (sdPar.a)) + Math.abs((iPar.szi) * (sdPar.b));\r\n\r\n                        // Compute a rigorous bound on the rounding error in evaluating p\r\n\r\n                        zm = Math.sqrt(Math.abs(v));\r\n                        ee = 2.0 * Math.abs(qp[0]);\r\n                        t = -((iPar.szr) * (sdPar.b));\r\n\r\n                        for(i = 1; i < N; i++) {\r\n                            ee = ee * zm + Math.abs(qp[i]);\r\n                        }\r\n\r\n                        ee = ee * zm + Math.abs(t + sdPar.a);\r\n                        ee = (9.0 * ee + 2.0 * Math.abs(t) - 7.0 * (Math.abs((sdPar.a) + t) + zm * Math.abs((sdPar.b)))) * DBL_EPSILON;\r\n\r\n                        // Iteration has converged sufficiently if the polynomial value is less than 20 times this bound\r\n                        if(mp <= 20.0 * ee) {\r\n                            iPar.NZ = 2;\r\n                            break;\r\n                        }\r\n\r\n                        j++;\r\n                        // Stop iteration after 20 steps\r\n                        if(j > 20)\r\n                            break;\r\n                        if(j >= 2) {\r\n                            if((relstp <= 0.01) && (mp >= omp) && (!triedFlag)) {\r\n                                // A cluster appears to be stalling the convergence. Five fixed shift\r\n                                // steps are taken with a u, v close to the cluster.\r\n                                relstp = ((relstp < DBL_EPSILON) ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp));\r\n                                u -= u * relstp;\r\n                                v += v * relstp;\r\n\r\n                                QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                                for(i = 0; i < 5; i++) {\r\n                                    tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                                    nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\r\n                                }\r\n\r\n                                triedFlag = 1;\r\n                                j = 0;\r\n\r\n                            }\r\n                        }\r\n                        omp = mp;\r\n\r\n                        // Calculate next K polynomial and new u and v\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                        nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                        newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\r\n                        ui = sdPar.a;\r\n                        vi = sdPar.b;\r\n\r\n                        // If vi is zero, the iteration is not converging\r\n                        if(vi != 0) {\r\n                            relstp = Math.abs((-v + vi) / vi);\r\n                            u = ui;\r\n                            v = vi;\r\n                        }\r\n                    }\r\n                    while(vi != 0);\r\n                    return;\r\n                }\r\n\r\n                function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk) {\r\n                    // Variable-shift H-polynomial iteration for a real zero\r\n                    // sss\t- starting iterate = sdPar.a\r\n                    // NZ\t\t- number of zeros found = iPar.NZ\r\n                    // dumFlag\t- flag to indicate a pair of zeros near real axis, returned to iFlag\r\n\r\n                    var ee, kv, mp, ms, omp, pv, s, t,\r\n                            dumFlag, i, j, nm1 = N - 1;   // Integer variables\r\n\r\n                    iPar.NZ = j = dumFlag = 0;\r\n                    s = sdPar.a;\r\n\r\n                    for(; ; ) {\r\n                        pv = p[0];\r\n\r\n                        // Evaluate p at s\r\n                        qp[0] = pv;\r\n                        for(i = 1; i < NN; i++) {\r\n                            qp[i] = pv = pv * s + p[i];\r\n                        }\r\n                        mp = Math.abs(pv);\r\n\r\n                        // Compute a rigorous bound on the error in evaluating p\r\n                        ms = Math.abs(s);\r\n                        ee = 0.5 * Math.abs(qp[0]);\r\n                        for(i = 1; i < NN; i++) {\r\n                            ee = ee * ms + Math.abs(qp[i]);\r\n                        }\r\n\r\n                        // Iteration has converged sufficiently if the polynomial value is less than\r\n                        // 20 times this bound\r\n                        if(mp <= 20.0 * DBL_EPSILON * (2.0 * ee - mp)) {\r\n                            iPar.NZ = 1;\r\n                            iPar.szr = s;\r\n                            iPar.szi = 0.0;\r\n                            break;\r\n                        }\r\n                        j++;\r\n                        // Stop iteration after 10 steps\r\n                        if(j > 10)\r\n                            break;\r\n\r\n                        if(j >= 2) {\r\n                            if((Math.abs(t) <= 0.001 * Math.abs(-t + s)) && (mp > omp)) {\r\n                                // A cluster of zeros near the real axis has been encountered.\r\n                                // Return with iFlag set to initiate a quadratic iteration.\r\n                                dumFlag = 1;\r\n                                iPar.a = s;\r\n                                break;\r\n                            } // End if ((fabs(t) <= 0.001*fabs(s - t)) && (mp > omp))\r\n                        } //End if (j >= 2)\r\n\r\n                        // Return if the polynomial value has increased significantly\r\n                        omp = mp;\r\n\r\n                        // Compute t, the next polynomial and the new iterate\r\n                        qk[0] = kv = K[0];\r\n                        for(i = 1; i < N; i++) {\r\n                            qk[i] = kv = kv * s + K[i];\r\n                        }\r\n\r\n                        if(Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON) {\r\n                            // Use the scaled form of the recurrence if the value of K at s is non-zero\r\n                            t = -(pv / kv);\r\n                            K[0] = qp[0];\r\n                            for(i = 1; i < N; i++) {\r\n                                K[i] = t * qk[i - 1] + qp[i];\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Use unscaled form\r\n                            K[0] = 0.0;\r\n                            for(i = 1; i < N; i++)\r\n                                K[i] = qk[i - 1];\r\n                        }\r\n\r\n                        kv = K[0];\r\n                        for(i = 1; i < N; i++) {\r\n                            kv = kv * s + K[i];\r\n                        }\r\n                        t = ((Math.abs(kv) > (Math.abs(K[nm1]) * 10.0 * DBL_EPSILON)) ? -(pv / kv) : 0.0);\r\n                        s += t;\r\n                    }\r\n                    return dumFlag;\r\n                }\r\n\r\n                function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N, p, NN, qp, u, iPar) {\r\n\r\n                    // Computes up to L2 fixed shift K-polynomials, testing for convergence in the linear or\r\n                    // quadratic case. Initiates one of the variable shift iterations and returns with the\r\n                    // number of zeros found.\r\n                    // L2\tlimit of fixed shift steps\r\n                    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\r\n                    // NZ\tnumber of zeros found\r\n                    var sdPar = new Object(), // sdPar is a dummy variable for passing the two parameters--a and b--into QuadSD_ak1 by reference\r\n                            calcPar = new Object(),\r\n                            // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --into calcSC_ak1 by reference\r\n\r\n                            qk = new Array(MDP1),\r\n                            svk = new Array(MDP1),\r\n                            a, b, betas, betav, oss, ots, otv, ovv, s, ss, ts, tss, tv, tvv, ui, vi, vv,\r\n                            fflag, i, iFlag = 1, j, spass, stry, tFlag, vpass, vtry;     // Integer variables\r\n\r\n                    iPar.NZ = 0;\r\n                    betav = betas = 0.25;\r\n                    oss = sr;\r\n                    ovv = v;\r\n\r\n                    //Evaluate polynomial by synthetic division\r\n                    sdPar.b = sdPar.a = 0.0;\r\n                    QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                    a = sdPar.a;\r\n                    b = sdPar.b;\r\n                    calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0.0;\r\n                    tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n\r\n                    for(j = 0; j < L2; j++) {\r\n                        fflag = 1;\r\n\r\n                        // Calculate next K polynomial and estimate v\r\n                        nextK_ak1(DBL_EPSILON, N, tFlag, a, b, calcPar, K, qk, qp);\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n\r\n                        // Use sdPar for passing in uu and vv instead of defining a brand-new variable.\r\n                        // sdPar.a = ui, sdPar.b = vi\r\n                        newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\r\n                        ui = sdPar.a;\r\n                        vv = vi = sdPar.b;\r\n\r\n                        // Estimate s\r\n                        ss = ((K[N - 1] != 0.0) ? -(p[N] / K[N - 1]) : 0.0);\r\n                        ts = tv = 1.0;\r\n\r\n                        if((j != 0) && (tFlag != 3)) {\r\n                            // Compute relative measures of convergence of s and v sequences\r\n                            tv = ((vv != 0.0) ? Math.abs((vv - ovv) / vv) : tv);\r\n                            ts = ((ss != 0.0) ? Math.abs((ss - oss) / ss) : ts);\r\n\r\n                            // If decreasing, multiply the two most recent convergence measures\r\n                            tvv = ((tv < otv) ? tv * otv : 1.0);\r\n                            tss = ((ts < ots) ? ts * ots : 1.0);\r\n\r\n                            // Compare with convergence criteria\r\n                            vpass = ((tvv < betav) ? 1 : 0);\r\n                            spass = ((tss < betas) ? 1 : 0);\r\n\r\n                            if((spass) || (vpass)) {\r\n\r\n                                // At least one sequence has passed the convergence test.\r\n                                // Store variables before iterating\r\n\r\n                                for(i = 0; i < N; i++) {\r\n                                    svk[i] = K[i];\r\n                                }\r\n                                s = ss;\r\n\r\n                                // Choose iteration according to the fastest converging sequence\r\n\r\n                                stry = vtry = 0;\r\n\r\n                                for(; ; ) {\r\n                                    if((fflag && ((fflag = 0) == 0)) && ((spass) && (!vpass || (tss < tvv)))) {\r\n                                        ;// Do nothing. Provides a quick \"short circuit\".\r\n                                    }\r\n                                    else {\r\n                                        QuadIT_ak1(DBL_EPSILON, N, iPar, ui, vi, qp, NN, sdPar, p, qk, calcPar, K);\r\n                                        a = sdPar.a;\r\n                                        b = sdPar.b;\r\n\r\n                                        if((iPar.NZ) > 0)\r\n                                            return;\r\n\r\n                                        // Quadratic iteration has failed. Flag that it has been tried and decrease the\r\n                                        // convergence criterion\r\n                                        iFlag = vtry = 1;\r\n                                        betav *= 0.25;\r\n\r\n                                        // Try linear iteration if it has not been tried and the s sequence is converging\r\n                                        if(stry || (!spass)) {\r\n                                            iFlag = 0;\r\n                                        }\r\n                                        else {\r\n                                            for(i = 0; i < N; i++)\r\n                                                K[i] = svk[i];\r\n                                        }\r\n                                    }\r\n                                    //fflag = 0;\r\n                                    if(iFlag != 0) {\r\n                                        // Use sdPar for passing in s instead of defining a brand-new variable.\r\n                                        // sdPar.a = s\r\n                                        sdPar.a = s;\r\n                                        iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk);\r\n                                        s = sdPar.a;\r\n\r\n                                        if((iPar.NZ) > 0)\r\n                                            return;\r\n\r\n                                        // Linear iteration has failed. Flag that it has been tried and decrease the\r\n                                        // convergence criterion\r\n                                        stry = 1;\r\n                                        betas *= 0.25;\r\n\r\n                                        if(iFlag != 0) {\r\n                                            // If linear iteration signals an almost double real zero, attempt quadratic iteration\r\n                                            ui = -(s + s);\r\n                                            vi = s * s;\r\n                                            continue;\r\n\r\n                                        }\r\n                                    }\r\n\r\n                                    // Restore variables\r\n                                    for(i = 0; i < N; i++)\r\n                                        K[i] = svk[i];\r\n\r\n                                    // Try quadratic iteration if it has not been tried and the v sequence is converging\r\n                                    if(!vpass || vtry)\r\n                                        break;\t\t// Break out of infinite for loop\r\n\r\n                                }\r\n\r\n                                // Re-compute qp and scalar values to continue the second stage\r\n\r\n                                QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                                a = sdPar.a;\r\n                                b = sdPar.b;\r\n\r\n                                tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n                            }\r\n                        }\r\n                        ovv = vv;\r\n                        oss = ss;\r\n                        otv = tv;\r\n                        ots = ts;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function rpSolve(degPar, p, zeror, zeroi) {\r\n                    var N = degPar.Degree,\r\n                            RADFAC = 3.14159265358979323846 / 180, // Degrees-to-radians conversion factor = PI/180\r\n                            LB2 = Math.LN2, // Dummy variable to avoid re-calculating this value in loop below\r\n                            MDP1 = degPar.Degree + 1,\r\n                            K = new Array(MDP1),\r\n                            pt = new Array(MDP1),\r\n                            qp = new Array(MDP1),\r\n                            temp = new Array(MDP1),\r\n                            // qPar is a dummy variable for passing the four parameters--sr, si, lr, and li--by reference\r\n                            qPar = new Object(),\r\n                            // Fxshfr_Par is a dummy variable for passing parameters by reference : NZ, lzi, lzr, szi, szr);\r\n                            Fxshfr_Par = new Object(),\r\n                            bnd, DBL_EPSILON, df, dx, factor, ff, moduli_max, moduli_min, sc, x, xm,\r\n                            aa, bb, cc, sr, t, u, xxx,\r\n                            j, jj, l, NM1, NN, zerok;// Integer variables\r\n\r\n                    // Calculate the machine epsilon and store in the variable DBL_EPSILON.\r\n                    // To calculate this value, just use existing variables rather than create new ones that will be used only for this code block\r\n                    aa = 1.0;\r\n                    do {\r\n                        DBL_EPSILON = aa;\r\n                        aa /= 2;\r\n                        bb = 1.0 + aa;\r\n                    }\r\n                    while(bb > 1.0);\r\n\r\n                    var LO = Number.MIN_VALUE / DBL_EPSILON,\r\n                            cosr = Math.cos(94.0 * RADFAC), // = -0.069756474\r\n                            sinr = Math.sin(94.0 * RADFAC), // = 0.99756405\r\n                            xx = Math.sqrt(0.5), // = 0.70710678\r\n                            yy = -xx;\r\n\r\n                    Fxshfr_Par.NZ = j = 0;\r\n                    Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0.0;\r\n\r\n                    // Remove zeros at the origin, if any\r\n                    while(p[N] == 0) {\r\n                        zeror[j] = zeroi[j] = 0;\r\n                        N--;\r\n                        j++;\r\n                    }\r\n                    NN = N + 1;\r\n\r\n                    // >>>>> Begin Main Loop <<<<<\r\n                    while(N >= 1) { // Main loop\r\n                        // Start the algorithm for one zero\r\n                        if(N <= 2) {\r\n                            // Calculate the final zero or pair of zeros\r\n                            if(N < 2) {\r\n                                zeror[degPar.Degree - 1] = -(p[1] / p[0]);\r\n                                zeroi[degPar.Degree - 1] = 0;\r\n                            }\r\n                            else {\r\n                                qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\r\n                                Quad_ak1(p[0], p[1], p[2], qPar);\r\n                                zeror[degPar.Degree - 2] = qPar.sr;\r\n                                zeroi[degPar.Degree - 2] = qPar.si;\r\n                                zeror[degPar.Degree - 1] = qPar.lr;\r\n                                zeroi[degPar.Degree - 1] = qPar.li;\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        // Find the largest and smallest moduli of the coefficients\r\n                        moduli_max = 0.0;\r\n                        moduli_min = Number.MAX_VALUE;\r\n\r\n                        for(i = 0; i < NN; i++) {\r\n                            x = Math.abs(p[i]);\r\n                            if(x > moduli_max)\r\n                                moduli_max = x;\r\n                            if((x != 0) && (x < moduli_min))\r\n                                moduli_min = x;\r\n                        }\r\n\r\n                        // Scale if there are large or very small coefficients\r\n                        // Computes a scale factor to multiply the coefficients of the polynomial. The scaling\r\n                        // is done to avoid overflow and to avoid undetected underflow interfering with the\r\n                        // convergence criterion.\r\n                        // The factor is a power of the base.\r\n                        sc = LO / moduli_min;\r\n\r\n                        if(((sc <= 1.0) && (moduli_max >= 10)) || ((sc > 1.0) && (Number.MAX_VALUE / sc >= moduli_max))) {\r\n                            sc = ((sc == 0) ? Number.MIN_VALUE : sc);\r\n                            l = Math.floor(Math.log(sc) / LB2 + 0.5);\r\n                            factor = Math.pow(2.0, l);\r\n                            if(factor != 1.0) {\r\n                                for(i = 0; i < NN; i++)\r\n                                    p[i] *= factor;\r\n                            }\r\n                        }\r\n\r\n                        // Compute lower bound on moduli of zeros\r\n                        for(var i = 0; i < NN; i++)\r\n                            pt[i] = Math.abs(p[i]);\r\n                        pt[N] = -(pt[N]);\r\n                        NM1 = N - 1;\r\n\r\n                        // Compute upper estimate of bound\r\n                        x = Math.exp((Math.log(-pt[N]) - Math.log(pt[0])) / N);\r\n\r\n                        if(pt[NM1] != 0) {\r\n                            // If Newton step at the origin is better, use it\r\n                            xm = -pt[N] / pt[NM1];\r\n                            x = ((xm < x) ? xm : x);\r\n                        }\r\n\r\n                        // Chop the interval (0, x) until ff <= 0\r\n                        xm = x;\r\n                        do {\r\n                            x = xm;\r\n                            xm = 0.1 * x;\r\n                            ff = pt[0];\r\n                            for(var i = 1; i < NN; i++) {\r\n                                ff = ff * xm + pt[i];\r\n                            }\r\n                        }\r\n                        while(ff > 0); // End do-while loop\r\n\r\n                        dx = x;\r\n                        // Do Newton iteration until x converges to two decimal places\r\n\r\n                        do {\r\n                            df = ff = pt[0];\r\n                            for(var i = 1; i < N; i++) {\r\n                                ff = x * ff + pt[i];\r\n                                df = x * df + ff;\r\n                            } // End for i\r\n                            ff = x * ff + pt[N];\r\n                            dx = ff / df;\r\n                            x -= dx;\r\n                        }\r\n                        while(Math.abs(dx / x) > 0.005); // End do-while loop\r\n\r\n                        bnd = x;\r\n\r\n                        // Compute the derivative as the initial K polynomial and do 5 steps with no shift\r\n                        for(var i = 1; i < N; i++)\r\n                            K[i] = (N - i) * p[i] / N;\r\n                        K[0] = p[0];\r\n                        aa = p[N];\r\n                        bb = p[NM1];\r\n                        zerok = ((K[NM1] == 0) ? 1 : 0);\r\n\r\n                        for(jj = 0; jj < 5; jj++) {\r\n                            cc = K[NM1];\r\n                            if(zerok) {\r\n                                // Use unscaled form of recurrence\r\n                                for(var i = 0; i < NM1; i++) {\r\n                                    j = NM1 - i;\r\n                                    K[j] = K[j - 1];\r\n                                } // End for i\r\n                                K[0] = 0;\r\n                                zerok = ((K[NM1] == 0) ? 1 : 0);\r\n                            }\r\n                            else {\r\n                                // Used scaled form of recurrence if value of K at 0 is nonzero\r\n                                t = -aa / cc;\r\n                                for(var i = 0; i < NM1; i++) {\r\n                                    j = NM1 - i;\r\n                                    K[j] = t * K[j - 1] + p[j];\r\n                                } // End for i\r\n                                K[0] = p[0];\r\n                                zerok = ((Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10.0) ? 1 : 0);\r\n                            }\r\n                        }\r\n\r\n                        // Save K for restarts with new shifts\r\n                        for(var i = 0; i < N; i++)\r\n                            temp[i] = K[i];\r\n\r\n                        // Loop to select the quadratic corresponding to each new shift\r\n                        for(jj = 1; jj <= 20; jj++) {\r\n\r\n                            // Quadratic corresponds to a double shift to a non-real point and its\r\n                            // complex conjugate. The point has modulus BND and amplitude rotated\r\n                            // by 94 degrees from the previous shift.\r\n\r\n                            xxx = -(sinr * yy) + cosr * xx;\r\n                            yy = sinr * xx + cosr * yy;\r\n                            xx = xxx;\r\n                            sr = bnd * xx;\r\n                            u = -(2.0 * sr);\r\n\r\n                            // Second stage calculation, fixed quadratic\r\n                            Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N, p, NN, qp, u, Fxshfr_Par);\r\n\r\n                            if(Fxshfr_Par.NZ != 0) {\r\n                                // The second stage jumps directly to one of the third stage iterations and\r\n                                // returns here if successful. Deflate the polynomial, store the zero or\r\n                                // zeros, and return to the main algorithm.\r\n                                j = degPar.Degree - N;\r\n                                zeror[j] = Fxshfr_Par.szr;\r\n                                zeroi[j] = Fxshfr_Par.szi;\r\n                                NN = NN - Fxshfr_Par.NZ;\r\n                                N = NN - 1;\r\n                                for(var i = 0; i < NN; i++)\r\n                                    p[i] = qp[i];\r\n                                if(Fxshfr_Par.NZ != 1) {\r\n                                    zeror[j + 1] = Fxshfr_Par.lzr;\r\n                                    zeroi[j + 1] = Fxshfr_Par.lzi;\r\n                                }\r\n                                break;\r\n                            }\r\n                            else {\r\n                                // If the iteration is unsuccessful, another quadratic is chosen after restoring K\r\n                                for(var i = 0; i < N; i++) {\r\n                                    K[i] = temp[i];\r\n                                }\r\n                            }\r\n                        }\r\n                        // Return with failure if no convergence with 20 shifts\r\n                        if(jj > 20) {\r\n                            degPar.Degree -= N;\r\n                            break;\r\n                        }\r\n                    }\r\n                    // >>>>> End Main Loop <<<<<\r\n                    return;\r\n                }\r\n                //--> End Jenkins-Traub\r\n                rpSolve(degreePar, p, zeror, zeroi);\r\n\r\n                var l = zeroi.length;\r\n                //format the output\r\n                for(i = 0; i < l; i++) {\r\n                    // We round the imaginary part to avoid having something crazy like 5.67e-16.\r\n                    var img = round(zeroi[i], decp + 8),\r\n                            real = round(zeror[i], decp + 8);\r\n                    // Did the rounding pay off? If the rounding did nothing more than chop off a few digits then no.\r\n                    // If the rounding results in a a number at least 3 digits shorter we'll keep it else we'll keep \r\n                    // the original otherwise the rounding was worth it.\r\n                    real = decp - String(real).length > 2 ? real : zeror[i];\r\n                    var sign = img < 0 ? '-' : '';\r\n\r\n                    // Remove the zeroes\r\n                    if(real === 0) {\r\n                        real = '';\r\n                    }\r\n                    if(img === 0) {\r\n                        img = '';\r\n                    }\r\n\r\n                    // Remove 1 as the multiplier and discard imaginary part if there isn't one.\r\n                    img = Math.abs(img) === 1 ? sign + 'i' : (img ? img + '*i' : '');\r\n\r\n                    var num = (real && img) ? real + '+' + img : real + img;\r\n                    zeror[i] = num.replace(/\\+\\-/g, '-');\r\n                }\r\n                return zeror;\r\n            }\r\n        },\r\n        roots: function (symbol) {\r\n\r\n            if(symbol.isConstant(true, true)) {\r\n                return core.Utils.nroots(symbol);\r\n            }\r\n            var roots = __.proots(symbol).map(function (x) {\r\n                return _.parse(x);\r\n            });\r\n            return core.Vector.fromArray(roots);\r\n        },\r\n        froot: function (f, guess, dx) {\r\n            var newtonraph = function (xn) {\r\n                var mesh = 1e-12,\r\n                        // If the derivative was already provided then don't recalculate.\r\n                        df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())),\r\n                        // If the function was passed in as a function then don't recalculate.\r\n                        fn = f instanceof Function ? f : core.Utils.build(f),\r\n                        max = 10000,\r\n                        done = false,\r\n                        safety = 0;\r\n                while(!done) {\r\n                    var x = xn - (fn(xn) / df(xn));\r\n                    //absolute values for both x & xn ensures that we indeed have the radius    \r\n                    var r = Math.abs(x) - Math.abs(xn),\r\n                            delta = Math.abs(r);\r\n                    xn = x;\r\n\r\n                    if(delta < mesh)\r\n                        done = true;\r\n                    else if(safety > max) {\r\n                        xn = null;\r\n                        done = true;\r\n                    }\r\n\r\n                    safety++;\r\n                }\r\n                return xn;\r\n            };\r\n            return newtonraph(Number(guess));\r\n        },\r\n        quad: function (a, b, c) {\r\n            var q = function (a, b, c, sign) {\r\n                return _.parse('-(' + b + '+' + sign + '*sqrt((' + b + ')^2-4*(' + a + ')*(' + c + ')))/(2*' + a + ')');\r\n            };\r\n            return [q(a, b, c, 1), q(a, b, c, -1)];\r\n        },\r\n        sumProd: function (a, b) {\r\n            return __.quad(-b, a, -1).map(function (x) {\r\n                return x.invert();\r\n            });\r\n        },\r\n        coeffs: function (symbol, wrt, coeffs) {\r\n            wrt = String(wrt);\r\n            symbol = _.expand(symbol);\r\n            coeffs = coeffs || [new Symbol(0)];\r\n            //we cannot get coeffs for group EX\r\n            if(symbol.group === EX && symbol.contains(wrt, true))\r\n                _.error('Unable to get coefficients using expression ' + symbol.toString());\r\n            var vars = variables(symbol);\r\n            if(vars.length === 1 && vars[0] === wrt && !symbol.isImaginary()) {\r\n                var a = new Polynomial(symbol).coeffs.map(function (x) {\r\n                    return new Symbol(x);\r\n                });\r\n\r\n                for(var i = 0, l = a.length; i < l; i++) {\r\n                    var coeff = a[i],\r\n                            e = coeffs[i];\r\n                    if(e)\r\n                        coeff = _.add(e, coeff);\r\n                    coeffs[i] = coeff; //transfer it all over\r\n                }\r\n            }\r\n            else {\r\n                if(!wrt)\r\n                    _.error('Polynomial contains more than one variable. Please specify which variable is to be used!');\r\n                //if the variable isn't part of this polynomial then we're looking at x^0\r\n\r\n                if(vars.indexOf(wrt) === -1) {\r\n                    coeffs[0] = _.add(symbol, coeffs[0]);\r\n                }\r\n                else {\r\n                    coeffs = coeffs || [new Symbol(0)];\r\n                    if(symbol.group === CB) {\r\n                        var s = symbol.symbols[wrt];\r\n                        if(!s)\r\n                            _.error('Expression is not a polynomial!');\r\n                        var p = Number(s.power);\r\n                        coeff = _.divide(symbol.clone(), s.clone());\r\n                        if(coeff.contains(wrt, true) || p < 0 || !isInt(p))\r\n                            _.error('Expression is not a polynomial!');\r\n                        var e = coeffs[p];\r\n                        if(e)\r\n                            coeff = _.add(e, coeff);\r\n                        coeffs[p] = coeff;\r\n                    }\r\n                    else if(symbol.group === CP) {\r\n                        symbol.each(function (x) {\r\n                            __.coeffs(x.clone(), wrt, coeffs);\r\n                        }, true);\r\n                    }\r\n                }\r\n            }\r\n            //fill holes\r\n            for(var i = 0, l = coeffs.length; i < l; i++)\r\n                if(typeof coeffs[i] === 'undefined')\r\n                    coeffs[i] = new Symbol(0);\r\n\r\n            return coeffs;\r\n        },\r\n        /**\r\n         * Get's all the powers of a particular polynomial including the denominators. The denominators powers\r\n         * are returned as negative. All remaining polynomials are returned as zero order polynomials.\r\n         * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]\r\n         * @param {Symbol} e\r\n         * @param {String} for_variable\r\n         * @param {Array} powers\r\n         * @returns {Array} An array of the powers\r\n         */\r\n        //assumes you've already verified that it's a polynomial\r\n        polyPowers: function (e, for_variable, powers) {\r\n            powers = powers || [];\r\n            var g = g = e.group;\r\n            if(g === PL && for_variable === e.value) {\r\n                powers = powers.concat(keys(e.symbols));\r\n            }\r\n            else if(g === CP) {\r\n                for(var s in e.symbols) {\r\n                    var symbol = e.symbols[s];\r\n                    var g = symbol.group, v = symbol.value;\r\n                    if(g === S && for_variable === v)\r\n                        powers.push(symbol.power);\r\n                    else if(g === PL || g === CP)\r\n                        powers = __.polyPowers(symbol, for_variable, powers);\r\n                    else if(g === CB && symbol.contains(for_variable)) {\r\n                        var t = symbol.symbols[for_variable];\r\n                        if(t)\r\n                            powers.push((t.power));\r\n                    }\r\n                    else if(g === N || for_variable !== v)\r\n                        powers.push(0);\r\n                }\r\n            }\r\n            else if(g === CB && e.contains(for_variable)) {\r\n                powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);\r\n            }\r\n            return core.Utils.arrayUnique(powers).sort();\r\n        },\r\n        //The factor object\r\n        Factor: {\r\n            //splits the symbol in symbol and constant\r\n            split: function (symbol) {\r\n                var c = new Symbol(1); //the constants part\r\n                var s = new Symbol(1); //the symbolic part\r\n                __.Factor.factor(symbol, new Factors()).each(function (x) {\r\n                    var t = _.parse(x);\r\n                    if(x.isConstant(true)) {\r\n                        c = _.multiply(c, t);\r\n                    }\r\n                    else {\r\n                        s = _.multiply(s, t);\r\n                    }\r\n                });\r\n                return [c, s];\r\n            },\r\n            mix: function (o, include_negatives) {\r\n                var factors = keys(o);\r\n                var l = factors.length;\r\n                var m = [];//create a row which we'r going to be mixing\r\n                for(var i = 0; i < l; i++) {\r\n                    var factor = factors[i],\r\n                            p = o[factor];\r\n                    var ll = m.length;\r\n                    for(var j = 0; j < ll; j++) {\r\n                        var t = m[j] * factor;\r\n                        m.push(t);\r\n                        if(include_negatives)\r\n                            m.push(-t);\r\n                    }\r\n\r\n                    for(var j = 1; j <= p; j++)\r\n                        m.push(Math.pow(factor, j));\r\n                }\r\n                return m;\r\n            },\r\n            //TODO: this method is to replace common factoring\r\n            common: function (symbol, factors) {\r\n                try {\r\n                    if(symbol.group === CP) {\r\n                        //this may have the unfortunate side effect of expanding and factoring again\r\n                        //to only end up with the same result. \r\n                        //TODO: try to avoid this\r\n                        //collect the symbols and sort to have the longest first. Thinking is that the longest terms \r\n                        //has to contain the variable in order for it to be factorable\r\n                        var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function (a, b) {\r\n                            return (b.length || 1) - (a.length || 1);\r\n                        });\r\n\r\n                        var map = {}; //create a map of common factors\r\n                        var coeffs = [];\r\n                        for(var i = 0; i < symbols.length; i++) {\r\n                            var sym = symbols[i];\r\n                            coeffs.push(sym.multiplier.clone());\r\n                            sym.each(function (x) {\r\n                                var p = Number(x.power);\r\n                                //This check exits since we have a symbolic power.\r\n                                //For the future... think about removing this check and modify for symbolic powers\r\n                                if(isNaN(p))\r\n                                    throw new Error('exiting');\r\n                                //loop through the symbols and lump together common terms\r\n                                if(x.value in map) {\r\n                                    if(p < map[x.value][0])\r\n                                        map[x.value][0] = p;\r\n                                    map[x.value][1].push(x);\r\n                                }\r\n                                else\r\n                                    map[x.value] = [p, [x]];\r\n                            });\r\n                        }\r\n                        //the factor\r\n                        var factor = new Symbol(1);\r\n                        for(var x in map) {\r\n                            //if this factor is found in all terms since the length of \r\n                            //matching variable terms matches the number of original terms\r\n                            if(map[x][1].length === symbols.length) {\r\n                                //generate a symbol and multiply into the factor\r\n                                factor = _.multiply(factor, _.pow(new Symbol(x), new Symbol(map[x][0])));\r\n                            }\r\n                        }\r\n                        //get coefficient factor\r\n                        var c = core.Math2.QGCD.apply(null, coeffs);\r\n\r\n                        if(!c.equals(1)) {\r\n                            factors.add(new Symbol(c));\r\n                            for(var i = 0; i < symbols.length; i++) {\r\n                                symbols[i].multiplier = symbols[i].multiplier.divide(c);\r\n                            }\r\n                        }\r\n\r\n                        //if we actuall found any factors\r\n                        if(!factor.equals(1)) {\r\n                            factors.add(factor);\r\n                            symbol = new Symbol(0);\r\n                            for(var i = 0; i < symbols.length; i++) {\r\n                                symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    ;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            zeroes: function (symbol, factors) {\r\n                var exit = function () {\r\n                    throw new core.exceptions.ValueLimitExceededError('Exiting');\r\n                };\r\n                try {\r\n                    var vars, term, sum, p, e;\r\n                    symbol = _.expand(symbol.clone());\r\n                    e = symbol.toString();\r\n                    vars = variables(symbol);\r\n\r\n                    sum = new Symbol(0);\r\n\r\n                    var terms = [];\r\n                    var powers = [];\r\n\r\n                    //start setting each variable to zero\r\n                    for(var i = 0, l = vars.length; i < vars.length; i++) {\r\n                        var subs = {};\r\n                        //we want to create a subs object with all but the current variable set to zero\r\n                        for(var j = 0; j < l; j++)\r\n                            if(i !== j) //make sure we're not looking at the same variable\r\n                                subs[vars[j]] = 0;\r\n                        term = _.parse(e, subs);\r\n                        var tp = term.power;\r\n                        //the temporary power has to be an integer as well\r\n                        if(!isInt(tp))\r\n                            exit();\r\n                        terms.push(term);\r\n                        powers.push(term.power);\r\n                    }\r\n\r\n                    //get the gcd. This will be the p in (a^n+b^m)^p\r\n                    //if the gcd equals 1 meaning n = m then we need a tie breakder\r\n                    if(core.Utils.allSame(powers)) {\r\n                        //get p given x number of terms\r\n                        var n_terms = symbol.length;\r\n                        //the number of zeroes determines\r\n                        var n_zeroes = terms.length;\r\n                        if(n_zeroes === 2) {\r\n                            p = new Frac(powers[0] / (n_terms - 1));\r\n                        }\r\n                        if(n_zeroes === 3) {\r\n                            p = new Frac(powers[0] / Math.round((Math.sqrt(8 * n_terms - 1) - 3) / 2));\r\n                        }\r\n                        /*\r\n                         //get the lowest possible power\r\n                         //e.g. given b^4+2*a^2*b^2+a^4, the power we're looking for would be 2\r\n                         symbol.each(function(x) {\r\n                         if(x.group === CB)\r\n                         x.each(function(y) {\r\n                         if(!p || y.power.lessThan(p))\r\n                         //p = Number(y.power);\r\n                         p = y.power;\r\n                         });\r\n                         else if(!p || x.power.lessThan(p))\r\n                         //p = Number(x.power);\r\n                         p = x.power;\r\n                         });\r\n                         */\r\n                    }\r\n                    else\r\n                        //p is just the gcd of the powers\r\n                        p = core.Math2.QGCD.apply(null, powers);\r\n\r\n                    //if we don't have an integer then exit\r\n                    if(!isInt(p))\r\n                        exit();\r\n\r\n                    //build the factor\r\n                    for(var i = 0; i < terms.length; i++) {\r\n                        var t = terms[i];\r\n                        var n = t.power.clone().divide(p);\r\n                        t.multiplier = new Frac(Math.pow(t.multiplier, 1 / n));\r\n                        t.power = p.clone();\r\n                        sum = _.add(sum, t);\r\n                    }\r\n\r\n                    //by now we have the factor of zeroes. We'll know if we got it right because \r\n                    //we'll get a remainder of zero each time we divide by it\r\n                    if(sum.group !== CP)\r\n                        return symbol; //nothing to do\r\n\r\n                    while(true) {\r\n                        var d = __.div(symbol.clone(), sum.clone());\r\n                        if(d[1].equals(0)) {\r\n                            symbol = d[0];\r\n                            factors.add(sum.clone());\r\n                            if(symbol.equals(1)) //we've reached 1 so done.\r\n                                break;\r\n                        }\r\n                        else\r\n                            break;\r\n                    }\r\n                }\r\n                catch(e) {\r\n                }\r\n                ;\r\n\r\n                return symbol;\r\n            },\r\n            factor: function (symbol, factors) {\r\n                // Don't try to factor constants\r\n                if(symbol.isConstant()) {\r\n                    return core.Math2.factor(symbol);\r\n                }\r\n\r\n                var _symbol = _.parse(symbol);\r\n                var retval = __.Factor._factor(_symbol, factors);\r\n                if(retval.equals(symbol)) {\r\n                    return retval;\r\n                }\r\n\r\n                if(retval.group === CB) {\r\n                    var t = new Symbol(1);\r\n                    var p = _.parse(retval.power);\r\n                    //store the multiplier and strip it\r\n                    var m = _.parse(retval.multiplier);\r\n\r\n                    retval.toUnitMultiplier();\r\n\r\n                    /* \r\n                     * NOTE: for sign issues with factor START DEBUGGING HERE\r\n                     */\r\n                    //move the sign to t\r\n                    if(retval.multiplier.lessThan(0)) {\r\n                        t.negate();\r\n                        retval.negate();\r\n                    }\r\n\r\n                    retval.each(function (x) {\r\n                        // Related to #566. Since the symbol's group may not have been properly\r\n                        // updated, it's easier to just parse the symbol and have the parser \r\n                        // do the update for us.\r\n                        var factored = _.parse(__.Factor._factor(x));\r\n\r\n                        if(factored.group === CB) {\r\n                            // Include the multiplier\r\n                            m = _.multiply(m, Symbol.create(factored.multiplier));\r\n                            factored.each(function (y) {\r\n                                var _factored = _.parse(__.Factor._factor(y));\r\n                                t = _.multiply(t, _factored);\r\n                                if(_factored.group === CB) {\r\n                                    m = _.multiply(m, Symbol.create(_factored.multiplier));\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            t = _.multiply(t, factored);\r\n                        }\r\n                    });\r\n\r\n                    //put back the multiplier and power\r\n                    retval = _.pow(_.multiply(m, t), p);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            quadFactor: function (symbol, factors) {\r\n                if(symbol.isPoly() && __.degree(symbol.equals(2))) {\r\n                    //We've  already checked that we're dealing with a polynomial\r\n                    var v = core.Utils.variables(symbol)[0]; //get the variable\r\n                    var coeffs = __.coeffs(symbol, v);\r\n                    //factor the lead coefficient\r\n                    var cf = __.Factor._factor(coeffs[2].clone());\r\n                    //check if we have factors\r\n                    if(cf.group === CB) {\r\n                        var symbols = cf.collectSymbols();\r\n                        //if the factors are greater than 2 we're done so exit\r\n                        if(symbols.length > 2)\r\n                            return symbol;\r\n                        //if we have two factors then attempt to factor the polynomial\r\n                        //let the factors be f1 and f1\r\n                        //let the factors be (ax+b)(cx+d)\r\n                        //let the coefficients be c1x^2+c2x+c3\r\n                        //then a(x1)+c(x2)=c2 and x1*x2=c3\r\n                        //we can solve for x1 and x2\r\n                        var c = _.multiply(_.parse(coeffs[0]), _.parse(symbols[0]));\r\n                        var b = _.parse(coeffs[1]).negate();\r\n                        var a = _.parse(symbols[1]);\r\n                        //solve the system\r\n                        var root = __.quad(a, b, c).filter(function (x) {\r\n                            if(core.Utils.isInt(x))\r\n                                return x;\r\n                        });\r\n                        //if we have one root then find the other one by dividing the constant\r\n                        if(root.length === 1) {\r\n                            var root1 = root[0];\r\n                            var root2 = _.divide(coeffs[0], _.parse(root1));\r\n                            if(core.Utils.isInt(root2)) {\r\n                                //we found them both\r\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[1], v, root2)));\r\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[0], v, root1)));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return symbol;\r\n            },\r\n            cubeFactor: function (symbol, factors) {\r\n                if(symbol.isComposite()) {\r\n                    var symbols = symbol.collectSymbols();\r\n                    // The symbol should be in the form of a^3+-b^3. The length\r\n                    // should therefore only be two. If it's any different from this\r\n                    // then we're done\r\n                    if(symbols.length === 2) {\r\n                        // Store the signs and then strip them from the symbols\r\n                        var sign_a = symbols[0].sign();\r\n                        var a = symbols[0].clone().abs();\r\n                        var sign_b = symbols[1].sign();\r\n                        var b = symbols[1].clone().abs();\r\n                        // Check if they're cube\r\n                        if(a.isCube() && b.isCube()) {\r\n                            // Keep the negative sign on the right, meaning b is always negative.\r\n                            if(sign_a < sign_b) {\r\n                                // Swap the signs and then the values\r\n                                [sign_a, sign_b] = [sign_b, sign_a];\r\n                                [a, b] = [b, a];\r\n                            }\r\n\r\n                            // Get teh roots\r\n                            var m_root_a = _.parse(a.getNth(3));\r\n                            var m_root_b = _.parse(b.getNth(3));\r\n\r\n                            // Remove the cube for both\r\n                            var x = _.multiply(_.expand(_.pow(a.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_a);\r\n                            var y = _.multiply(_.expand(_.pow(b.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_b);\r\n\r\n                            if(sign_a === 1 && sign_b === -1) {\r\n                                // Apply difference of cubes rule\r\n                                factors.add(_.parse(format('(({0})-({1}))', x, y)));\r\n                                factors.add(_.parse(format('(({0})^2+({0})*({1})+({1})^2)', x, y)));\r\n                                symbol = Symbol(1);\r\n                            }\r\n                            else if(sign_a === 1 && sign_b === 1) {\r\n                                // Apply sum of cubes rule\r\n                                factors.add(_.parse(format('(({0})+({1}))', x, y)));\r\n                                factors.add(_.parse(format('(({0})^2-({0})*({1})+({1})^2)', x, y)));\r\n                                symbol = Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            _factor: function (symbol, factors) {\r\n                var g = symbol.group;\r\n                //some items cannot be factored any further so return those right away\r\n                if(symbol.group === FN) {\r\n                    var arg = symbol.args[0];\r\n                    if(arg.group === S && arg.isSimple()) {\r\n                        return symbol;\r\n                    }\r\n                }\r\n                else if(symbol.group === S && symbol.isSimple()) {\r\n                    return symbol;\r\n                }\r\n\r\n                // Expand the symbol to get it in a predictable form. If this step\r\n                // is skipped some factors are missed.\r\n                //if(symbol.group === CP && !(even(symbol.power) && symbol.multiplier.lessThan(0))) {\r\n                if(symbol.group === CP) {\r\n                    symbol.distributeMultiplier(true);\r\n                    var t = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        if((x.group === CP && x.power.greaterThan(1) || x.group === CB))\r\n                            x = _.expand(x);\r\n                        t = _.add(t, x);\r\n                    });\r\n                    t.power = symbol.power;\r\n\r\n                    symbol = t;\r\n                }\r\n\r\n                if(symbol.group === FN && symbol.fname !== 'sqrt') {\r\n                    symbol = core.Utils.evaluate(symbol);\r\n                }\r\n\r\n                //make a copy of the symbol to return if something goes wrong\r\n                var untouched = symbol.clone();\r\n                try {\r\n                    if(symbol.group === CB) {\r\n                        var p = _.parse(symbol.power);\r\n\r\n                        var den_array, num_array, den, num, dfact, nfact;\r\n                        //grab the denominator and strip the multiplier and power. Store them in an array\r\n                        den_array = __.Simplify.strip(symbol.getDenom());\r\n                        num_array = __.Simplify.strip(symbol.getNum());\r\n\r\n                        den = den_array.pop();\r\n                        num = num_array.pop();\r\n\r\n                        //if the numerator equals the symbol then we've hit the simplest form and then we're done\r\n                        if(num.equals(symbol)) {\r\n                            return symbol;\r\n                        }\r\n                        nfact = __.Factor.factor(num);\r\n                        dfact = __.Factor.factor(den);\r\n\r\n                        var n = __.Simplify.unstrip(num_array, nfact);\r\n                        var d = __.Simplify.unstrip(den_array, dfact);\r\n\r\n                        var retval = _.divide(n, d);\r\n\r\n                        return retval;\r\n                    }\r\n                    if(symbol.group === S) {\r\n                        return symbol; //absolutely nothing to do\r\n                    }\r\n\r\n                    if(symbol.isConstant()) {\r\n                        if(symbol.equals(1))\r\n                            return symbol.clone();\r\n                        var ret = core.Math2.factor(symbol);\r\n                        return ret;\r\n                    }\r\n\r\n                    var p = symbol.power.clone();\r\n\r\n                    if(isInt(p) && !(p.lessThan(0) && symbol.group === FN)) {\r\n                        var sign = p.sign();\r\n                        symbol.toLinear();\r\n                        factors = factors || new Factors();\r\n                        var map = {};\r\n                        symbol = _.parse(core.Utils.subFunctions(symbol, map));\r\n                        if(keys(map).length > 0) { //it might have functions\r\n                            factors.preAdd = function (factor) {\r\n                                var ret = _.parse(factor, core.Utils.getFunctionsSubs(map));\r\n                                return ret;\r\n                            };\r\n                        }\r\n\r\n                        //strip the power\r\n                        if(!symbol.isLinear()) {\r\n                            factors.pFactor = symbol.power.toString();\r\n                            symbol.toLinear();\r\n                        }\r\n\r\n                        var vars = variables(symbol);\r\n                        //bypass for imaginary. TODO: find a better solution\r\n                        if(symbol.isImaginary()) {\r\n                            vars.push(core.Settings.IMAGINARY);\r\n                        }\r\n                        var multiVar = vars.length > 1;\r\n\r\n                        //minor optimization. Seems to cut factor time by half in some cases.\r\n                        if(multiVar) {\r\n                            var all_S = true, all_unit = true;\r\n                            symbol.each(function (x) {\r\n                                if(x.group !== S)\r\n                                    all_S = false;\r\n                                if(!x.multiplier.equals(1))\r\n                                    all_unit = false;\r\n                            });\r\n\r\n                            if(all_S && all_unit) {\r\n                                return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));\r\n                            }\r\n                        }\r\n\r\n                        //factor the coefficients\r\n                        var coeff_factors = new Factors();\r\n\r\n                        symbol = __.Factor.coeffFactor(symbol, coeff_factors);\r\n\r\n                        coeff_factors.each(function (x) {\r\n                            // If the factor was negative but was within a square then it becomes positive\r\n                            if(even(p) && x.lessThan(0)) {\r\n                                x.negate();\r\n                            }\r\n\r\n                            if(sign < 0)\r\n                                x.invert();\r\n                            factors.add(x);\r\n                        });\r\n\r\n                        //factor the power\r\n                        var power_factors = new Factors();\r\n                        symbol = __.Factor.powerFactor(symbol, power_factors);\r\n                        power_factors.each(function (x) {\r\n                            if(sign < 0)\r\n                                x.invert();\r\n                            factors.add(x);\r\n                        });\r\n\r\n                        if(!multiVar) {\r\n                            //pass in vars[0] for safety\r\n                            var v = vars[0];\r\n\r\n                            symbol = __.Factor.squareFree(symbol, factors, v);\r\n\r\n                            var t_factors = new Factors();\r\n\r\n                            symbol = __.Factor.trialAndError(symbol, t_factors, v);\r\n\r\n                            //generate a symbol based off the last factors\r\n                            var tf_symbol = t_factors.toSymbol();\r\n                            //if nothing was factored then return the factors\r\n                            if(tf_symbol.equals(untouched)) {\r\n                                return tf_symbol;\r\n                            }\r\n\r\n                            for(var x in t_factors.factors) {\r\n                                //store the current factor in t_factor\r\n                                var t_factor = t_factors.factors[x];\r\n                                factors.add(_.pow(t_factor, _.parse(p)));\r\n                            }\r\n                            //if we still don't have a factor and it's quadratic then let's just do a quad factor\r\n                            if(symbol.equals(untouched)) {\r\n                                symbol = __.Factor.quadFactor(symbol, factors);\r\n                            }\r\n\r\n                        }\r\n                        else {\r\n                            // Try sum and difference of cubes\r\n                            symbol = __.Factor.cubeFactor(symbol, factors);\r\n\r\n                            symbol = __.Factor.mfactor(symbol, factors);\r\n\r\n                            //put back the sign of power\r\n                            factors.each(function (x) {\r\n                                if(sign < 0)\r\n                                    x.power.negate();\r\n                            });\r\n                        }\r\n\r\n                        //last minute clean up\r\n                        symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));\r\n                        \r\n                        var addPower = factors.length === 1;\r\n                        \r\n                        factors.add(_.pow(symbol, _.parse(p)));\r\n\r\n                        var retval = factors.toSymbol();\r\n                        \r\n                        // We may have only factored out the symbol itself so we end up with a factor of one \r\n                        // where the power needs to be placed back\r\n                        // e.g. factor((2*y+p)^2). Here we end up having a factor of 1 remaining and a p of 2.\r\n                        if(addPower && symbol.equals(1) && retval.isLinear()) {\r\n                            retval = _.pow(retval, _.parse(p));\r\n                        }\r\n                        \r\n                        return retval;\r\n                    }\r\n\r\n                    return symbol;\r\n                }\r\n                catch(e) {\r\n                    //no need to stop the show because something went wrong :). Just return the unfactored.\r\n                    return untouched;\r\n                }\r\n            },\r\n            reduce: function (symbol, factors) {\r\n                if(symbol.group === CP && symbol.length === 2) {\r\n                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                        return b.multiplier - a.multiplier;\r\n                    });\r\n                    if(symbols[0].power.equals(symbols[1].power)) {\r\n                        //x^n-a^n\r\n                        var n = _.parse(symbols[0].power),\r\n                                a = symbols[0].clone().toLinear(),\r\n                                b = symbols[1].clone().toLinear();\r\n\r\n                        //apply rule: (a-b)*sum(a^(n-i)*b^(i-1),1,n)\r\n                        factors.add(_.add(a.clone(), b.clone()));\r\n                        //flip the sign\r\n                        b.negate();\r\n                        //turn n into a number\r\n                        var nn = Number(n);\r\n                        //the remainder\r\n                        var result = new Symbol(0);\r\n                        for(var i = 1; i <= nn; i++) {\r\n                            var aa = _.pow(a.clone(), _.subtract(n.clone(), new Symbol(i))),\r\n                                    bb = _.pow(b.clone(), _.subtract(new Symbol(i), new Symbol(1)));\r\n                            result = _.add(result, _.multiply(aa, bb));\r\n                        }\r\n                        return result;\r\n                    }\r\n                }\r\n                return symbol;\r\n            },\r\n            /**\r\n             * Makes Symbol square free\r\n             * @param {Symbol} symbol\r\n             * @param {Factors} factors\r\n             * @@param {String} variable The variable which is being factored \r\n             * @returns {[Symbol, Factor]}\r\n             */\r\n            squareFree: function (symbol, factors, variable) {\r\n                if(symbol.isConstant() || symbol.group === S)\r\n                    return symbol;\r\n\r\n                var poly = new Polynomial(symbol, variable);\r\n                var sqfr = poly.squareFree();\r\n                var p = sqfr[2];\r\n                //if we found a square then the p entry in the array will be non-unit\r\n                if(p !== 1) {\r\n                    //make sure the remainder doesn't have factors\r\n                    var t = sqfr[1].toSymbol();\r\n                    t.power = t.power.multiply(new Frac(p));\r\n                    //send the factor to be fatored to be sure it's completely factored\r\n                    factors.add(__.Factor.factor(t));\r\n\r\n                    var retval = __.Factor.squareFree(sqfr[0].toSymbol(), factors);\r\n\r\n                    return retval;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            /**\r\n             * Factors the powers such that the lowest power is a constant\r\n             * @param {Symbol} symbol\r\n             * @param {Factors} factors\r\n             * @returns {[Symbol, Factor]}\r\n             */\r\n            powerFactor: function (symbol, factors) {\r\n                //only PL need apply\r\n                if(symbol.group !== PL || symbol.previousGroup === EX)\r\n                    return symbol;\r\n                var k = keys(symbol.symbols);\r\n                //we expect only numeric powers so return all else\r\n                if(!core.Utils.allNumeric(k))\r\n                    return symbol;\r\n\r\n                var d = core.Utils.arrayMin(k);\r\n                var retval = new Symbol(0);\r\n                var q = _.parse(symbol.value + '^' + d);\r\n                symbol.each(function (x) {\r\n                    x = _.divide(x, q.clone());\r\n                    retval = _.add(retval, x);\r\n                });\r\n\r\n                factors.add(q);\r\n                return retval;\r\n            },\r\n            /**\r\n             * Removes GCD from coefficients\r\n             * @param {Symbol} symbol\r\n             * @param {Factor} factors\r\n             * @returns {Symbol}\r\n             */\r\n            coeffFactor: function (symbol, factors) {\r\n                if(symbol.isComposite()) {\r\n                    var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());\r\n\r\n                    if(!gcd.equals(1)) {\r\n                        symbol.each(function (x) {\r\n                            if(x.isComposite()) {\r\n                                x.each(function (y) {\r\n                                    y.multiplier = y.multiplier.divide(gcd);\r\n                                });\r\n                            }\r\n                            else\r\n                                x.multiplier = x.multiplier.divide(gcd);\r\n                        });\r\n                        symbol.updateHash();\r\n                    }\r\n                    else {\r\n                        // TODO: This should probably go to the prototype\r\n                        var power = function (symbol) {\r\n                            var p;\r\n                            if(symbol.group === CB) {\r\n                                p = 0;\r\n                                symbol.each(function (x) {\r\n                                    p += x.power;\r\n                                });\r\n                            }\r\n                            else {\r\n                                p = Number(symbol.power);\r\n                            }\r\n                            return p;\r\n                        };\r\n                        // Factor out negatives from the lead term\r\n                        var terms = symbol.collectSymbols(null, null, null, true).sort(function (a, b) {\r\n                            // Push constants to the back\r\n                            if(a.isConstant(true))\r\n                                return 1;\r\n                            return b.power - a.power;\r\n                        });\r\n\r\n                        var LT = terms[0];\r\n\r\n                        // Check if the LT is indeed the greatest\r\n                        if(power(LT) > power(terms[1]) || terms[1].isConstant(true)) {\r\n                            if(LT.multiplier.lessThan(0)) {\r\n                                // Although the symbol should always be linear at this point, remove the negative for squares\r\n                                // to be safe.\r\n                                factors.add(new Symbol(-1));\r\n\r\n                                symbol.each(function (x) {\r\n                                    x.negate();\r\n                                }, true);\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(factors) {\r\n                        factors.add(new Symbol(gcd));\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            /**\r\n             * The name says it all :)\r\n             * @param {Symbol} symbol\r\n             * @param {Factor} factors\r\n             * @@param {String} variable \r\n             * @returns {Symbol}\r\n             */\r\n            trialAndError: function (symbol, factors, variable) {\r\n                var untouched = symbol.clone();\r\n                try {\r\n                    // At temp holder for the factors. If all goes well then\r\n                    // they'll be moved to the actual factors.\r\n                    var factor_array = [];\r\n\r\n                    if(symbol.isConstant() || symbol.group === S)\r\n                        return symbol;\r\n                    var poly = new Polynomial(symbol, variable),\r\n                            cnst = poly.coeffs[0],\r\n                            cfactors = core.Math2.ifactor(cnst),\r\n                            roots = __.proots(symbol);\r\n                    for(var i = 0; i < roots.length; i++) {\r\n                        var r = roots[i],\r\n                                p = 1;\r\n                        if(!isNaN(r)) { //if it's a number\r\n                            for(var x in cfactors) {\r\n                                //check it's raised to a power\r\n                                var n = core.Utils.round(Math.log(x) / Math.log(Math.abs(r)), 8);\r\n                                if(isInt(n)) {\r\n                                    r = x; //x must be the root since n gave us a whole\r\n                                    p = n;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            var root = new Frac(r),\r\n                                    terms = [new Frac(root.num).negate()];\r\n                            terms[p] = new Frac(root.den);\r\n                            //convert to Frac. The den is coeff of LT and the num is coeff of constant\r\n                            var div = Polynomial.fromArray(terms, poly.variable).fill(),\r\n                                    t = poly.divide(div);\r\n                            if(t[1].equalsNumber(0)) { //if it's zero we have a root and divide it out\r\n                                poly = t[0];\r\n                                // factors.add(div.toSymbol());\r\n                                factor_array.push(div.toSymbol());\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(!poly.equalsNumber(1)) {\r\n                        poly = __.Factor.search(poly, factors);\r\n                    }\r\n\r\n                    // Move the factors over since all went well.\r\n                    factor_array.forEach(function (x) {\r\n                        factors.add(x);\r\n                    });\r\n\r\n                    return poly.toSymbol();\r\n                }\r\n                catch(e) {\r\n                    return untouched;\r\n                }\r\n            },\r\n            search: function (poly, factors, base) {\r\n                base = base || 10; //I like 10 because numbers exhibit similar behaviours at 10\r\n                var v = poly.variable; //the polynmial variable name\r\n                /**\r\n                 * Attempt to remove a root by division given a number by first creating\r\n                 * a polynomial fromt he given information\r\n                 * @param {int} c1 - coeffient for the constant\r\n                 * @param {int} c2 - coefficient for the LT\r\n                 * @param {int} n - the number to be used to construct the polynomial\r\n                 * @param {int} p - the power at which to create the polynomial\r\n                 * @returns {null|Polynomial} - returns polynomial if successful otherwise null\r\n                 */\r\n                var check = function (c1, c2, n, p) {\r\n                    var candidate = Polynomial.fit(c1, c2, n, base, p, v);\r\n                    if(candidate && candidate.coeffs.length > 1) {\r\n                        var t = poly.divide(candidate);\r\n                        if(t[1].equalsNumber(0)) {\r\n                            factors.add(candidate.toSymbol());\r\n                            return [t[0], candidate];\r\n                        }\r\n                    }\r\n                    return null;\r\n                };\r\n                var cnst = poly.coeffs[0];\r\n                var cfactors = core.Math2.ifactor(cnst);\r\n                var lc = poly.lc();\r\n                var ltfactors = core.Math2.ifactor(lc);\r\n                var subbed = poly.sub(base);\r\n                var isubbed = core.Math2.ifactor(subbed);\r\n                var nfactors = __.Factor.mix(isubbed, subbed < 0);\r\n                var cp = Math.ceil(poly.coeffs.length / 2);\r\n                var lc_is_neg = lc.lessThan(0);\r\n                var cnst_is_neg = cnst.lessThan(0);\r\n                ltfactors['1'] = 1;\r\n                cfactors['1'] = 1;\r\n                while(cp--) {\r\n                    for(var x in ltfactors) {\r\n                        for(var y in cfactors) {\r\n                            for(var i = 0; i < nfactors.length; i++) {\r\n                                var factor_found = check(x, y, nfactors[i], cp);\r\n                                if(factor_found) {\r\n                                    poly = factor_found[0];\r\n                                    if(!core.Utils.isPrime(poly.sub(base)))\r\n                                        poly = __.Factor.search(poly, factors);\r\n                                    return poly;\r\n                                }\r\n                                else if(!factor_found) {\r\n                                    if(lc_is_neg && cnst_is_neg)\r\n                                        factor_found = check(-x, -y, nfactors[i], cp);\r\n                                    else if(lc_is_neg)\r\n                                        factor_found = check(-x, y, nfactors[i], cp); //check a negative lc\r\n                                    else if(cnst_is_neg)\r\n                                        factor_found = check(x, -y, nfactors[i], cp); //check a negative constant\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return poly;\r\n            },\r\n            /**\r\n             * Equivalent of square free factor for multivariate polynomials\r\n             * @param {type} symbol\r\n             * @param {type} factors\r\n             * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}\r\n             */\r\n            mSqfrFactor: function (symbol, factors) {\r\n                if(symbol.group !== FN) {\r\n                    var vars = variables(symbol).reverse();\r\n\r\n                    // Loop through all the variable and remove the partial derivatives\r\n                    for(var i = 0; i < vars.length; i++) {\r\n                        do {\r\n                            if(vars[i] === symbol.value) {\r\n                                //the derivative tells us nothing since this symbol is already the factor\r\n                                factors.add(symbol);\r\n                                symbol = new Symbol(1);\r\n                                continue;\r\n                            }\r\n\r\n                            var diff = core.Calculus.diff(symbol, vars[i]);\r\n\r\n                            var d = __.Factor.coeffFactor(diff);\r\n\r\n                            if(d.equals(0))\r\n                                break;\r\n\r\n                            //trial division to see if factors have whole numbers. \r\n                            //This can be optimized by stopping as soon as can_divide is false\r\n                            //this will also need utilize big number at some point\r\n                            var can_divide = true;\r\n                            if(d.isConstant() && symbol.isComposite()) {\r\n                                //check the coefficients\r\n\r\n                                symbol.each(function (x) {\r\n                                    if(x.multiplier % d !== 0)\r\n                                        can_divide = false;\r\n                                }, true);\r\n                            }\r\n\r\n                            //if we can divide then do so\r\n                            if(can_divide) {\r\n\r\n                                var div = __.div(symbol, d.clone()),\r\n                                        is_factor = div[1].equals(0);\r\n                                \r\n                                // Break infinite loop for factoring e^t*x-1\r\n                                if((symbol.equals(div[0]) && div[1].equals(0))) {\r\n                                    break;\r\n                                }\r\n                                \r\n                                if(div[0].isConstant()) {\r\n                                    factors.add(div[0]);\r\n                                    break;\r\n                                }\r\n                                \r\n                            }\r\n                            else\r\n                                is_factor = false;\r\n\r\n                            if(is_factor) {\r\n                                factors.add(div[0]);\r\n                                symbol = d;\r\n                            }\r\n                        }\r\n                        while(is_factor)\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            //difference of squares factorization\r\n            sqdiff: function (symbol, factors) {\r\n                if(symbol.isConstant('all')) {\r\n                    // Nothing to do\r\n                    return symbol;\r\n                }\r\n\r\n                try {\r\n                    var remove_square = function (x) {\r\n                        return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\r\n                            return Symbol.unwrapPARENS(math.sqrt(math.abs(x)));\r\n                        }, true);\r\n                    };\r\n                    var separated = core.Utils.separate(symbol.clone());\r\n\r\n                    var obj_array = [];\r\n\r\n                    //get the unique variables\r\n                    for(var x in separated) {\r\n                        if(x !== 'constants') {\r\n                            obj_array.push(separated[x]);\r\n                        }\r\n                    }\r\n                    obj_array.sort(function (a, b) {\r\n                        return b.power - a.power;\r\n                    });\r\n\r\n                    //if we have the same number of variables as unique variables then we can apply the difference of squares\r\n                    if(obj_array.length === 2) {\r\n                        var a, b;\r\n                        a = obj_array.pop();\r\n                        b = obj_array.pop();\r\n\r\n                        if(even(a.power) && even(b.power)\r\n                                && a.sign() === b.sign()\r\n                                && a.group === S && b.group === S) {\r\n                            throw new Error('Unable to factor');\r\n                        }\r\n                        ;\r\n\r\n                        if(a.isComposite() && b.power.equals(2)) {\r\n                            //remove the square from b\r\n                            b = remove_square(b);\r\n                            var f = __.Factor.factor(_.add(a, separated.constants));\r\n                            if(f.power.equals(2)) {\r\n                                f.toLinear();\r\n                                factors.add(_.subtract(f.clone(), b.clone()));\r\n                                factors.add(_.add(f, b));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                        else {\r\n                            a = a.powSimp();\r\n                            b = b.powSimp();\r\n\r\n                            if((a.group === S || a.fname === '') && a.power.equals(2) && (b.group === S || b.fname === '') && b.power.equals(2) && !separated.constants) {\r\n                                if(a.multiplier.lessThan(0)) {\r\n                                    var t = b;\r\n                                    b = a;\r\n                                    a = t;\r\n                                }\r\n                                if(a.multiplier.greaterThan(0)) {\r\n                                    a = remove_square(a);\r\n                                    b = remove_square(b);\r\n                                }\r\n\r\n                                factors.add(_.subtract(a.clone(), b.clone()));\r\n                                factors.add(_.add(a, b));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    ;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            //factoring for multivariate\r\n            mfactor: function (symbol, factors) {\r\n\r\n                if(symbol.group === FN) {\r\n                    if(symbol.fname === 'sqrt') {\r\n                        var factors2 = new Factors(),\r\n                                arg = __.Factor.common(symbol.args[0].clone(), factors2);\r\n                        arg = __.Factor.coeffFactor(arg, factors2);\r\n                        symbol = _.multiply(_.symfunction('sqrt', [arg]), _.parse(symbol.multiplier));\r\n                        factors2.each(function (x) {\r\n                            symbol = _.multiply(symbol, _.parse(core.Utils.format('sqrt({0})', x)));\r\n                        });\r\n                    }\r\n                    else\r\n                        factors.add(symbol);\r\n                }\r\n                else {\r\n\r\n                    //square free factorization\r\n                    symbol = __.Factor.mSqfrFactor(symbol, factors);\r\n\r\n                    //try factor out common factors\r\n                    //symbol = __.Factor.common(symbol, factors);\r\n\r\n                    var vars = variables(symbol),\r\n                            symbols = symbol.collectSymbols().map(function (x) {\r\n                        return Symbol.unwrapSQRT(x);\r\n                    }),\r\n                            sorted = {},\r\n                            maxes = {},\r\n                            l = vars.length, n = symbols.length;\r\n                    //take all the variables in the symbol and organize by variable name\r\n                    //e.g. a^2+a^2+b*a -> {a: {a^3, a^2, b*a}, b: {b*a}}\r\n\r\n                    for(var i = 0; i < l; i++) {\r\n                        var v = vars[i];\r\n                        sorted[v] = new Symbol(0);\r\n                        for(var j = 0; j < n; j++) {\r\n                            var s = symbols[j];\r\n                            if(s.contains(v)) {\r\n                                var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();\r\n                                if(!maxes[v] || p < maxes[v])\r\n                                    maxes[v] = p;\r\n                                sorted[v] = _.add(sorted[v], s.clone());\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    for(var x in sorted) {\r\n                        var r = _.parse(x + '^' + maxes[x]);\r\n                        var div = _.divide(sorted[x], r);\r\n                        var new_factor = _.expand(div);\r\n\r\n                        if(new_factor.equals(1))\r\n                            break; //why divide by one. Just move \r\n                        var divided = __.div(symbol.clone(), new_factor);\r\n\r\n                        if(divided[0].equals(0)) {\r\n                            //cant factor anymore\r\n                            break;\r\n                        }\r\n\r\n                        // We potentially ended up with fractional coefficients when the\r\n                        // trial division was performed. We need to remove \r\n                        // This check will more then likely become superfluous with improvements\r\n                        // to polynomial division\r\n                        if(divided[1].equals(0)) {\r\n                            var has_fractions = false;\r\n\r\n                            divided[0].each(function (x) {\r\n                                if(!isInt(x.multiplier)) {\r\n                                    has_fractions = true;\r\n                                }\r\n                            });\r\n\r\n                            // The factor isn't really a factor and needs to be put back\r\n                            if(has_fractions) {\r\n                                divided[1] = _.expand(_.multiply(divided[1], new_factor));\r\n                                // Since the new factor is not just one, we exit.\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);\r\n\r\n                        if(divided[1].equals(0) && !neg_numeric_factor) { //we found at least one factor\r\n\r\n                            //factors.add(new_factor);\r\n                            var d = __.div(symbol.clone(), divided[0].clone());\r\n                            var r = d[0];\r\n\r\n                            // Nothing left to do since we didn't get a reduction\r\n                            if(r.equals(0)) {\r\n                                return symbol;\r\n                            }\r\n\r\n                            symbol = d[1];\r\n                            //we don't want to just flip the sign. If the remainder is -1 then we accomplished nothing\r\n                            //and we just return the symbol;\r\n                            //If r equals zero then there's nothing left to do so we're done\r\n\r\n                            if(r.equals(-1) && !symbol.equals(0))\r\n                                return symbol;\r\n\r\n                            var factor = divided[0];\r\n\r\n                            if(symbol.equals(factor)) {\r\n                                var rem = __.Factor.reduce(factor, factors);\r\n\r\n                                if(!symbol.equals(rem))\r\n                                    return __.Factor.mfactor(rem, factors);\r\n\r\n                                return rem;\r\n                            }\r\n                            else {\r\n                                factors.add(factor);\r\n                                //if the remainder of the symbol is zero then we're done. TODO: Rethink this logic a bit.\r\n                                if(symbol.equals(0))\r\n                                    return r;\r\n                            }\r\n\r\n                            if(r.isConstant('all')) {\r\n                                factors.add(r);\r\n                                return r;\r\n                            }\r\n\r\n                            return __.Factor.mfactor(r, factors);\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                //difference of squares factorization\r\n                symbol = __.Factor.sqdiff(symbol, factors);\r\n\r\n                //factors by fishing for zeroes\r\n                symbol = __.Factor.zeroes(symbol, factors);\r\n\r\n                return symbol;\r\n            }\r\n        },\r\n        /**\r\n         * Checks to see if a set of \"equations\" is linear. \r\n         * @param {type} set\r\n         * @returns {Boolean}\r\n         */\r\n        allLinear: function (set) {\r\n            var l = set.length;\r\n            for(var i = 0; i < l; i++) {\r\n                if(!__.isLinear(set[i]))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        /*\r\n         * Checks to see if the \"equation\" is linear\r\n         * @param {Symbol} e\r\n         * @returns {boolean}\r\n         */\r\n        isLinear: function (e) {\r\n            var status = false, g = e.group;\r\n            if(g === PL || g === CP) {\r\n                status = true;\r\n                for(var s in e.symbols) {\r\n                    var symbol = e.symbols[s], sg = symbol.group;\r\n                    if(sg === FN || sg === EX) {\r\n                        status = false;\r\n                    }\r\n                    if(sg === CB) {\r\n                        //needs further checking since it might be imaginary\r\n                        status = variables(symbol).length === 1;\r\n                    }\r\n                    else {\r\n                        if(sg === PL || sg === CP)\r\n                            status = __.isLinear(symbol);\r\n                        else {\r\n                            if(symbol.group !== N && symbol.power.toString() !== '1') {\r\n                                status = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if(g === S && e.power === 1)\r\n                status = true;\r\n            return status;\r\n        },\r\n        gcd: function () {\r\n            var args;\r\n            if(arguments.length === 1 && arguments[0] instanceof core.Vector)\r\n                args = arguments[0].elements;\r\n            else\r\n                args = core.Utils.arguments2Array(arguments);\r\n\r\n            //short-circuit early\r\n            if(args.length === 0)\r\n                return new Symbol(1);\r\n            else if(args.length === 1)\r\n                return args[0];\r\n\r\n            var appeared = [], evaluate = false;\r\n            for(var i = 0; i < args.length; i++) {\r\n                if(args[i].group === FN && args[i].fname === 'gcd')\r\n                {\r\n                    //compress gcd(a,gcd(b,c)) into gcd(a,b,c)\r\n                    args = args.concat(arguments[i].args);\r\n                    //do not keep gcd in args\r\n                    args.splice(i, 1);\r\n                }\r\n                else\r\n                {\r\n                    //Look if there are any common variables such that\r\n                    //gcd(a,b) => gcd(a,b); gcd(a,a) => a\r\n                    var vars = variables(args[i]);\r\n                    if(core.Utils.haveIntersection(vars, appeared))\r\n                    {\r\n                        //Ok, there are common variables\r\n                        evaluate = true;\r\n                        break;\r\n                    }\r\n                    else\r\n                        appeared = appeared.concat(vars);\r\n                }\r\n            }\r\n\r\n            //appeared.length is 0 when all arguments are group N\r\n            if(evaluate || appeared.length === 0) {\r\n                //TODO: distribute exponent so that (a^-1*b^-1)^-1 => a*b\r\n                if(args.every(function (symbol) {\r\n                    return symbol.getDenom().equals(1)\r\n                })) {\r\n                    var aggregate = args[0];\r\n\r\n                    for(var i = 1; i < args.length; i++) {\r\n                        aggregate = __.gcd_(args[i], aggregate);\r\n                    }\r\n                    return aggregate;\r\n                }\r\n                else {\r\n                    //gcd_ cannot handle denominators correctly\r\n                    return _.divide(__.gcd.apply(null, args.map(function (symbol) {\r\n                        return symbol.getNum();\r\n                    })),\r\n                            __.lcm.apply(null, args.map(function (symbol) {\r\n                                return symbol.getDenom();\r\n                            })));\r\n                }\r\n            }\r\n            else\r\n                return _.symfunction('gcd', args);\r\n        },\r\n        gcd_: function (a, b) {\r\n            if(a.group === FN || a.group === P)\r\n                a = core.Utils.block('PARSE2NUMBER', function () {\r\n                    return _.parse(a);\r\n                });\r\n\r\n            if(b.group === FN)\r\n                b = core.Utils.block('PARSE2NUMBER', function () {\r\n                    return _.parse(b);\r\n                });\r\n\r\n            if(a.isConstant() && b.isConstant()) {\r\n                // return core.Math2.QGCD(new Frac(+a), new Frac(+b));\r\n                return new Symbol(core.Math2.QGCD(new Frac(+a), new Frac(+b)));\r\n            }\r\n\r\n            var den = _.multiply(a.getDenom() || new Symbol(1), b.getDenom() || new Symbol(1)).invert();\r\n            a = _.multiply(a.clone(), den.clone());\r\n            b = _.multiply(b.clone(), den.clone());\r\n\r\n            //feels counter intuitive but it works. Issue #123 (nerdamer(\"gcd(x+y,(x+y)^2)\"))\r\n            a = _.expand(a);\r\n            b = _.expand(b);\r\n\r\n            if(a.group === CB || b.group === CB) {\r\n                var q = _.divide(a.clone(), b.clone()); //get the quotient\r\n                var t = _.multiply(b.clone(), q.getDenom().invert());//multiply by the denominator\r\n                //if they have a common factor then the result will not equal one \r\n                if(!t.equals(1))\r\n                    return t;\r\n            }\r\n\r\n            //just take the gcd of each component when either of them is in group EX\r\n            if(a.group === EX || b.group === EX)\r\n            {\r\n                var gcd_m = new Symbol(core.Math2.GCD(a.multiplier, b.multiplier));\r\n                var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol(1) : _.parse(b.value));\r\n                var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));\r\n                return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));\r\n            }\r\n\r\n            if(a.length < b.length) { //swap'm\r\n                var t = a;\r\n                a = b;\r\n                b = t;\r\n            }\r\n            var vars_a = variables(a), vars_b = variables(b);\r\n            if((vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0])\r\n                    || vars_a.length === 1 && vars_b.length === 0\r\n                    || vars_a.length === 0 && vars_b.length === 1) {\r\n                a = new Polynomial(a);\r\n                b = new Polynomial(b);\r\n                return _.divide(a.gcd(b).toSymbol(), den);\r\n            }\r\n            else {\r\n                //get the gcd of the multipiers\r\n                //get rid of gcd in coeffs\r\n                var multipliers = [];\r\n                a.each(function (x) {\r\n                    multipliers.push(x.multiplier);\r\n                });\r\n                b.each(function (x) {\r\n                    multipliers.push(x.multiplier);\r\n                });\r\n\r\n                var T;\r\n                while(!b.equals(0)) {\r\n                    var t = b.clone();\r\n                    a = a.clone();\r\n                    T = __.div(a, t);\r\n\r\n                    b = T[1];\r\n                    if(T[0].equals(0)) {\r\n                        //return _.multiply(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), b);\r\n                        return _.divide(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), den);\r\n                    }\r\n                    a = t;\r\n                }\r\n\r\n                var gcd = core.Math2.QGCD.apply(undefined, multipliers);\r\n\r\n                if(!gcd.equals(1)) {\r\n                    a.each(function (x) {\r\n                        x.multiplier = x.multiplier.divide(gcd);\r\n                    });\r\n                }\r\n\r\n                //return symbolic function for gcd in indeterminate form\r\n                if(a.equals(1) && !a.isConstant() && !b.isConstant())\r\n                    return _.divide(_.symfunction('gcd', arguments), den);\r\n\r\n                return _.divide(a, den);\r\n            }\r\n        },\r\n        lcm: function () {\r\n            //https://math.stackexchange.com/a/319310\r\n            //generalization of the 2-variable formula of lcm\r\n\r\n            var args;\r\n            if(arguments.length === 1)\r\n                if(arguments[0] instanceof core.Vector)\r\n                    args = arguments[0].elements;\r\n                else\r\n                    _.error('lcm expects either 1 vector or 2 or more arguments');\r\n            else\r\n                args = core.Utils.arguments2Array(arguments);\r\n\r\n            //product of all arguments\r\n            //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\r\n            var numer = args.reduce(function (prev, curr) {\r\n                return _.multiply(prev, curr.clone())\r\n            }, new Symbol(1));\r\n\r\n            //gcd of complementary terms\r\n            var denom_args =\r\n                    //https://stackoverflow.com/a/18223072\r\n                //take all complementary terms, e.g.\r\n                //[a,b,c] => [a*b, b*c, a*c]\r\n                //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]\r\n                (function (input, size) {\r\n                        size = Number(size);\r\n                        var results = [], result, mask, i, total = Math.pow(2, input.length);\r\n                        for(mask = size; mask < total; mask++) {\r\n                            result = [];\r\n                            i = input.length - 1;\r\n\r\n                            do {\r\n                                if((mask & (1 << i)) !== 0) {\r\n                                    result.push(input[i]);\r\n                                }\r\n                            }\r\n                            while(i--);\r\n\r\n                            if(result.length === size) {\r\n                                results.push(result);\r\n                            }\r\n                        }\r\n                        return results;\r\n                        //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\r\n                    })(arguments, arguments.length - 1).map(function (x) {\r\n                return x.reduce(function (prev, curr) {\r\n                    return _.multiply(prev, curr.clone())\r\n                }, new Symbol(1))\r\n            });\r\n\r\n            var denom;\r\n            //don't eat the gcd term if all arguments are symbols\r\n            if(args.every(function (x) {\r\n                return core.Utils.isVariableSymbol(x)\r\n            }))\r\n                denom = _.symfunction('gcd', core.Utils.arrayUnique(denom_args));\r\n            else\r\n                denom = __.gcd.apply(null, denom_args);\r\n            //divide product of all arguments by gcd of complementary terms\r\n            var div = _.divide(numer, denom);\r\n            return div;\r\n        },\r\n        /**\r\n         * Divides one expression by another\r\n         * @param {Symbol} symbol1\r\n         * @param {Symbol} symbol2\r\n         * @returns {Array}\r\n         */\r\n        divide: function (symbol1, symbol2) {\r\n            var result, remainder, factored, den;\r\n            factored = core.Algebra.Factor.factor(symbol1.clone());\r\n            den = factored.getDenom();\r\n            if(!den.isConstant('all')) {\r\n                symbol1 = _.expand(Symbol.unwrapPARENS(_.multiply(factored, den.clone())));\r\n            }\r\n            else\r\n                //reset the denominator since we're not dividing by it anymore\r\n                den = new Symbol(1);\r\n            result = __.div(symbol1, symbol2);\r\n            remainder = _.divide(result[1], symbol2);\r\n            return _.divide(_.add(result[0], remainder), den);\r\n        },\r\n        div: function (symbol1, symbol2) {\r\n            // If all else fails then assume that division failed with\r\n            // a remainder of zero and the original quotient\r\n            var fail = [new Symbol(0), symbol1.clone()];\r\n\r\n            try {\r\n\r\n                // Division by constants\r\n                if(symbol2.isConstant('all')) {\r\n                    symbol1.each(function (x) {\r\n                        x.multiplier = x.multiplier.divide(symbol2.multiplier);\r\n                    });\r\n                    return [symbol1, new Symbol(0)];\r\n                }\r\n                // So that factorized symbols don't affect the result\r\n                symbol1 = _.expand(symbol1);\r\n                symbol2 = _.expand(symbol2);\r\n                // Special case. May need revisiting\r\n                if(symbol1.group === S && symbol2.group === CP) {\r\n                    var x = symbol1.value;\r\n                    var f = core.Utils.decompose_fn(symbol2.clone(), x, true);\r\n                    if(symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {\r\n                        var k = Symbol.create(symbol1.multiplier);\r\n                        return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];\r\n                    }\r\n                }\r\n                if(symbol1.group === S && symbol2.group === S) {\r\n                    var r = _.divide(symbol1.clone(), symbol2.clone());\r\n                    if(r.isConstant()) //we have a whole\r\n                        return [r, new Symbol(0)];\r\n                    return [new Symbol(0), symbol1.clone()];\r\n                }\r\n                var symbol1_has_func = symbol1.hasFunc(),\r\n                        symbol2_has_func = symbol2.hasFunc(),\r\n                        parse_funcs = false;\r\n\r\n                //substitute out functions so we can treat them as regular variables\r\n                if(symbol1_has_func || symbol2_has_func) {\r\n                    parse_funcs = true;\r\n                    var map = {},\r\n                            symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)),\r\n                            symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)),\r\n                            subs = core.Utils.getFunctionsSubs(map);\r\n                }\r\n                //get a list of the variables\r\n                var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))),\r\n                        quot, rem;\r\n\r\n                //treat imaginary numbers as variables\r\n                if(symbol1.isImaginary() || symbol2.isImaginary()) {\r\n                    vars.push(core.Settings.IMAGINARY);\r\n                }\r\n\r\n                if(vars.length === 1) {\r\n                    var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));\r\n                    quot = q[0].toSymbol();\r\n                    rem = q[1].toSymbol();\r\n                }\r\n                else {\r\n                    vars.push(CONST_HASH); //this is for the numbers\r\n                    var reconvert = function (arr) {\r\n                        var symbol = new Symbol(0);\r\n                        for(var i = 0; i < arr.length; i++) {\r\n                            var x = arr[i].toSymbol();\r\n                            symbol = _.add(symbol, x);\r\n                        }\r\n                        return symbol;\r\n                    };\r\n\r\n                    // Silly Martin. This is why you document. I don't remember now\r\n                    var get_unique_max = function (term, any) {\r\n                        var max = Math.max.apply(null, term.terms),\r\n                                count = 0, idx;\r\n\r\n                        if(!any) {\r\n                            for(var i = 0; i < term.terms.length; i++) {\r\n                                if(term.terms[i].equals(max)) {\r\n                                    idx = i;\r\n                                    count++;\r\n                                }\r\n                                if(count > 1)\r\n                                    return;\r\n                            }\r\n                        }\r\n                        if(any) {\r\n                            for(i = 0; i < term.terms.length; i++)\r\n                                if(term.terms[i].equals(max)) {\r\n                                    idx = i;\r\n                                    break;\r\n                                }\r\n                        }\r\n                        return [max, idx, term];\r\n                    };\r\n\r\n                    // Tries to find an LT in the dividend that will satisfy division\r\n                    var get_det = function (s, lookat) {\r\n                        lookat = lookat || 0;\r\n                        var det = s[lookat], l = s.length;\r\n                        if(!det)\r\n                            return;\r\n                        //eliminate the first term if it doesn't apply\r\n                        var umax = get_unique_max(det);\r\n                        for(var i = lookat + 1; i < l; i++) {\r\n                            var term = s[i],\r\n                                    is_equal = det.sum.equals(term.sum);\r\n                            if(!is_equal && umax) {\r\n                                break;\r\n                            }\r\n                            if(is_equal) {\r\n                                // Check the differences of their maxes. The one with the biggest difference governs\r\n                                // e.g. x^2*y^3 vs x^2*y^3 is unclear but this isn't the case in x*y and x^2\r\n                                var max1, max2, idx1, idx2, l2 = det.terms.length;\r\n                                for(var j = 0; j < l2; j++) {\r\n                                    var item1 = det.terms[j], item2 = term.terms[j];\r\n                                    if(typeof max1 === 'undefined' || item1.greaterThan(max1)) {\r\n                                        max1 = item1;\r\n                                        idx1 = j;\r\n                                    }\r\n                                    if(typeof max2 === 'undefined' || item2.greaterThan(max2)) {\r\n                                        max2 = item2;\r\n                                        idx2 = j;\r\n                                    }\r\n                                }\r\n                                //check their differences\r\n                                var d1 = max1.subtract(term.terms[idx1]),\r\n                                        d2 = max2.subtract(det.terms[idx2]);\r\n                                if(d2 > d1) {\r\n                                    umax = [max2, idx2, term];\r\n                                    break;\r\n                                }\r\n                                if(d1 > d2) {\r\n                                    umax = [max1, idx1, det];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            else {\r\n                                //check if it's a suitable pick to determine the order\r\n                                umax = get_unique_max(term);\r\n                                //if(umax) return umax;\r\n                                if(umax)\r\n                                    break;\r\n                            }\r\n                            umax = get_unique_max(term); //calculate a new unique max\r\n                        }\r\n\r\n                        //if still no umax then any will do since we have a tie\r\n                        if(!umax)\r\n                            return get_unique_max(s[0], true);\r\n                        var e, idx;\r\n                        for(var i = 0; i < s2.length; i++) {\r\n                            var cterm = s2[i].terms;\r\n                            //confirm that this is a good match for the denominator\r\n                            idx = umax[1];\r\n                            if(idx === cterm.length - 1)\r\n                                return;\r\n                            e = cterm[idx];\r\n                            if(!e.equals(0))\r\n                                break;\r\n                        }\r\n                        if(e.equals(0))\r\n                            return get_det(s, ++lookat); //look at the next term\r\n\r\n                        return umax;\r\n                    };\r\n\r\n                    var t_map = core.Utils.toMapObj(vars);\r\n                    var init_sort = function (a, b) {\r\n                        return b.sum.subtract(a.sum);\r\n                    };\r\n                    var is_larger = function (a, b) {\r\n                        if(!a || !b)\r\n                            return false; //it's empty so...\r\n                        for(var i = 0; i < a.terms.length; i++) {\r\n                            if(a.terms[i].lessThan(b.terms[i]))\r\n                                return false;\r\n                        }\r\n                        return true;\r\n                    };\r\n\r\n                    var s1 = symbol1.tBase(t_map).sort(init_sort),\r\n                            s2 = symbol2.tBase(t_map).sort(init_sort);\r\n                    var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1; //since the num is already larger than we can get the det from denom\r\n                    var det = get_det(target);//we'll begin by assuming that this will let us know which term \r\n                    var quotient = [];\r\n                    if(det) {\r\n                        var lead_var = det[1];\r\n                        var can_divide = function (a, b) {\r\n                            if(a[0].sum.equals(b[0].sum))\r\n                                return a.length >= b.length;\r\n                            return true;\r\n                        };\r\n\r\n                        var try_better_lead_var = function (s1, s2, lead_var) {\r\n                            var checked = [];\r\n                            for(var i = 0; i < s1.length; i++) {\r\n                                var t = s1[i];\r\n                                for(var j = 0; j < t.terms.length; j++) {\r\n                                    var cf = checked[j], tt = t.terms[j];\r\n                                    if(i === 0)\r\n                                        checked[j] = tt; //add the terms for the first one\r\n                                    else if(cf && !cf.equals(tt))\r\n                                        checked[j] = undefined;\r\n                                }\r\n                            }\r\n                            for(var i = 0; i < checked.length; i++) {\r\n                                var t = checked[i];\r\n                                if(t && !t.equals(0))\r\n                                    return i;\r\n                            }\r\n                            return lead_var;\r\n                        };\r\n                        var sf = function (a, b) {\r\n                            var l1 = a.len(), l2 = b.len();\r\n                            var blv = b.terms[lead_var], alv = a.terms[lead_var];\r\n                            if(l2 > l1 && blv.greaterThan(alv))\r\n                                return l2 - l1;\r\n                            return blv.subtract(alv);\r\n                        };\r\n\r\n                        //check to see if there's a better lead_var\r\n                        lead_var = try_better_lead_var(s1, s2, lead_var);\r\n                        //reorder both according to the max power\r\n                        s1.sort(sf); //sort them both according to the leading variable power\r\n                        s2.sort(sf);\r\n\r\n                        //try to adjust if den is larger\r\n                        var fdt = s2[0], fnt = s1[0];\r\n\r\n                        var den = new MVTerm(new Frac(1), [], fnt.map);\r\n                        if(fdt.sum.greaterThan(fnt.sum) && fnt.len() > 1) {\r\n                            for(var i = 0; i < fnt.terms.length; i++) {\r\n                                var d = fdt.terms[i].subtract(fnt.terms[i]);\r\n                                if(!d.equals(0)) {\r\n                                    var nd = d.add(new Frac(1));\r\n                                    den.terms[i] = d;\r\n                                    for(var j = 0; j < s1.length; j++) {\r\n                                        s1[j].terms[i] = s1[j].terms[i].add(nd);\r\n                                    }\r\n                                }\r\n                                else\r\n                                    den.terms[i] = new Frac(0);\r\n                            }\r\n                        }\r\n\r\n                        var dividend_larger = is_larger(s1[0], s2[0]);\r\n\r\n                        var safety = 0;\r\n                        var max = 200;\r\n\r\n                        while(dividend_larger && can_divide(s1, s2)) {\r\n                            if(safety++ > max) {\r\n                                throw new core.exceptions.InfiniteLoopError('Unable to compute!');\r\n                            }\r\n\r\n                            var q = s1[0].divide(s2[0]);\r\n\r\n                            quotient.push(q); //add what's divided to the quotient\r\n                            s1.shift();//the first one is guaranteed to be gone so remove from dividend\r\n                            for(var i = 1; i < s2.length; i++) { //loop through the denominator\r\n                                var t = s2[i].multiply(q).generateImage(),\r\n                                        l2 = s1.length;\r\n                                //if we're subtracting from 0\r\n                                if(l2 === 0) {\r\n                                    t.coeff = t.coeff.neg();\r\n                                    s1.push(t);\r\n                                    s1.sort(sf);\r\n                                }\r\n\r\n                                for(var j = 0; j < l2; j++) {\r\n                                    var cur = s1[j];\r\n                                    if(cur.getImg() === t.getImg()) {\r\n                                        cur.coeff = cur.coeff.subtract(t.coeff);\r\n                                        if(cur.coeff.equals(0)) {\r\n                                            core.Utils.remove(s1, j);\r\n                                            j--; //adjust the iterator\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                    if(j === l2 - 1) {\r\n                                        t.coeff = t.coeff.neg();\r\n                                        s1.push(t);\r\n                                        s1.sort(sf);\r\n                                    }\r\n                                }\r\n                            }\r\n                            dividend_larger = is_larger(s1[0], s2[0]);\r\n\r\n                            if(!dividend_larger && s1.length >= s2.length) {\r\n                                //One more try since there might be a terms that is larger than the LT of the divisor\r\n                                for(var i = 1; i < s1.length; i++) {\r\n                                    dividend_larger = is_larger(s1[i], s2[0]);\r\n                                    if(dividend_larger) {\r\n                                        //take it from its current position and move it to the front\r\n                                        s1.unshift(core.Utils.remove(s1, i));\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    quot = reconvert(quotient);\r\n                    rem = reconvert(s1);\r\n\r\n                    if(typeof den !== 'undefined') {\r\n                        den = den.toSymbol();\r\n                        quot = _.divide(quot, den.clone());\r\n                        rem = _.divide(rem, den);\r\n                    }\r\n                }\r\n\r\n                //put back the functions\r\n                if(parse_funcs) {\r\n                    quot = _.parse(quot.text(), subs);\r\n                    rem = _.parse(rem.text(), subs);\r\n                }\r\n\r\n                return [quot, rem];\r\n            }\r\n            catch(e) {\r\n                return fail;\r\n            }\r\n\r\n        },\r\n        line: function (v1, v2, x) {\r\n            if(core.Utils.isArray(v1))\r\n                v1 = core.Utils.convertToVector(v1);\r\n            if(core.Utils.isArray(v2))\r\n                v2 = core.Utils.convertToVector(v2);\r\n            x = _.parse(x || 'x');\r\n            if(!core.Utils.isVector(v1) || !core.Utils.isVector(v2))\r\n                _.error('Line expects a vector! Received \"' + v1 + '\" & \"' + v2 + '\"');\r\n            var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()),\r\n                    dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()),\r\n                    m = _.divide(dy, dx),\r\n                    a = _.multiply(x, m.clone()),\r\n                    b = _.multiply(v1.e(1).clone(), m);\r\n            return _.add(_.subtract(a, b), v1.e(2).clone());\r\n        },\r\n        PartFrac: {\r\n            createTemplate: function (den, denom_factors, f_array, v) {\r\n                //clean up the denominator function by factors so it reduces nicely\r\n                den = __.Factor.factor(den);\r\n\r\n                //clean up factors. This is so inefficient but factors are wrapped in parens for safety\r\n                den.each(function (x, key) {\r\n                    if(x.group === FN && x.fname === '' && x.args[0].group === S) {\r\n                        var y = x.args[0];\r\n                        if(this.symbols) {\r\n                            delete this.symbols[key];\r\n                            this.symbols[y.value] = y;\r\n                        }\r\n                        else {\r\n                            den = x.args[0];\r\n                        }\r\n                    }\r\n                });\r\n\r\n                var factors, factors_vec, f, p, deg, degrees, m;\r\n                factors = denom_factors.collectFactors();\r\n                factors_vec = []; //a vector for the template\r\n                degrees = [];\r\n                m = new Symbol(1);\r\n\r\n                for(var i = 0; i < factors.length; i++) { //loop through the factors\r\n                    var factor = Symbol.unwrapPARENS(factors[i]);\r\n                    //if in he for P^n where P is polynomial and n = integer\r\n                    if(factor.power.greaterThan(1)) {\r\n                        p = Number(factor.power);\r\n                        f = factor.clone().toLinear(); //remove the power so we have only the function\r\n                        deg = Number(__.degree(f, v)); //get the degree of f\r\n                        //expand the factor\r\n                        for(var j = 0; j < p; j++) {\r\n                            var efactor = _.pow(f.clone(), new Symbol(j + 1));\r\n                            f_array.push(efactor.clone());\r\n                            var d = _.divide(den.clone(), efactor.clone());\r\n                            degrees.push(deg);\r\n                            factors_vec.push(d);\r\n                        }\r\n                    }\r\n                    /*\r\n                     Possible bug.\r\n                     Removed: causes 1/(20+24*x+4*x^2) to result in (-1/64)*(5+x)^(-1)+(1/64)*(1+x)^(-1)\r\n                     else if(factor.isConstant('all')) {\r\n                     m = _.multiply(m, factor);\r\n                     }\r\n                     */\r\n                    else {\r\n                        //get the degree of the factor so we tack it on tot he factor. This should probably be an array\r\n                        //but for now we note it on the symbol\r\n                        deg = Number(__.degree(factor, v));\r\n                        f_array.push(factor);\r\n                        var d = _.divide(den.clone(), factor.clone());\r\n                        d = _.expand(Symbol.unwrapPARENS(d));\r\n                        degrees.push(deg);\r\n                        factors_vec.push(d);\r\n                    }\r\n                }\r\n                //put back the constant\r\n                f_array = f_array.map(function (x) {\r\n                    return _.multiply(x, m.clone());\r\n                });\r\n                return [f_array, factors_vec, degrees];\r\n            },\r\n            partfrac: function (symbol, v, as_array) {\r\n\r\n                var vars = variables(symbol);\r\n\r\n                v = v || _.parse(vars[0]); //make wrt optional and assume first variable\r\n                try {\r\n                    var num, den, factors, tfactors, ofactors, nterms, degrees,\r\n                            dterms, max, M, c, powers, div, r, factors_vec, ks,\r\n                            template, tfactors;\r\n                    num = _.expand(symbol.getNum());\r\n                    den = _.expand(symbol.getDenom().toUnitMultiplier());\r\n                    //move the entire multipier to the numerator\r\n                    num.multiplier = symbol.multiplier;\r\n                    //we only have a meaningful change if n factors > 1. This means that\r\n                    //the returned group will be a CB\r\n                    //collect the terms wrt the x\r\n                    nterms = num.groupTerms(v);\r\n                    //divide out wholes if top is larger\r\n                    if(Number(__.degree(num, v)) >= Number(__.degree(den, v))) {\r\n                        div = __.div(num.clone(), _.expand(den.clone()));\r\n                        r = div[0]; //remove the wholes\r\n                        num = div[1]; //work with the remainder\r\n                        nterms = num.groupTerms(v); //recalculate the nterms\r\n                    }\r\n                    else\r\n                        r = new Symbol(0);\r\n\r\n                    if(Number(__.degree(den, v)) === 1) {\r\n                        var q = _.divide(num, den);\r\n                        if(as_array)\r\n                            return [r, q];\r\n                        return _.add(r, q);\r\n                    }\r\n                    //first factor the denominator. This means that the strength of this\r\n                    //algorithm depends on how well we can factor the denominator. \r\n                    ofactors = __.Factor.factor(den);\r\n                    //create the template. This method will create the template for solving \r\n                    //the partial fractions. So given x/(x-1)^2 the template creates A/(x-1)+B/(x-1)^2\r\n                    template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);\r\n                    tfactors = template[0]; //grab the factors\r\n                    factors_vec = template[1]; //grab the factor vectors\r\n                    degrees = template[2]; //grab the degrees\r\n                    //make note of the powers of each term\r\n                    powers = [nterms.length];\r\n                    //create the dterms vector\r\n                    dterms = [];\r\n                    factors = [];\r\n                    ks = [];\r\n                    var factor, deg;\r\n                    factors_vec.map(function (x, idx) {\r\n                        factor = tfactors[idx];\r\n                        deg = degrees[idx];\r\n                        for(var i = 0; i < deg; i++) {\r\n                            factors.push(factor.clone());\r\n                            var k = Symbol.create(v, i);\r\n                            var t = _.expand(_.multiply(x, k.clone())).groupTerms(v);\r\n                            //make a note of the power which corresponds to the length of the array\r\n                            var p = t.length;\r\n                            powers.push(p);\r\n                            dterms.push(t);\r\n                            ks.push(k.clone());\r\n                        }\r\n                    });\r\n                    //get the max power\r\n                    max = core.Utils.arrayMax(powers);\r\n\r\n                    //fill the holes and create a matrix\r\n                    c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose();\r\n                    //for each of the factors we do the same\r\n                    M = new core.Matrix();\r\n                    for(var i = 0; i < dterms.length; i++) {\r\n                        M.elements.push(core.Utils.fillHoles(dterms[i], max));\r\n                    }\r\n\r\n                    //solve the system of equations\r\n                    var partials = _.multiply(M.transpose().invert(), c);\r\n                    //the results are backwards to reverse it\r\n                    //partials.elements.reverse();\r\n                    //convert it all back\r\n                    var retval = as_array ? [r] : r;\r\n                    partials.each(function (e, i) {\r\n                        var term = _.multiply(ks[i], _.divide(e, factors[i]));\r\n                        if(as_array)\r\n                            retval.push(term);\r\n                        else\r\n                            retval = _.add(retval, term);\r\n                    });\r\n\r\n                    //done\r\n                    return retval;\r\n                }\r\n                catch(e) {\r\n                    //try to group symbols\r\n                    try {\r\n                        if(symbol.isComposite()) {\r\n                            //group denominators\r\n                            var denominators = {};\r\n\r\n                            symbol.each(function (x) {\r\n                                var d = x.getDenom();\r\n                                var n = x.getNum();\r\n                                var e = denominators[d];\r\n                                denominators[d] = e ? _.add(e, n) : n;\r\n                            });\r\n\r\n                            var t = new Symbol(0);\r\n\r\n                            for(var x in denominators) {\r\n                                t = _.add(t, _.divide(denominators[x], _.parse(x)));\r\n                            }\r\n\r\n                            symbol = t;\r\n                        }\r\n                    }\r\n                    catch(e2) {\r\n                    }\r\n                    ;\r\n                }\r\n                ;\r\n\r\n                return symbol;\r\n            }\r\n        },\r\n        degree: function (symbol, v, o) {\r\n            o = o || {\r\n                nd: [], //numeric\r\n                sd: [], //symbolic\r\n                depth: 0 //call depth\r\n            };\r\n\r\n            if(!v) {\r\n                var vars = variables(symbol);\r\n                //The user must specify the variable for multivariate\r\n                if(vars.length > 1)\r\n                    throw new Error('You must specify the variable for multivariate polynomials!');\r\n                //if it's empty then we're dealing with a constant\r\n                if(vars.length === 0)\r\n                    return new Symbol(0);\r\n                //assume the variable for univariate\r\n                v = _.parse(vars[0]);\r\n            }\r\n\r\n            //store the group\r\n            var g = symbol.group;\r\n            //we're going to trust the user and assume no EX. Calling isPoly \r\n            //would eliminate this but no sense in checking twice. \r\n            if(symbol.isComposite()) {\r\n                symbol = symbol.clone();\r\n                symbol.distributeExponent();\r\n                symbol.each(function (x) {\r\n                    o.depth++; //mark a depth increase\r\n                    __.degree(x, v, o);\r\n                    o.depth--; //we're back\r\n                });\r\n            }\r\n            else if(symbol.group === CB) {\r\n                symbol.each(function (x) {\r\n                    o.depth++;\r\n                    __.degree(x, v, o);\r\n                    o.depth++;\r\n                });\r\n            }\r\n            else if(g === EX && symbol.value === v.value) {\r\n                o.sd.push(symbol.power.clone());\r\n            }\r\n            else if(g === S && symbol.value === v.value) {\r\n                o.nd.push(_.parse(symbol.power));\r\n            }\r\n            else\r\n                o.nd.push(new Symbol(0));\r\n\r\n            //get the max out of the array\r\n            var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : undefined;\r\n\r\n            if(o.depth === 0 && o.sd.length > 0) {\r\n                if(deg !== undefined)\r\n                    o.sd.unshift(deg);\r\n                return _.symfunction('max', o.sd);\r\n            }\r\n            if(!core.Utils.isSymbol(deg))\r\n                deg = _.parse(deg);\r\n            //return the degree\r\n            return deg;\r\n        },\r\n        /**\r\n         * Attempts to complete the square of a polynomial\r\n         * @param {type} symbol\r\n         * @param {type} v\r\n         * @param {type} raw\r\n         * @throws {Error} \r\n         * @returns {Object|Symbol[]}\r\n         */\r\n        sqComplete: function (symbol, v, raw) {\r\n            if(!core.Utils.isSymbol(v))\r\n                v = _.parse(v);\r\n            var stop = function (msg) {\r\n                msg = msg || 'Stopping';\r\n                throw new core.exceptions.ValueLimitExceededError(msg);\r\n            };\r\n            //if not CP then nothing to do\r\n            if(!symbol.isPoly(true))\r\n                stop('Must be a polynomial!');\r\n\r\n            //declare vars\r\n            var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;\r\n\r\n            br = core.Utils.inBrackets;\r\n            //make a copy\r\n            symbol = symbol.clone();\r\n            deg = core.Algebra.degree(symbol, v); //get the degree of polynomial\r\n            //must be in form ax^2 +/- bx +/- c\r\n            if(!deg.equals(2))\r\n                stop('Cannot complete square for degree ' + deg);\r\n            //get the coeffs\r\n            coeffs = core.Algebra.coeffs(symbol, v);\r\n            a = coeffs[2];\r\n            //store the sign\r\n            sign = coeffs[1].sign();\r\n            //divide the linear term by two and square it\r\n            b = _.divide(coeffs[1], new Symbol(2));\r\n            //add the difference to the constant\r\n            c = _.pow(b.clone(), new Symbol(2));\r\n            if(raw)\r\n                return [a, b, d];\r\n            sqrt_a = math.sqrt(a);\r\n            e = _.divide(math.sqrt(c), sqrt_a.clone());\r\n            //calculate d which is the constant\r\n            d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol(2)));\r\n            //compute the square part\r\n            sym = _.parse(br(sqrt_a.clone() + '*' + v + (sign < 0 ? '-' : '+') + e));\r\n            return {\r\n                a: sym,\r\n                c: d,\r\n                f: _.add(_.pow(sym.clone(), new Symbol(2)), d.clone())\r\n            };\r\n        },\r\n        Simplify: {\r\n            strip: function (symbol) {\r\n                var c = _.parse(symbol.multiplier);\r\n                symbol.toUnitMultiplier();\r\n                var p = _.parse(symbol.power);\r\n                symbol.toLinear();\r\n                return [c, p, symbol];\r\n            },\r\n            unstrip: function (cp, symbol) {\r\n                var c = cp[0];\r\n                var p = cp[1];\r\n                return _.multiply(c, _.pow(symbol, p));\r\n            },\r\n            complexSimp: function (num, den) {\r\n                var ac, bd, bc, ad, cd, r1, r2, i1, i2;\r\n                r1 = num.realpart();\r\n                i1 = num.imagpart();\r\n                r2 = den.realpart();\r\n                i2 = den.imagpart();\r\n                //apply complex arithmatic rule\r\n                ac = _.multiply(r1.clone(), r2.clone());\r\n                bd = _.multiply(i1.clone(), i2.clone());\r\n                bc = _.multiply(r2.clone(), i1);\r\n                ad = _.multiply(r1, i2.clone());\r\n                cd = _.add(_.pow(r2, new Symbol(2)), _.pow(i2, new Symbol(2)));\r\n\r\n                return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol.imaginary())), cd);\r\n            },\r\n            trigSimp: function (symbol) {\r\n                if(symbol.containsFunction(['cos', 'sin', 'tan'])) {\r\n                    symbol = symbol.clone();\r\n                    //remove power and multiplier\r\n                    var sym_array = __.Simplify.strip(symbol);\r\n                    symbol = sym_array.pop();\r\n                    //the default return value is the symbol\r\n                    var retval = symbol.clone();\r\n\r\n                    //rewrite the symbol\r\n                    if(symbol.group === CP) {\r\n                        var sym = new Symbol(0);\r\n                        symbol.each(function (x) {\r\n                            //rewrite the function\r\n                            var tr = __.Simplify.trigSimp(x.fnTransform());\r\n                            sym = _.add(sym, tr);\r\n                        }, true);\r\n\r\n                        //put back the power and multiplier and return\r\n                        retval = _.pow(_.multiply(new Symbol(symbol.multiplier), sym), new Symbol(symbol.power));\r\n                    }\r\n                    else if(symbol.group === CB) {\r\n\r\n                        var n = symbol.getNum();\r\n                        var d = symbol.getDenom();\r\n\r\n                        //try for tangent\r\n                        if(n.fname === 'sin' && d.fname === 'cos' && n.args[0].equals(d.args[0]) && n.power.equals(d.power)) {\r\n                            retval = _.parse(core.Utils.format('({0})*({1})*tan({2})^({3})', d.multiplier, n.multiplier, n.args[0], n.power));\r\n                        }\r\n                        if(retval.group === CB) {\r\n                            var t = new Symbol(1);\r\n                            retval.each(function (x) {\r\n                                if(x.fname === 'tan') {\r\n                                    x = _.parse(core.Utils.format('({0})*sin({1})^({2})/cos({1})^({2})', x.multiplier, __.Simplify.simplify(x.args[0]), x.power));\r\n                                }\r\n                                t = _.multiply(t, x);\r\n                            });\r\n                            retval = t;\r\n                        }\r\n                    }\r\n\r\n\r\n                    retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();\r\n\r\n                    symbol = retval;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            fracSimp: function (symbol) {\r\n                //try a quick simplify of imaginary numbers\r\n                var den = symbol.getDenom();\r\n                var num = symbol.getNum();\r\n\r\n                if(num.isImaginary() && den.isImaginary())\r\n                    symbol = __.Simplify.complexSimp(num, den);\r\n\r\n                if(symbol.isComposite()) {\r\n                    if(symbol.power > 1) {\r\n                        symbol = _.expand(symbol);\r\n                    }\r\n\r\n                    var symbols = symbol.collectSymbols();\r\n                    //assumption 1.\r\n                    //since it's a composite, it has a length of at least 1\r\n                    var retval, a, b, d1, d2, n1, n2, s, x, y, c, den, num;\r\n                    a = symbols.pop(); //grab the first symbol\r\n                    //loop through each term and make denominator common\r\n                    while(symbols.length) {\r\n                        b = symbols.pop(); //grab the second symbol\r\n                        d1 = _.parse(a.getDenom());\r\n                        d2 = _.parse(b.getDenom());\r\n                        n1 = a.getNum();\r\n                        n2 = b.getNum();\r\n                        c = _.multiply(d1.clone(), d2.clone());\r\n                        x = _.multiply(n1, d2);\r\n                        y = _.multiply(n2, d1);\r\n                        s = _.add(x, y);\r\n                        a = _.divide(s, c);\r\n                    }\r\n                    den = _.expand(a.getDenom());\r\n                    num = _.expand(a.getNum());\r\n                    //simplify imaginary\r\n                    if(num.isImaginary() && den.isImaginary()) {\r\n                        retval = __.Simplify.complexSimp(num, den);\r\n                    }\r\n                    else {\r\n                        retval = _.divide(num, den);\r\n                    }\r\n\r\n                    //we've already hit the simplest form so return that\r\n                    if(retval.equals(symbol)) {\r\n                        return symbol;\r\n                    }\r\n\r\n                    //otherwise simplify it some more\r\n                    return __.Simplify.simplify(retval);\r\n                }\r\n                return symbol;\r\n            },\r\n            ratSimp: function (symbol) {\r\n                if(symbol.group === CB) {\r\n                    var den = symbol.getDenom();\r\n                    var num = symbol.getNum().distributeMultiplier();\r\n                    var d = __.Simplify.fracSimp(den);\r\n                    var n = __.Simplify.fracSimp(num);\r\n                    symbol = _.divide(n, d);\r\n                }\r\n                return symbol;\r\n            },\r\n            sqrtSimp: function (symbol, sym_array) {\r\n                var retval;\r\n                if(symbol.isSQRT()) {\r\n                    var factored = __.Factor.factor(symbol.args[0].clone());\r\n                    var m = _.parse(factored.multiplier);\r\n                    var sign = m.sign();\r\n\r\n                    var retval = _.sqrt(m.abs());\r\n                    var arg;\r\n\r\n                    if(isInt(retval)) {\r\n\r\n                        if(factored.group === CB) {\r\n                            var rem = new Symbol(1);\r\n\r\n                            factored.each(function (x) {\r\n                                if(x.group === N) {\r\n                                    var trial = _.sqrt(x.clone());\r\n\r\n                                    // Multiply back sqrt if it's an integer otherwise just put back the number\r\n                                    if(isInt(trial)) {\r\n                                        retval = _.multiply(retval, trial);\r\n                                    }\r\n                                    else {\r\n                                        rem = _.multiply(rem, x);\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    rem = _.multiply(rem, x);\r\n                                }\r\n\r\n                            });\r\n                            var t = _.multiply(rem, _.parse(sign));\r\n                            arg = _.sqrt(t.clone());\r\n\r\n                            // Expand if it's imaginary\r\n                            if(arg.isImaginary) {\r\n                                arg = _.sqrt(_.expand(t.clone()));\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Strip the multiplier\r\n                            arg = _.sqrt(factored.clone().toUnitMultiplier());\r\n                        }\r\n                        return _.multiply(retval, arg);\r\n\r\n                    }\r\n\r\n                }\r\n                else if(symbol.isComposite() && symbol.isLinear()) {\r\n                    retval = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        retval = _.add(retval, __.Simplify.sqrtSimp(x));\r\n                    }, true);\r\n                    // Put back the multiplier\r\n                    retval = _.multiply(retval, _.parse(symbol.multiplier));\r\n                }\r\n                else if(symbol.group === CB) {\r\n                    retval = _.parse(symbol.multiplier);\r\n                    symbol.each(function (x) {\r\n                        var simp = __.Simplify.sqrtSimp(x);\r\n                        retval = _.multiply(retval, simp);\r\n\r\n                    }, true);\r\n                    // Put back the power\r\n                    retval = _.pow(retval, _.parse(symbol.power));\r\n                }\r\n\r\n                return retval ? retval : _.parse(symbol);\r\n            },\r\n            /**\r\n             * Unused. The goal is to substitute out patterns but it currently doesn't work.\r\n             * @param {Symbol} symbol\r\n             * @return {Array} The symbol and the matched patterns\r\n             */\r\n            patternSub: function (symbol) {\r\n                var patterns = {};\r\n\r\n                var has_CP = function (symbol) {\r\n                    var found = false;\r\n                    symbol.each(function (x) {\r\n                        if(x.group === CP) {\r\n                            found = true;\r\n                        }\r\n                        else if(x.symbols) {\r\n                            found = has_CP(x);\r\n                        }\r\n                    });\r\n\r\n                    return found;\r\n                };\r\n\r\n                var collect = function (sym) {\r\n                    // We loop through each symbol looking for anything in the simplest\r\n                    // form of ax+byz+...\r\n                    sym.each(function (x) {\r\n                        // Items of group N,P,S, need to apply\r\n                        if(!x.symbols && x.group !== FN) {\r\n                            return;\r\n                        }\r\n\r\n                        // Check to see if it has any symbols of group CP\r\n                        // Get the patterns in that symbol instead if it has anything of group CP\r\n                        if(has_CP(x)) {\r\n                            collect(x);\r\n                        }\r\n                        else {\r\n                            if(!patterns[x.value]) {\r\n                                var u = core.Utils.getU(symbol);\r\n                                // Get a u value and mark it for subsitution\r\n                                patterns[x.value] = u;\r\n                                symbol = symbol.sub(x.value, u);\r\n                            }\r\n                        }\r\n                    }, true);\r\n                };\r\n\r\n                // Collect a list of patterns\r\n                collect(symbol);\r\n\r\n                return [symbol, patterns];\r\n            },\r\n            simplify: function (symbol) {\r\n                //remove the multiplier to make calculation easier;\r\n                var sym_array = __.Simplify.strip(symbol);\r\n                symbol = sym_array.pop();\r\n                //remove gcd from denominator\r\n                symbol = __.Simplify.fracSimp(symbol);\r\n                //nothing more to do\r\n                if(symbol.isConstant() || symbol.group === core.groups.S) {\r\n                    sym_array.push(symbol);\r\n                    var ret = __.Simplify.unstrip(sym_array, symbol);\r\n                    return ret;\r\n                }\r\n\r\n                //var patterns;\r\n\r\n                var simplified = symbol.clone(); //make a copy\r\n\r\n                //[simplified, patterns] = __.Simplify.patternSub(symbol);\r\n\r\n                // Simplify sqrt within the symbol\r\n//                simplified = __.Simplify.sqrtSimp(simplified, sym_array);\r\n\r\n                // Try trig simplificatons e.g. cos(x)^2+sin(x)^2\r\n                simplified = __.Simplify.trigSimp(simplified);\r\n\r\n                // Simplify common denominators\r\n                simplified = __.Simplify.ratSimp(simplified);\r\n\r\n                // First go for the \"cheapest\" simplification which may eliminate \r\n                // your problems right away. factor -> evaluate. Remember\r\n                // that there's no need to expand since factor already does that\r\n\r\n                simplified = __.Factor.factor(simplified);\r\n\r\n                //If the simplfied is a sum then we can make a few more simplifications\r\n                //e.g. simplify(1/(x-1)+1/(1-x)) as per issue #431\r\n                if(simplified.group === core.groups.CP && simplified.isLinear()) {\r\n                    var m = simplified.multiplier.clone();\r\n                    simplified.toUnitMultiplier(); //strip the multiplier\r\n                    var r = new Symbol(0);\r\n                    //return the sum of simplifications\r\n                    simplified.each(function (x) {\r\n                        var s = __.Simplify.simplify(x);\r\n                        r = _.add(r, s);\r\n                    });\r\n                    simplified = r;\r\n                    //put back the multiplier\r\n                    r.multiplier = r.multiplier.multiply(m);\r\n                }\r\n\r\n                //place back multiplier and return\r\n                var retval = __.Simplify.unstrip(sym_array, simplified);\r\n\r\n                // Back substitute\r\n                /*\r\n                 for(var x in patterns) {\r\n                 retval = retval.sub(patterns[x], x);\r\n                 }\r\n                 */\r\n\r\n                return retval;\r\n            }\r\n        },\r\n\r\n        Classes: {\r\n            Polynomial: Polynomial,\r\n            Factors: Factors,\r\n            MVTerm: MVTerm\r\n        }\r\n    };\r\n\r\n    // Add a link to simplify\r\n    core.Expression.prototype.simplify = function () {\r\n        return __.Simplify.simplify(this.symbol);\r\n    };\r\n\r\n    nerdamer.useAlgebraDiv = function () {\r\n        var divide = __.divideFn = _.divide;\r\n        var calls = 0; //keep track of how many calls were made\r\n        _.divide = function (a, b) {\r\n            calls++;\r\n            var ans;\r\n            if(calls === 1) //check if this is the first call. If it is use algebra divide\r\n                ans = core.Algebra.divide(a, b);\r\n            else //otherwise use parser divide\r\n                ans = divide(a, b);\r\n            calls = 0; //reset the number of calls back to none\r\n            return ans;\r\n        };\r\n    };\r\n\r\n    nerdamer.useParserDiv = function () {\r\n        if(__.divideFn)\r\n            _.divide = __.divideFn;\r\n        delete __.divideFn;\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'factor',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Factor.factor;\r\n            }\r\n        },\r\n        {\r\n            name: 'simplify',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Simplify.simplify;\r\n            }\r\n        },\r\n        {\r\n            name: 'gcd',\r\n            visible: true,\r\n            numargs: [1, ],\r\n            build: function () {\r\n                return __.gcd;\r\n            }\r\n        },\r\n        {\r\n            name: 'lcm',\r\n            visible: true,\r\n            numargs: [1, ],\r\n            build: function () {\r\n                return __.lcm;\r\n            }\r\n        },\r\n        {\r\n            name: 'roots',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.roots;\r\n            }\r\n        },\r\n        {\r\n            name: 'divide',\r\n            visible: true,\r\n            numargs: 2,\r\n            build: function () {\r\n                return __.divide;\r\n            }\r\n        },\r\n        {\r\n            name: 'div',\r\n            visible: true,\r\n            numargs: 2,\r\n            build: function () {\r\n                return __.div;\r\n            }\r\n        },\r\n        {\r\n            name: 'partfrac',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.PartFrac.partfrac;\r\n            }\r\n        },\r\n        {\r\n            name: 'deg',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.degree;\r\n            }\r\n        },\r\n        {\r\n            name: 'coeffs',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                var f = function () {\r\n                    var coeffs = __.coeffs.apply(__, arguments);\r\n                    return new core.Vector(coeffs);\r\n                };\r\n                return f;\r\n            }\r\n        },\r\n        {\r\n            name: 'line',\r\n            visible: true,\r\n            numargs: [2, 3],\r\n            build: function () {\r\n                return __.line;\r\n            }\r\n        },\r\n        {\r\n            name: 'sqcomp',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                var f = function (x, v) {\r\n                    try {\r\n                        v = v || variables(x)[0];\r\n                        var sq = __.sqComplete(x.clone(), v);\r\n                        return sq.f;\r\n                    }\r\n                    catch(e) {\r\n                        return x;\r\n                    }\r\n                };\r\n                return f;\r\n            }\r\n        }\r\n    ]);\r\n    nerdamer.updateAPI();\r\n})();"],"names":["nerdamer","require","core","getCore","_","PARSER","Frac","Settings","isSymbol","Utils","FN","groups","Symbol","text","inBrackets","isInt","format","even","evaluate","N","S","PL","CP","CB","EX","P","LOG","ABS","SQRT","SIN","COS","TAN","SEC","CSC","COT","ASIN","ACOS","ATAN","ASEC","ACSC","ACOT","SINH","COSH","TANH","CSCH","SECH","COTH","ASECH","ACSCH","ACOTH","NoIntegralFound","msg","this","message","prototype","Error","hasIntegral","containsFunction","fnTransform","group","retval","a","args","m","multiplier","sym","clone","toUnitMultiplier","isLinear","fname","parse","power","equals","lessThan","negate","n","double_angle","pow","toLinear","transformed","expand","each","s","t","add","multiply","hasTrig","isConstant","in_trig","in_inverse_trig","symbols","x","Expression","symbol","toCommonDenominator","isComposite","denominator","numerator","getDenom","num","getNum","den","factor","divide","Algebra","indexOf","in_htrig","Matrix","jacobian","eqns","vars","arrayGetVariables","forEach","v","i","eq","j","e","Calculus","diff","set","max","abs","gt","cMatrix","value","all_functions","arr","l","length","cosAsinBtransform","cosAsinBtranform","symbol1","symbol2","b","cosAsinAtransform","cosAsinAtranform","Number","sinAsinBtransform","trigTransform","map","toString","integration_depth","max_lim_depth","__","version","sum","fn","index","start","end","exceptions","NerdamerTypeError","isNumericSymbol","modifier","block","f","subs","ans","symfunction","arguments","product","wrt","nth","isVector","vector","Vector","elements","push","isMatrix","matrix","d","undefined","variables","sp","derive","polydiff","contains","subtract","cp","g","collectSymbols","result","df","product_rule","qdiff","arg","String","x_","y_","LOG10","c","updateHash","val","altVal","integration","u_substitution","dx","try_combo","q","do_fn_sub","subbed","integrate","u","sub","Q","g1","g2","poly_integrate","p","dc","decompose_arg","xp","dc2","new_val","by_parts","integrated","A","Factor","B","f1","f2","toDecimal","stop","warn","partial_fraction","input","depth","opt","partial_fractions","PartFrac","partfrac","get_udv","parts","setSymbol","unwrapSQRT","dv","part","trig_sub","greaterThan","getU","du","integral","clearU","o","udv","vdu","uv","integral_vdu","vdu_s","previous","stripVar","isE","is_cyclic","pop","rem","decompose_fn","original_symbol","dt","isNaN","error","previousGroup","PARENTHESIS","aa","decomp","ax","b_is_positive","unwrapAbs","C","D","E","F","L1","L2","br","d2","sqrt_a","sqrt_ax","sqa","sqb","aob","bsqi","invert","Math","was_factored","degree","fx","sq","sqComplete","u_du","ag","decomposed","hasFunc","a_","b_","rd","rd2","na","r","w","n1","n2","parse_str","coeff","cfsymbol","isPoly","sort","unwrapped","sym1","sym2","fn1","fn2","arg1","arg2","new_sym","p1_even","p2_even","k","sign","trans","bx","sym1_is_linear","pd","min","apply","keys","pc","f_is_linear","p1","p2","dummy","bksub","u_transform","sqrt","expanded","y","U","scope","U2","factors","Classes","Factors","coeffFactor","div","cosn","X","sym2_clone","sa","sb","nq","syma","symb","first","intg","DivisionByZero","defint","from","to","get_value","point","Limit","limit","build","Math2","num_integrate","upper","lower","interval","diverges","lim","gin","lim_sign","isInfinity","fm","gm","L","lim1","lim2","indeterminate","ft","t_symbol","den_is_zero","infinity","rewriteToLog","getSubbed","isInterval","isConvergent","Simplify","simplify","_num","_den","isOne","symbol_","base","lim_base","lim_pow","evaluates","trial","s_arg","pi","divergent","FACTORIAL","_lim","_symbols","fns","unshift","Fresnel","register","name","visible","numargs","updateAPI","round","CONST_HASH","math","importFunctions","Polynomial","variable","order","InvalidVariableNameError","coeffs","fill","MVTerm","terms","image","fromArray","fit","c1","c2","Array","floor","absEquals","trim","equalsZero","modP","mod","up_one","next","poly","dividend","arrayClone","divisor","mp","quotient","l1","l2","x1","x2","isZero","deg","lc","monic","gcd","QGCD","new_array","gcf","toPolynomial","ca","fnz","parr","quad","incl_img","roots","dsc","squareFree","output","equalsNumber","z","toSymbol","str","plus","with_order","distributeMultiplier","isImaginary","imaginary","tBase","nterm","updateCount","altVar","sameVars","groupTerms","egrouped","grouped","el","collectFactors","getNumberSymbolics","fo","firstObject","obj","key","preAdd","pFactor","is_constant","factored","Object","values","unwrapPARENS","merge","call","count","clean","h","getVars","term","getRevMap","rev_map","join","len","mapped","generateImage","getImg","mvterm","new_mvterm","toMapObj","filledArray","clss","arrSum","haveIntersection","some","subFunctions","tvar","getFunctionsSubs","proots","decp","known_roots","get_roots","rarr","powers","calcroots","concat","lowest_pow","arrayMin","lowest_symbol","minpower","arrayMax","isArray","last_power","slice","ValueLimitExceededError","zeroi","degreePar","Degree","zeror","QuadSD_ak1","NN","iPar","calcSC_ak1","DBL_EPSILON","K","qk","sdPar","dumFlag","a3","a1","a7","nextK_ak1","tFlag","qp","temp","newest_ak1","a4","a5","b1","b2","c3","c4","Quad_ak1","sr","si","lr","li","QuadIT_ak1","uu","vv","calcPar","ee","omp","relstp","ui","vi","zm","qPar","triedFlag","NZ","szr","szi","lzr","lzi","RealIT_ak1","kv","ms","pv","nm1","Fxshfr_ak1","MDP1","betas","betav","oss","ots","otv","ovv","ss","ts","tss","tv","tvv","fflag","spass","stry","vpass","vtry","svk","iFlag","degPar","bnd","ff","moduli_max","moduli_min","sc","xm","bb","cc","xxx","jj","NM1","zerok","RADFAC","LB2","LN2","pt","Fxshfr_Par","LO","MIN_VALUE","cosr","cos","sinr","sin","xx","yy","MAX_VALUE","log","exp","rpSolve","img","real","replace","nroots","froot","guess","xn","Function","done","safety","newtonraph","sumProd","polyPowers","for_variable","arrayUnique","split","mix","include_negatives","ll","common","zeroes","exit","tp","allSame","n_terms","n_zeroes","_symbol","_factor","create","_factored","quadFactor","cf","root","filter","root1","root2","cubeFactor","sign_a","sign_b","isCube","m_root_a","getNth","m_root_b","isSimple","untouched","den_array","num_array","dfact","nfact","strip","unstrip","IMAGINARY","multiVar","all_S","all_unit","coeff_factors","power_factors","powerFactor","mfactor","t_factors","trialAndError","tf_symbol","t_factor","addPower","reduce","nn","sqfr","allNumeric","LT","factor_array","cnst","cfactors","ifactor","search","check","candidate","ltfactors","isubbed","nfactors","ceil","lc_is_neg","cnst_is_neg","factor_found","isPrime","mSqfrFactor","reverse","can_divide","is_factor","sqdiff","remove_square","separated","separate","obj_array","constants","powSimp","factors2","sorted","maxes","new_factor","divided","has_fractions","neg_numeric_factor","allLinear","status","sg","arguments2Array","appeared","splice","every","aggregate","gcd_","lcm","gcd_m","GCD","gcd_v","gcd_p","vars_a","vars_b","T","multipliers","denom","numer","prev","curr","denom_args","size","mask","results","total","isVariableSymbol","remainder","fail","symbol1_has_func","symbol2_has_func","parse_funcs","quot","reconvert","get_unique_max","any","idx","get_det","lookat","det","umax","is_equal","max1","max2","idx1","idx2","item1","item2","d1","s2","cterm","t_map","init_sort","is_larger","s1","target","lead_var","sf","blv","alv","checked","tt","try_better_lead_var","fdt","fnt","nd","dividend_larger","InfiniteLoopError","shift","neg","cur","remove","line","v1","v2","convertToVector","dy","createTemplate","denom_factors","f_array","factors_vec","degrees","efactor","as_array","ofactors","nterms","dterms","M","ks","template","tfactors","fillHoles","transpose","partials","denominators","e2","sd","distributeExponent","raw","complexSimp","ac","bd","bc","ad","cd","r1","r2","i1","i2","realpart","imagpart","trigSimp","sym_array","tr","fracSimp","ratSimp","sqrtSimp","isSQRT","simp","patternSub","patterns","has_CP","found","collect","simplified","useAlgebraDiv","divideFn","calls","useParserDiv"],"sourceRoot":""}