{"version":3,"file":"static/js/93.ceb3316c.chunk.js","mappings":"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","sources":["../node_modules/nerdamer/Solve.js"],"sourcesContent":["/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n/* global module */\r\n\r\nif((typeof module) !== 'undefined') {\r\n    var nerdamer = require('./nerdamer.core.js');\r\n    require('./Calculus.js');\r\n    require('./Algebra.js');\r\n}\r\n\r\n(function () {\r\n    //handle imports\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            _A = core.Algebra,\r\n            _C = core.Calculus,\r\n            explode = _C.integration.decompose_arg,\r\n            evaluate = core.Utils.evaluate,\r\n            remove = core.Utils.remove,\r\n            format = core.Utils.format,\r\n            build = core.Utils.build,\r\n            knownVariable = core.Utils.knownVariable,\r\n            Symbol = core.Symbol,\r\n            isSymbol = core.Utils.isSymbol,\r\n            variables = core.Utils.variables,\r\n            S = core.groups.S,\r\n            PL = core.groups.PL,\r\n            CB = core.groups.CB,\r\n            CP = core.groups.CP,\r\n            FN = core.groups.FN,\r\n            Settings = core.Settings,\r\n            range = core.Utils.range,\r\n            isArray = core.Utils.isArray;\r\n\r\n\r\n    // The search radius for the roots\r\n    core.Settings.SOLVE_RADIUS = 1000;\r\n    // The maximum number to fish for on each side of the zero\r\n    core.Settings.ROOTS_PER_SIDE = 10;\r\n    // Covert the number to multiples of pi if possible\r\n    core.Settings.make_pi_conversions = false;\r\n    // The step size\r\n    core.Settings.STEP_SIZE = 0.1;\r\n    // The epsilon size\r\n    core.Settings.EPSILON = 1e-13;\r\n    //the maximum iterations for Newton's method\r\n    core.Settings.MAX_NEWTON_ITERATIONS = 200;\r\n    //the maximum number of time non-linear solve tries another jump point\r\n    core.Settings.MAX_NON_LINEAR_TRIES = 12;\r\n    //the amount of iterations the function will start to jump at\r\n    core.Settings.NON_LINEAR_JUMP_AT = 50;\r\n    //the size of the jump\r\n    core.Settings.NON_LINEAR_JUMP_SIZE = 100;\r\n    //the original starting point for nonlinear solving\r\n    core.Settings.NON_LINEAR_START = 0.01;\r\n    //When points are generated as starting points for Newton's method, they are sliced into small\r\n    //slices to make sure that we have convergence on the right point. This defines the \r\n    //size of the slice\r\n    core.Settings.NEWTON_SLICES = 200;\r\n    //The epsilon used in Newton's iteration\r\n    core.Settings.NEWTON_EPSILON = Number.EPSILON * 2;\r\n    //The distance in which two solutions are deemed the same\r\n    core.Settings.SOLUTION_PROXIMITY = 1e-14;\r\n    //Indicate wheter to filter the solutions are not\r\n    core.Settings.FILTER_SOLUTIONS = true;\r\n    //the maximum number of recursive calls\r\n    core.Settings.MAX_SOLVE_DEPTH = 10;\r\n    // The tolerance that's considered close enough to zero\r\n    core.Settings.ZERO_EPSILON = 1e-9;\r\n    // The maximum iteration for the bisection method incase of some JS strangeness\r\n    core.Settings.MAX_BISECTION_ITER = 2000;\r\n    // The tolerance for the bisection method\r\n    core.Settings.BI_SECTION_EPSILON = 1e-12;\r\n\r\n\r\n    core.Symbol.prototype.hasTrig = function () {\r\n        return this.containsFunction(['cos', 'sin', 'tan', 'cot', 'csc', 'sec']);\r\n    };\r\n\r\n    core.Symbol.prototype.hasNegativeTerms = function () {\r\n        if(this.isComposite()) {\r\n            for(var x in this.symbols) {\r\n                var sym = this.symbols[x];\r\n                if(sym.group === PL && sym.hasNegativeTerms() || this.symbols[x].power.lessThan(0))\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n    /* nerdamer version 0.7.x and up allows us to make better use of operator overloading\r\n     * As such we can have this data type be supported completely outside of the core.\r\n     * This is an equation that has a left hand side and a right hand side\r\n     */\r\n    function Equation(lhs, rhs) {\r\n        if(rhs.isConstant() && lhs.isConstant() && !lhs.equals(rhs) || lhs.equals(core.Settings.IMAGINARY) && rhs.isConstant(true) || rhs.equals(core.Settings.IMAGINARY) && lhs.isConstant(true))\r\n            throw new core.exceptions.NerdamerValueError(lhs.toString() + ' does not equal ' + rhs.toString());\r\n        this.LHS = lhs; //left hand side\r\n        this.RHS = rhs; //right and side\r\n    }\r\n    ;\r\n\r\n    //UTILS ##!!\r\n\r\n    Equation.prototype = {\r\n        toString: function () {\r\n            return this.LHS.toString() + '=' + this.RHS.toString();\r\n        },\r\n        text: function (option) {\r\n            return this.LHS.text(option) + '=' + this.RHS.text(option);\r\n        },\r\n        toLHS: function (expand) {\r\n            expand = typeof expand === 'undefined' ? true : false;\r\n            var eqn;\r\n            if(!expand) {\r\n                eqn = this.clone();\r\n            }\r\n            else {\r\n                eqn = this.removeDenom();\r\n            }\r\n            var a = eqn.LHS;\r\n            var b = eqn.RHS;\r\n            \r\n            if(a.isConstant(true) && !b.isConstant(true)) {\r\n                // Swap them to avoid confusing parser and cause an infinite loop\r\n                [a, b] = [b, a];\r\n            }\r\n            var _t = _.subtract(a, b);\r\n            var retval = expand ? _.expand(_t) : _t;\r\n            \r\n            // Quick workaround for issue #636\r\n            // This basically borrows the removeDenom method from the Equation class. \r\n            // TODO: Make this function a stand-alone function\r\n            retval = new Equation(retval, new Symbol(0)).removeDenom().LHS;\r\n            \r\n            return retval;\r\n        },\r\n        removeDenom: function () {\r\n            var a = this.LHS.clone();\r\n            var b = this.RHS.clone();\r\n            //remove the denominator on both sides\r\n            var den = _.multiply(a.getDenom(), b.getDenom());\r\n            a = _.expand(_.multiply(a, den.clone()));\r\n            b = _.expand(_.multiply(b, den));\r\n            //swap the groups\r\n            if(b.group === CP && b.group !== CP) {\r\n                var t = a;\r\n                a = b;\r\n                b = t; //swap\r\n            }\r\n\r\n            //scan to eliminate denominators\r\n            if(a.group === CB) {\r\n                var t = new Symbol(a.multiplier),\r\n                        newRHS = b.clone();\r\n                a.each(function (y) {\r\n                    if(y.power.lessThan(0))\r\n                        newRHS = _.divide(newRHS, y);\r\n                    else\r\n                        t = _.multiply(t, y);\r\n                });\r\n                a = t;\r\n                b = newRHS;\r\n\r\n            }\r\n            else if(a.group === CP) {\r\n                //the logic: loop through each and if it has a denominator then multiply it out on both ends\r\n                //and then start over\r\n                for(var x in a.symbols) {\r\n                    var sym = a.symbols[x];\r\n                    if(sym.group === CB) {\r\n                        for(var y in sym.symbols) {\r\n                            var sym2 = sym.symbols[y];\r\n                            if(sym2.power.lessThan(0)) {\r\n                                return new Equation(\r\n                                        _.expand(_.multiply(sym2.clone().toLinear(), a)),\r\n                                        _.expand(_.multiply(sym2.clone().toLinear(), b))\r\n                                        );\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return new Equation(a, b);\r\n        },\r\n        clone: function () {\r\n            return new Equation(this.LHS.clone(), this.RHS.clone());\r\n        },\r\n        sub: function (x, y) {\r\n            var clone = this.clone();\r\n            clone.LHS = clone.LHS.sub(x.clone(), y.clone());\r\n            clone.RHS = clone.RHS.sub(x.clone(), y.clone());\r\n            return clone;\r\n        },\r\n        isZero: function () {\r\n            return core.Utils.evaluate(this.toLHS()).equals(0);\r\n        },\r\n        latex: function (option) {\r\n            return [this.LHS.latex(option), this.RHS.latex(option)].join('=');\r\n        }\r\n    };\r\n    //overwrite the equals function\r\n    _.equals = function (a, b) {\r\n        return new Equation(a, b);\r\n    };\r\n\r\n    // Extend simplify\r\n    (function () {\r\n        var simplify = _.functions.simplify[0];\r\n        _.functions.simplify[0] = function (symbol) {\r\n            if(symbol instanceof Equation) {\r\n                symbol.LHS = simplify(symbol.LHS);\r\n                symbol.RHS = simplify(symbol.RHS);\r\n                return symbol;\r\n            }\r\n            // Just call the original simplify\r\n            return simplify(symbol);\r\n        };\r\n    })();\r\n\r\n    /**\r\n     * Sets two expressions equal\r\n     * @param {Symbol} symbol\r\n     * @returns {Expression}\r\n     */\r\n    core.Expression.prototype.equals = function (symbol) {\r\n        if(symbol instanceof core.Expression)\r\n            symbol = symbol.symbol; //grab the symbol if it's an expression\r\n        var eq = new Equation(this.symbol, symbol);\r\n        return eq;\r\n    };\r\n\r\n    core.Expression.prototype.solveFor = function (x) {\r\n        var symbol;\r\n        if(this.symbol instanceof Equation) {\r\n            //exit right away if we already have the answer\r\n            //check the LHS\r\n            if(this.symbol.LHS.isConstant() && this.symbol.RHS.equals(x))\r\n                return new core.Expression(this.symbol.LHS);\r\n\r\n            //check the RHS\r\n            if(this.symbol.RHS.isConstant() && this.symbol.LHS.equals(x))\r\n                return new core.Expression(this.symbol.RHS);\r\n\r\n            //otherwise just bring it to LHS\r\n            symbol = this.symbol.toLHS();\r\n        }\r\n        else {\r\n            symbol = this.symbol;\r\n        }\r\n\r\n        return solve(symbol, x).map(function (x) {\r\n            return new core.Expression(x);\r\n        });\r\n    };\r\n\r\n    core.Expression.prototype.expand = function () {\r\n        if(this.symbol instanceof Equation) {\r\n            var clone = this.symbol.clone();\r\n            clone.RHS = _.expand(clone.RHS);\r\n            clone.LHS = _.expand(clone.LHS);\r\n            return new core.Expression(clone);\r\n        }\r\n        return new core.Expression(_.expand(this.symbol));\r\n    };\r\n\r\n    core.Expression.prototype.variables = function () {\r\n        if(this.symbol instanceof Equation)\r\n            return core.Utils.arrayUnique(variables(this.symbol.LHS).concat(variables(this.symbol.RHS)));\r\n        return variables(this.symbol);\r\n    };\r\n\r\n\r\n\r\n    var setEq = function (a, b) {\r\n        return _.equals(a, b);\r\n    };\r\n\r\n    //link the Equation class back to the core\r\n    core.Equation = Equation;\r\n\r\n    //Loops through an array and attempts to fails a test. Stops if manages to fail.\r\n    var checkAll = core.Utils.checkAll = function (args, test) {\r\n        for(var i = 0; i < args.length; i++)\r\n            if(test(args[i]))\r\n                return false;\r\n        return true;\r\n    };\r\n\r\n    //version solve\r\n    var __ = core.Solve = {\r\n        version: '2.0.3',\r\n        solutions: [],\r\n        solve: function (eq, variable) {\r\n            var solution = solve(eq, String(variable));\r\n            return new core.Vector(solution);\r\n            //return new core.Vector(solve(eq.toString(), variable ? variable.toString() : variable));\r\n        },\r\n        /**\r\n         * Brings the equation to LHS. A string can be supplied which will be converted to an Equation\r\n         * @param {Equation|String} eqn\r\n         * @returns {Symbol}\r\n         */\r\n        toLHS: function (eqn, expand) {\r\n            if(isSymbol(eqn))\r\n                return eqn;\r\n            //If it's an equation then call its toLHS function instead\r\n            if(!(eqn instanceof Equation)) {\r\n                var es = eqn.split('=');\r\n                //convert falsey values to zero\r\n                es[1] = es[1] || '0';\r\n                eqn = new Equation(_.parse(es[0]), _.parse(es[1]));\r\n            }\r\n            return eqn.toLHS(expand);\r\n        },\r\n//        getSystemVariables: function(eqns) {\r\n//            vars = variables(eqns[0], null, null, true);\r\n//\r\n//            //get all variables\r\n//            for (var i = 1, l=eqns.length; i < l; i++)\r\n//                vars = vars.concat(variables(eqns[i]));\r\n//            //remove duplicates\r\n//            vars = core.Utils.arrayUnique(vars).sort();\r\n//            \r\n//            //done\r\n//            return vars;\r\n//        },\r\n        /**\r\n         * Solve a set of circle equations. \r\n         * @param {Symbol[]} eqns\r\n         * @returns {Array}\r\n         */\r\n        solveCircle: function (eqns, vars) {\r\n            // Convert the variables to symbols\r\n            var svars = vars.map(function (x) {\r\n                return _.parse(x)\r\n            });\r\n\r\n            var deg = [];\r\n\r\n            var solutions = [];\r\n\r\n            // Get the degree for the equations\r\n            for(var i = 0; i < eqns.length; i++) {\r\n                var d = [];\r\n                for(var j = 0; j < svars.length; j++) {\r\n                    d.push(Number(core.Algebra.degree(eqns[i], svars[j])));\r\n                }\r\n                // Store the total degree\r\n                d.push(core.Utils.arraySum(d, true));\r\n                deg.push(d);\r\n            }\r\n\r\n            var a = eqns[0];\r\n            var b = eqns[1];\r\n\r\n            if(deg[0][2] > deg[1][2]) {\r\n                [b, a] = [a, b];\r\n                [deg[1], deg[0]] = [deg[0], deg[1]];\r\n            }\r\n\r\n            // Only solve it's truly a circle\r\n            if(deg[0][0] === 1 && deg[0][2] === 2 && deg[1][0] === 2 && deg[1][2] === 4) {\r\n                // For clarity we'll refer to the variables as x and y\r\n                var x = vars[0];\r\n                var y = vars[1];\r\n\r\n                // We can now get the two points for y\r\n                var y_points = solve(_.parse(b, knownVariable(x, solve(_.parse(a), x)[0])), y).map(function (x) {\r\n                    return x.toString();\r\n                });\r\n\r\n                // Since we now know y we can get the two x points from the first equation\r\n                var x_points = [\r\n                    solve(_.parse(a, knownVariable(y, y_points[0])))[0].toString()\r\n                ];\r\n\r\n                if(y_points[1]) {\r\n                    x_points.push(solve(_.parse(a, knownVariable(y, y_points[1])))[0].toString());\r\n                }\r\n\r\n                if(Settings.SOLUTIONS_AS_OBJECT) {\r\n                    var solutions = {};\r\n                    solutions[x] = x_points;\r\n                    solutions[y] = y_points;\r\n                }\r\n                else {\r\n                    y_points.unshift(y);\r\n                    x_points.unshift(x);\r\n                    solutions = [x_points, y_points];\r\n                }\r\n            }\r\n\r\n            return solutions;\r\n        },\r\n        /**\r\n         * Solve a system of nonlinear equations\r\n         * @param {Symbol[]} eqns The array of equations\r\n         * @param {number} tries The maximum number of tries\r\n         * @param {number} start The starting point where to start looking for solutions\r\n         * @returns {Array}\r\n         */\r\n        solveNonLinearSystem: function (eqns, tries, start) {\r\n            if(tries < 0) {\r\n                return [];//can't find a solution\r\n            }\r\n\r\n            start = typeof start === 'undefined' ? core.Settings.NON_LINEAR_START : start;\r\n\r\n            //the maximum number of times to jump\r\n            var max_tries = core.Settings.MAX_NON_LINEAR_TRIES;\r\n\r\n            //halfway through the tries\r\n            var halfway = Math.floor(max_tries / 2);\r\n\r\n            //initialize the number of tries to 10 if not specified\r\n            tries = typeof tries === 'undefined' ? max_tries : tries;\r\n\r\n            //a point at which we check to see if we're converging. By inspection it seems that we can\r\n            //use around 20 iterations to see if we're converging. If not then we retry a jump of x\r\n            var jump_at = core.Settings.NON_LINEAR_JUMP_AT;\r\n\r\n            //we jump by this many points at each pivot point\r\n            var jump = core.Settings.NON_LINEAR_JUMP_SIZE;\r\n\r\n            //used to check if we actually found a solution or if we gave up. Assume we will find a solution.\r\n            var found = true;\r\n\r\n            var create_subs = function (vars, matrix) {\r\n                return vars.map(function (x, i) {\r\n                    return Number(matrix.get(i, 0));\r\n                });\r\n            };\r\n\r\n            var vars = core.Utils.arrayGetVariables(eqns);\r\n            var jacobian = core.Matrix.jacobian(eqns, vars, function (x) {\r\n                return build(x, vars);\r\n            }, true);\r\n\r\n            var max_iter = core.Settings.MAX_NEWTON_ITERATIONS;\r\n            var o, y, iters, xn1, norm, lnorm, xn, d;\r\n\r\n            var f_eqns = eqns.map(function (eq) {\r\n                return build(eq, vars);\r\n            });\r\n\r\n            var J = jacobian.map(function (e) {\r\n                return build(e, vars);\r\n            }, true);\r\n            //initial values\r\n            xn1 = core.Matrix.cMatrix(0, vars);\r\n\r\n            //initialize the c matrix with something close to 0. \r\n            var c = core.Matrix.cMatrix(start, vars);\r\n\r\n            iters = 0;\r\n\r\n            //start of algorithm\r\n            do {\r\n                //if we've reached the max iterations then exit\r\n                if(iters > max_iter) {\r\n                    break;\r\n                    found = false;\r\n                }\r\n\r\n                //set the substitution object\r\n                o = create_subs(vars, c);\r\n\r\n                //set xn\r\n                xn = c.clone();\r\n\r\n                //make all the substitutions for each of the equations\r\n                f_eqns.forEach(function (f, i) {\r\n                    c.set(i, 0, f.apply(null, o));\r\n                });\r\n\r\n                var m = new core.Matrix();\r\n                J.each(function (fn, i, j) {\r\n                    var ans = fn.apply(null, o);\r\n                    m.set(i, j, ans);\r\n                });\r\n\r\n                m = m.invert();\r\n\r\n                //preform the elimination\r\n                y = _.multiply(m, c).negate();\r\n\r\n                //the callback is to avoid overflow in the coeffient denonimator\r\n                //it converts it to a decimal and then back to a fraction. Some precision\r\n                //is lost be it's better than overflow. \r\n                d = y.subtract(xn1, function (x) {\r\n                    return _.parse(Number(x));\r\n                });\r\n\r\n                xn1 = xn.add(y, function (x) {\r\n                    return _.parse(Number(x));\r\n                });\r\n\r\n                //move c is now xn1\r\n                c = xn1;\r\n\r\n                //get the norm\r\n\r\n                //the expectation is that we're converging to some answer as this point regardless of where we start\r\n                //this may have to be adjusted at some point because of erroneous assumptions\r\n                if(iters >= jump_at) {\r\n                    //check the norm. If the norm is greater than one then it's time to try another point\r\n                    if(norm > 1) {\r\n                        //reset the start point at halway\r\n                        if(tries === halfway)\r\n                            start = 0;\r\n                        var sign = tries > halfway ? 1 : -1; //which side are we incrementing\r\n                        //we increment +n at one side and -n at the other. \r\n                        n = (tries % Math.floor(halfway)) + 1;\r\n                        //adjust the start point\r\n                        start += (sign * n * jump);\r\n                        //call restart\r\n                        return __.solveNonLinearSystem(eqns, --tries, start);\r\n                    }\r\n                }\r\n                lnorm = norm;\r\n                iters++;\r\n                norm = d.max();\r\n\r\n                //exit early. Revisit if we get bugs\r\n                if(Number(norm) === Number(lnorm)) {\r\n                    break;\r\n                }\r\n            }\r\n            while(Number(norm) >= Number.EPSILON)\r\n\r\n            //return a blank set if nothing was found;\r\n            if(!found)\r\n                return [];\r\n\r\n            //return c since that's the answer\r\n            return __.systemSolutions(c, vars, true, function (x) {\r\n                return core.Utils.round(Number(x), 14);\r\n            });\r\n        },\r\n        systemSolutions: function (result, vars, expand_result, callback) {\r\n            var solutions = core.Settings.SOLUTIONS_AS_OBJECT ? {} : [];\r\n\r\n            result.each(function (e, idx) {\r\n                var solution = (expand_result ? _.expand(e) : e).valueOf();\r\n                if(callback)\r\n                    solution = callback.call(e, solution);\r\n                var variable = vars[idx];\r\n                if(core.Settings.SOLUTIONS_AS_OBJECT) {\r\n                    solutions[variable] = solution;\r\n                }\r\n                else\r\n                    solutions.push([variable, solution]); /*NO*/\r\n            });\r\n            //done\r\n            return solutions;\r\n        },\r\n        /**\r\n         * Solves a system of equations by substitution. This is useful when\r\n         * no distinct solution exists. e.g. a line, plane, etc.\r\n         * @param {Array} eqns\r\n         * @returns {Array}\r\n         */\r\n        solveSystemBySubstitution: function (eqns) {\r\n            // Assume at least 2 equations. The function variables will just return an empty array if undefined is provided\r\n            var vars_a = variables(eqns[0]);\r\n            var vars_b = variables(eqns[1]);\r\n            // Check if it's a circle equation\r\n            if(eqns.length === 2 && vars_a.length === 2 && core.Utils.arrayEqual(vars_a, vars_b)) {\r\n                return __.solveCircle(eqns, vars_a);\r\n            }\r\n\r\n            return []; // return an empty set\r\n        },\r\n\r\n        //https://www.lakeheadu.ca/sites/default/files/uploads/77/docs/RemaniFinal.pdf\r\n        /**\r\n         * Solves a systems of equations\r\n         * @param {Array} eqns An array of equations\r\n         * @param {Array} var_array An array of variables\r\n         * @returns {Array|object}\r\n         */\r\n        solveSystem: function (eqns, var_array) {\r\n            //check if a var_array was specified\r\n            //nerdamer.clearVars();// this deleted ALL variables: not what we want\r\n            //parse all the equations to LHS. Remember that they come in as strings\r\n            for(var i = 0; i < eqns.length; i++)\r\n                eqns[i] = __.toLHS(eqns[i]);\r\n\r\n            var l = eqns.length,\r\n                    m = new core.Matrix(),\r\n                    c = new core.Matrix(),\r\n                    expand_result = false,\r\n                    vars;\r\n\r\n            if(typeof var_array === 'undefined') {\r\n                //check to make sure that all the equations are linear\r\n                if(!_A.allLinear(eqns)) {\r\n                    try {\r\n                        return __.solveNonLinearSystem(eqns);\r\n                    }\r\n                    catch(e) {\r\n                        if(e instanceof core.exceptions.DivisionByZero) {\r\n                            return __.solveSystemBySubstitution(eqns);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                vars = core.Utils.arrayGetVariables(eqns);\r\n                \r\n                // If the system only has one variable then we solve for the first one and \r\n                // then test the remaining equations with that solution. If any of the remaining\r\n                // equation fails then the system has no solution\r\n                if(vars.length === 1) {\r\n                    var n = 0,\r\n                        sol, e;\r\n                    do {\r\n                        var e = eqns[n].clone();\r\n                        \r\n                        if(n > 0) {\r\n                            e = e.sub(vars[0], sol[0]);\r\n                        }\r\n\r\n                        sol = solve(e, vars[0]);\r\n                        // Skip the first one\r\n                        if(n === 0) \r\n                            continue;\r\n                    }\r\n                    while(++n < eqns.length)\r\n                        \r\n                    // Format the output\r\n                    var solutions;\r\n                    if(Settings.SOLUTIONS_AS_OBJECT) {\r\n                        solutions = {};\r\n                        solutions[vars[0]] = sol;\r\n                    }\r\n                    else if(sol.length === 0) {\r\n                        solutions = sol; // No solutions\r\n                    }\r\n                    else {\r\n                        solutions = [vars[0], sol];\r\n                    }\r\n                        \r\n                    return solutions;\r\n                }\r\n                \r\n                // Deal with redundant equations as expressed in #562\r\n                // The fix is to remove all but the number of equations equal to the number\r\n                // of variables. We then solve those and then evaluate the remaining equations\r\n                // with those solutions. If the all equal true then those are just redundant\r\n                // equations and we can return the solution set.\r\n                if(vars.length < eqns.length) {\r\n                    var reduced = [];\r\n                    var n = eqns.length;\r\n                    for(var i = 0; i < n - 1; i++) {\r\n                        reduced.push(_.parse(eqns[i]));\r\n                    }\r\n\r\n                    var knowns = {};\r\n                    var solutions = __.solveSystem(reduced, vars);\r\n                    // The solutions may have come back as an array\r\n                    if(Array.isArray(solutions)) {\r\n                        solutions.forEach(function (sol) {\r\n                            knowns[sol[0]] = sol[1];\r\n                        });\r\n                    }\r\n                    else {\r\n                        knowns = solutions;\r\n                    }\r\n\r\n                    // Start by assuming they will all evaluate to zero. If even one fails\r\n                    // then all zero will be false\r\n                    var all_zero = true;\r\n                    // Check if the last solution evalutes to zero given these solutions\r\n                    for(var i = n - 1; i < n; i++) {\r\n                        if(!_.parse(eqns[i], knowns).equals(0)) {\r\n                            all_zero = false;\r\n                        }\r\n                    }\r\n\r\n                    if(all_zero) {\r\n                        return solutions;\r\n                    }\r\n                }\r\n\r\n                // deletes only the variables of the linear equations in the nerdamer namespace\r\n                for(var i = 0; i < vars.length; i++) {\r\n                    nerdamer.setVar(vars[i], \"delete\");\r\n                }\r\n                // TODO: move this to cMatrix or something similar\r\n                // populate the matrix\r\n                for(var i = 0; i < l; i++) {\r\n                    var e = eqns[i]; //store the expression\r\n                    // Iterate over the columns\r\n                    for(var j = 0; j < vars.length; j++) {\r\n                        var v = vars[j];\r\n                        var coeffs = [];\r\n                        e.each(function (x) {\r\n                            if(x.contains(v)) {\r\n                                coeffs = coeffs.concat(x.coeffs());\r\n                            }\r\n                        });\r\n\r\n                        var cf = core.Utils.arraySum(coeffs);\r\n                        m.set(i, j, cf);\r\n                    }\r\n\r\n                    //strip the variables from the symbol so we're left with only the zeroth coefficient\r\n                    //start with the symbol and remove each variable and its coefficient\r\n                    var num = e.clone();\r\n                    vars.map(function (e) {\r\n                        num = num.stripVar(e, true);\r\n                    });\r\n                    c.set(i, 0, num.negate());\r\n                }\r\n            }\r\n            else {\r\n                /**\r\n                 * The idea is that we loop through each equation and then expand it. Afterwards we loop\r\n                 * through each term and see if and check to see if it matches one of the variables.\r\n                 * When a match is found we mark it. No other match should be found for that term. If it\r\n                 * is we stop since it's not linear.\r\n                 */\r\n                vars = var_array;\r\n                expand_result = true;\r\n                for(i = 0; i < l; i++) {\r\n                    //prefill\r\n                    c.set(i, 0, new Symbol(0));\r\n                    var e = _.expand(eqns[i]).collectSymbols(); //expand and store\r\n                    //go trough each of the variables\r\n                    for(var j = 0; j < var_array.length; j++) {\r\n                        m.set(i, j, new Symbol(0));\r\n                        var v = var_array[j];\r\n                        //go through the terms and sort the variables\r\n                        for(var k = 0; k < e.length; k++) {\r\n                            var term = e[k],\r\n                                    check = false;\r\n                            for(var z = 0; z < var_array.length; z++) {\r\n                                //check to see if terms contain multiple variables\r\n                                if(term.contains(var_array[z])) {\r\n                                    if(check)\r\n                                        core.err('Multiple variables found for term ' + term);\r\n                                    check = true;\r\n                                }\r\n                            }\r\n                            //we made sure that every term contains one variable so it's safe to assume that if the\r\n                            //variable is found then the remainder is the coefficient.\r\n                            if(term.contains(v)) {\r\n                                var tparts = explode(remove(e, k), v);\r\n                                m.set(i, j, _.add(m.get(i, j), tparts[0]));\r\n                            }\r\n                        }\r\n                    }\r\n                    //all the remaining terms go to the c matrix\r\n                    for(k = 0; k < e.length; k++) {\r\n                        c.set(i, 0, _.add(c.get(i, 0), e[k]));\r\n                    }\r\n                }\r\n                //consider case (a+b)*I+u\r\n            }\r\n\r\n            //check if the system has a distinct solution\r\n            if(vars.length !== eqns.length || m.determinant().equals(0)) {\r\n                // solve the system by hand\r\n                //return __.solveSystemBySubstitution(eqns, vars, m, c);\r\n                throw new core.exceptions.SolveError('System does not have a distinct solution');\r\n            }\r\n\r\n            // Use M^-1*c to solve system\r\n            m = m.invert();\r\n            var result = m.multiply(c);\r\n            //correct the sign as per issue #410\r\n            if(core.Utils.isArray(var_array))\r\n                result.each(function (x) {\r\n                    return x.negate();\r\n                });\r\n\r\n            return __.systemSolutions(result, vars, expand_result);\r\n        },\r\n        /**\r\n         * The quadratic function but only one side.\r\n         * @param {Symbol} c\r\n         * @param {Symbol} b\r\n         * @param {Symbol} a\r\n         * @returns {Symbol}\r\n         */\r\n        quad: function (c, b, a) {\r\n            var discriminant = _.subtract(_.pow(b.clone(), Symbol(2)), _.multiply(_.multiply(a.clone(), c.clone()), Symbol(4)))/*b^2 - 4ac*/;\r\n            // Fix for #608\r\n            discriminant = _.expand(discriminant);\r\n            var det = _.pow(discriminant, Symbol(0.5));\r\n            var den = _.parse(_.multiply(new Symbol(2), a.clone()));\r\n            var retval = [\r\n                _.parse(format('(-({0})+({1}))/({2})', b, det, den)),\r\n                _.parse(format('(-({0})-({1}))/({2})', b, det, den))\r\n            ];\r\n\r\n            return retval;\r\n        },\r\n        /**\r\n         * The cubic equation\r\n         * http://math.stackexchange.com/questions/61725/is-there-a-systematic-way-of-solving-cubic-equations\r\n         * @param {Symbol} d_o\r\n         * @param {Symbol} c_o\r\n         * @param {Symbol} b_o\r\n         * @param {Symbol} a_o\r\n         * @returns {Array}\r\n         */\r\n        cubic: function (d_o, c_o, b_o, a_o) {\r\n            //convert everything to text\r\n            var a = a_o.text(), b = b_o.text(), c = c_o.text(), d = d_o.text();\r\n\r\n            var t = `(-(${b})^3/(27*(${a})^3)+(${b})*(${c})/(6*(${a})^2)-(${d})/(2*(${a})))`;\r\n            var u = `((${c})/(3*(${a}))-(${b})^2/(9*(${a})^2))`;\r\n            var v = `(${b})/(3*(${a}))`;\r\n            var x = `((${t})+sqrt((${t})^2+(${u})^3))^(1/3)+((${t})-sqrt((${t})^2+(${u})^3))^(1/3)-(${v})`;\r\n\r\n            // Convert a to one\r\n            var w = '1/2+sqrt(3)/2*i'; // Cube root of unity\r\n\r\n            return [\r\n                _.parse(x),\r\n                _.parse(`(${x})(${w})`),\r\n                _.parse(`(${x})(${w})^2`)\r\n            ];\r\n        },\r\n        /**\r\n         * The quartic equation\r\n         * @param {Symbol} e\r\n         * @param {Symbol} d\r\n         * @param {Symbol} c\r\n         * @param {Symbol} b\r\n         * @param {Symbol} a\r\n         * @returns {Array}\r\n         */\r\n        quartic: function (e, d, c, b, a) {\r\n            var scope = {};\r\n            core.Utils.arrayUnique(variables(a).concat(variables(b))\r\n                    .concat(variables(c)).concat(variables(d)).concat(variables(e)))\r\n                    .map(function (x) {\r\n                        scope[x] = 1;\r\n                    });\r\n            a = a.toString();\r\n            b = b.toString();\r\n            c = c.toString();\r\n            d = d.toString();\r\n            e = e.toString();\r\n            var p, q, D, D0, D1, Q, x1, x2, x3, x4;\r\n            /*var D = core.Utils.block('PARSE2NUMBER', function() {\r\n             return _.parse(format(\"256*({0})^3*({4})^3-192*({0})^2*({1})*({3})*({4})^2-128*({0})^2*({2})^2*({4})^2+144*({0})^2*({2})*({3})^2*({4})\"+\r\n             \"-27*({0})^2*({3})^4+144*({0})*({1})^2*({2})*({4})^2-6*({0})*({1})^2*({3})^2*({4})-80*({0})*({1})*({2})^2*({3})*({4})+18*({0})*({1})*({2})*({3})^3\"+\r\n             \"+16*({0})*({2})^4*({4})-4*({0})*({2})^3*({3})^2-27*({1})^4*({4})^2+18*({1})^3*({2})*({3})*({4})-4*({1})^3*({3})^3-4*({1})^2*({2})^3*({4})+({1})^2*({2})^2*({3})^2\", \r\n             a, b, c, d, e), scope);\r\n             });*/\r\n\r\n            p = _.parse(format(\"(8*({0})*({2})-3*({1})^2)/(8*({0})^2)\", a, b, c)).toString(); //a, b, c\r\n            q = _.parse(format(\"(({1})^3-4*({0})*({1})*({2})+8*({0})^2*({3}))/(8*({0})^3)\", a, b, c, d)).toString();//a, b, c, d, e\r\n            D0 = _.parse(format(\"12*({0})*({4})-3*({1})*({3})+({2})^2\", a, b, c, d, e)).toString(); //a, b, c, d, e\r\n            D1 = _.parse(format(\"2*({2})^3-9*({1})*({2})*({3})+27*({1})^2*({4})+27*({0})*({3})^2-72*({0})*({2})*({4})\", a, b, c, d, e)).toString(); //a, b, c, d, e\r\n            Q = _.parse(format(\"((({1})+(({1})^2-4*({0})^3)^(1/2))/2)^(1/3)\", D0, D1)).toString(); //D0, D1\r\n            S = _.parse(format(\"(1/2)*(-(2/3)*({1})+(1/(3*({0}))*(({2})+(({3})/({2})))))^(1/2)\", a, p, Q, D0)).toString(); //a, p, Q, D0\r\n            x1 = _.parse(format(\"-(({1})/(4*({0})))-({4})+(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x2 = _.parse(format(\"-(({1})/(4*({0})))-({4})-(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x3 = _.parse(format(\"-(({1})/(4*({0})))+({4})+(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x4 = _.parse(format(\"-(({1})/(4*({0})))+({4})-(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            return [x1, x2, x3, x4];\r\n        },\r\n        /**\r\n         * Breaks the equation up in its factors and tries to solve the smaller parts\r\n         * @param {Symbol} symbol\r\n         * @param {String} solve_for\r\n         * @returns {Array}\r\n         */\r\n        divideAndConquer: function (symbol, solve_for) {\r\n            var sols = [];\r\n            //see if we can solve the factors\r\n            var factors = core.Algebra.Factor.factor(symbol);\r\n            if(factors.group === CB) {\r\n                factors.each(function (x) {\r\n                    x = Symbol.unwrapPARENS(x);\r\n                    sols = sols.concat(solve(x, solve_for));\r\n                });\r\n            }\r\n            return sols;\r\n        },\r\n        /**\r\n         * Attempts to solve the equation assuming it's a polynomial with numeric coefficients\r\n         * @param {Symbol} eq\r\n         * @param {String} solve_for\r\n         * @returns {Array}\r\n         */\r\n        csolve: function (eq, solve_for) {\r\n            return core.Utils.block('IGNORE_E', function () {\r\n                var f, p, pn, n, pf, r, theta, sr, sp, roots;\r\n                roots = [];\r\n                f = core.Utils.decompose_fn(eq, solve_for, true);\r\n                if(f.x.group === S) {\r\n                    p = _.parse(f.x.power);\r\n                    pn = Number(p);\r\n                    n = _.pow(_.divide(f.b.negate(), f.a), p.invert());\r\n                    pf = Symbol.toPolarFormArray(n);\r\n                    r = pf[0];\r\n                    theta = pf[1];\r\n                    sr = r.toString();\r\n                    sp = p.toString();\r\n                    var k, root, str;\r\n                    for(var i = 0; i < pn; i++) {\r\n                        k = i;\r\n                        str = format('({0})*e^(2*{1}*pi*{2}*{3})', sr, k, p, core.Settings.IMAGINARY);\r\n                        root = _.parse(str);\r\n                        roots.push(root);\r\n                    }\r\n                }\r\n                return roots;\r\n            }, true);\r\n        },\r\n        /**\r\n         * Generates starting points for the Newton solver given an expression at zero.\r\n         * It beings by check if zero is a good point and starts expanding by a provided step size. \r\n         * Builds on the fact that if the sign changes over an interval then a zero\r\n         * must exist on that interval\r\n         * @param {Symbol} symbol\r\n         * @param {Number} step\r\n         * @param {Array} points\r\n         * @returns {Array}\r\n         */\r\n        getPoints: function (symbol, step, points) {\r\n            step = step || 0.01;\r\n            points = points || [];\r\n            var f = build(symbol);\r\n            var x0 = 0;\r\n\r\n            var start = Math.round(x0),\r\n                    last = f(start),\r\n                    last_sign = last / Math.abs(last),\r\n                    rside = core.Settings.ROOTS_PER_SIDE, // the max number of roots on right side\r\n                    lside = rside; // the max number of roots on left side\r\n            // check around the starting point\r\n            points.push(Math.floor(start / 2)); //half way from zero might be a good start\r\n            points.push(Math.abs(start)); //|f(0)| could be a good start\r\n            points.push(start);//|f(0)| could be a good start\r\n            //adjust for log. A good starting point to include for log is 0.1\r\n            symbol.each(function (x) {\r\n                if(x.containsFunction(core.Settings.LOG))\r\n                    points.push(0.1);\r\n            });\r\n\r\n            var left = range(-core.Settings.SOLVE_RADIUS, start, step),\r\n                    right = range(start, core.Settings.SOLVE_RADIUS, step);\r\n\r\n            var test_side = function (side, num_roots) {\r\n                var xi, val, sign;\r\n                var hits = [];\r\n                for(var i = 0, l = side.length; i < l; i++) {\r\n                    xi = side[i]; //the point being evaluated\r\n                    val = f(xi);\r\n                    sign = val / Math.abs(val);\r\n                    //Don't add non-numeric values\r\n                    if(isNaN(val) || !isFinite(val) || hits.length > num_roots) {\r\n                        continue;\r\n                    }\r\n\r\n                    //compare the signs. The have to be different if they cross a zero\r\n                    if(sign !== last_sign) {\r\n                        hits.push(xi); //take note of the possible zero location\r\n                    }\r\n                    last_sign = sign;\r\n                }\r\n\r\n                points = points.concat(hits);\r\n            };\r\n\r\n            test_side(left, lside);\r\n            test_side(right, rside);\r\n\r\n            return points;\r\n        },\r\n        /**\r\n         * Implements the bisection method. Returns undefined in no solution is found\r\n         * @param {number} point\r\n         * @param {function} f\r\n         * @returns {undefined | number}\r\n         */\r\n        bisection: function (point, f) {\r\n            var left = point - 1;\r\n            var right = point + 1;\r\n            // First test if this point is even worth evaluating. It should\r\n            // be crossing the x axis so the signs should be different\r\n            if(Math.sign(f(left)) !== Math.sign(f(right))) {\r\n                var safety = 0;\r\n\r\n                var epsilon, middle;\r\n\r\n                do {\r\n                    epsilon = Math.abs(right - left);\r\n                    // Safety against an infinite loop\r\n                    if(safety++ > core.Settings.MAX_BISECTION_ITER || isNaN(epsilon)) {\r\n                        return;\r\n                    }\r\n                    // Calculate the middle point\r\n                    middle = (left + right) / 2;\r\n\r\n                    if(f(left) * f(middle) > 0) {\r\n                        left = middle;\r\n                    }\r\n                    else {\r\n                        right = middle;\r\n                    }\r\n                }\r\n                while(epsilon >= Settings.EPSILON);\r\n\r\n                var solution = (left + right) / 2;\r\n\r\n                // Test the solution to make sure that it's within tolerance\r\n                var x_point = f(solution);\r\n\r\n                if(!isNaN(x_point) && Math.abs(x_point) <= core.Settings.BI_SECTION_EPSILON) {\r\n                    // Returns too many junk solutions if not rounded at 13th place.\r\n                    return core.Utils.round(solution, 13);\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * Implements Newton's iterations. Returns undefined if no solutions if found\r\n         * @param {number} point\r\n         * @param {function} f\r\n         * @param {function} fp\r\n         * @returns {undefined|number}\r\n         */\r\n        Newton: function (point, f, fp) {\r\n            var maxiter = core.Settings.MAX_NEWTON_ITERATIONS,\r\n                    iter = 0;\r\n            //first try the point itself. If it's zero viola. We're done\r\n            var x0 = point, x;\r\n            do {\r\n                var fx0 = f(x0); //store the result of the function\r\n                //if the value is zero then we're done because 0 - (0/d f(x0)) = 0\r\n                if(x0 === 0 && fx0 === 0) {\r\n                    x = 0;\r\n                    break;\r\n                }\r\n\r\n                iter++;\r\n                if(iter > maxiter)\r\n                    return; //naximum iterations reached\r\n\r\n                x = x0 - fx0 / fp(x0);\r\n                var e = Math.abs(x - x0);\r\n                x0 = x;\r\n            }\r\n            while(e > Settings.NEWTON_EPSILON)\r\n\r\n            //check if the number is indeed zero. 1e-13 seems to give the most accurate results\r\n            if(Math.abs(f(x)) <= Settings.EPSILON)\r\n                return x;\r\n        },\r\n        rewrite: function (rhs, lhs, for_variable) {\r\n            lhs = lhs || new Symbol(0);\r\n            if(rhs.isComposite() && rhs.isLinear()) {\r\n                //try to isolate the square root\r\n                //container for the square roots\r\n                var sqrts = [];\r\n                //all else\r\n                var rem = [];\r\n                rhs.each(function (x) {\r\n                    x = x.clone();\r\n                    if(x.fname === 'sqrt' && x.contains(for_variable)) {\r\n                        sqrts.push(x);\r\n                    }\r\n                    else {\r\n                        rem.push(x);\r\n                    }\r\n                }, true);\r\n\r\n                if(sqrts.length === 1) {\r\n                    //move the remainder to the RHS\r\n                    lhs = _.expand(_.pow(_.subtract(lhs, core.Utils.arraySum(rem)), new Symbol(2)));\r\n                    //square both sides\r\n                    rhs = _.expand(_.pow(Symbol.unwrapSQRT(sqrts[0]), new Symbol(2)));\r\n                }\r\n            }\r\n            else {\r\n                rhs = Symbol.unwrapSQRT(_.expand(rhs)); //expand the term expression go get rid of quotients when possible\r\n            }\r\n\r\n            var c = 0, //a counter to see if we have all terms with the variable\r\n                    l = rhs.length;\r\n            //try to rewrite the whole thing\r\n            if(rhs.group === CP && rhs.contains(for_variable) && rhs.isLinear()) {\r\n                rhs.distributeMultiplier();\r\n                var t = new Symbol(0);\r\n                //first bring all the terms containing the variable to the lhs\r\n                rhs.each(function (x) {\r\n                    if(x.contains(for_variable)) {\r\n                        c++;\r\n                        t = _.add(t, x.clone());\r\n                    }\r\n                    else\r\n                        lhs = _.subtract(lhs, x.clone());\r\n                });\r\n                rhs = t;\r\n\r\n                //if not all the terms contain the variable so it's in the form\r\n                //a*x^2+x\r\n                if(c !== l) {\r\n                    return __.rewrite(rhs, lhs, for_variable);\r\n                }\r\n                else {\r\n                    return [rhs, lhs];\r\n                }\r\n            }\r\n            else if(rhs.group === CB && rhs.contains(for_variable) && rhs.isLinear()) {\r\n                if(rhs.multiplier.lessThan(0)) {\r\n                    rhs.multiplier = rhs.multiplier.multiply(new core.Frac(-1));\r\n                    lhs.multiplier = lhs.multiplier.multiply(new core.Frac(-1));\r\n                }\r\n                if(lhs.equals(0))\r\n                    return new Symbol(0);\r\n                else {\r\n                    var t = new Symbol(1);\r\n                    rhs.each(function (x) {\r\n                        if(x.contains(for_variable))\r\n                            t = _.multiply(t, x.clone());\r\n                        else\r\n                            lhs = _.divide(lhs, x.clone());\r\n                    });\r\n                    rhs = t;\r\n                    return __.rewrite(rhs, lhs, for_variable);\r\n\r\n                }\r\n            }\r\n            else if(!rhs.isLinear() && rhs.contains(for_variable)) {\r\n                var p = _.parse(rhs.power.clone().invert());\r\n                rhs = _.pow(rhs, p.clone());\r\n                lhs = _.pow(_.expand(lhs), p.clone());\r\n                return __.rewrite(rhs, lhs, for_variable);\r\n            }\r\n            else if(rhs.group === FN || rhs.group === S || rhs.group === PL) {\r\n                return [rhs, lhs];\r\n            }\r\n        },\r\n        sqrtSolve: function (symbol, v) {\r\n            var sqrts = new Symbol(0);\r\n            var rem = new Symbol(0);\r\n            if(symbol.isComposite()) {\r\n                symbol.each(function (x) {\r\n                    if(x.fname === 'sqrt' && x.contains(v)) {\r\n                        sqrts = _.add(sqrts, x.clone());\r\n                    }\r\n                    else {\r\n                        rem = _.add(rem, x.clone());\r\n                    }\r\n                });\r\n                //quick and dirty ATM\r\n                if(!sqrts.equals(0)) {\r\n                    var t = _.expand(_.multiply(_.parse(symbol.multiplier), _.subtract(_.pow(rem, new Symbol(2)), _.pow(sqrts, new Symbol(2)))));\r\n                    //square both sides\r\n                    var solutions = solve(t, v);\r\n                    //test the points. The dumb way of getting the answers\r\n                    solutions = solutions.filter(function (e) {\r\n                        if(e.isImaginary())\r\n                            return e;\r\n                        var subs = {};\r\n                        subs[v] = e;\r\n                        var point = evaluate(symbol, subs);\r\n                        if(point.equals(0))\r\n                            return e;\r\n                    });\r\n                    return solutions;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /*\r\n     * \r\n     * @param {String[]|String|Equation} eqns\r\n     * @param {String} solve_for\r\n     * @param {Array} solutions\r\n     * @param {Number} depth\r\n     * @param {String|Equation} fn\r\n     * @returns {Array}\r\n     */\r\n    var solve = function (eqns, solve_for, solutions, depth, fn) {\r\n        depth = depth || 0;\r\n\r\n        if(depth++ > Settings.MAX_SOLVE_DEPTH) {\r\n            return solutions;\r\n        }\r\n\r\n        //make preparations if it's an Equation\r\n        if(eqns instanceof Equation) {\r\n            //if it's zero then we're done\r\n            if(eqns.isZero()) {\r\n                return [new Symbol(0)];\r\n            }\r\n            //if the lhs = x then we're done\r\n            if(eqns.LHS.equals(solve_for) && !eqns.RHS.contains(solve_for)) {\r\n                return [eqns.RHS];\r\n            }\r\n            //if the rhs = x then we're done\r\n            if(eqns.RHS.equals(solve_for) && !eqns.LHS.contains(solve_for)) {\r\n                return [eqns.LHS];\r\n            }\r\n        }\r\n\r\n        //unwrap the vector since what we want are the elements\r\n        if(eqns instanceof core.Vector)\r\n            eqns = eqns.elements;\r\n        solve_for = solve_for || 'x'; //assumes x by default\r\n        //If it's an array then solve it as a system of equations\r\n        if(isArray(eqns)) {\r\n            return __.solveSystem.apply(undefined, arguments);\r\n        }\r\n\r\n        // Parse out functions. Fix for issue #300\r\n        // eqns = core.Utils.evaluate(eqns);\r\n        solutions = solutions || [];\r\n        //mark existing solutions as not to have duplicates\r\n        var existing = {};\r\n\r\n        // Easy fail. If it's a rational function and the denominator is zero\r\n        // the we're done. Issue #555\r\n        var known = {};\r\n        known[solve_for] = 0;\r\n        if(isSymbol(eqns) && evaluate(eqns.getDenom(), known).equals(0) === true) {\r\n            return solutions;\r\n        }\r\n\r\n        // Is usued to add solutions to set. \r\n        // TODO: Set is now implemented and should be utilized\r\n        var add_to_result = function (r, has_trig) {\r\n            var r_is_symbol = isSymbol(r);\r\n            if(r === undefined || typeof r === 'number' && isNaN(r))\r\n                return;\r\n            if(isArray(r)) {\r\n                r.forEach(function (sol) {\r\n                    add_to_result(sol);\r\n                });\r\n            }\r\n            else {\r\n                if(r.valueOf() !== 'null') {\r\n                    // Call the pre-add function if defined. This could be useful for rounding\r\n                    if(typeof core.Settings.PRE_ADD_SOLUTION === 'function') {\r\n                        r = core.Settings.PRE_ADD_SOLUTION(r);\r\n                    }\r\n\r\n                    if(!r_is_symbol) {\r\n                        r = _.parse(r);\r\n                    }\r\n                    // try to convert the number to multiples of pi\r\n                    if(core.Settings.make_pi_conversions && has_trig) {\r\n                        var temp = _.divide(r.clone(), new Symbol(Math.PI)),\r\n                                m = temp.multiplier,\r\n                                a = Math.abs(m.num),\r\n                                b = Math.abs(m.den);\r\n                        if(a < 10 && b < 10)\r\n                            r = _.multiply(temp, new Symbol('pi'));\r\n                    }\r\n\r\n                    // And check if we get a number otherwise we might be throwing out symbolic solutions.\r\n                    var r_str = r.toString();\r\n\r\n                    if(!existing[r_str]) {\r\n                        solutions.push(r);\r\n                    }\r\n                    // Mark the answer as seen\r\n                    existing[r_str] = true;\r\n                }\r\n            }\r\n        };\r\n\r\n        // Maybe we get lucky. Try the point at the function. If it works we have a point\r\n        // If not it failed\r\n        if(eqns.group === S && eqns.contains(solve_for)) {\r\n            try {\r\n                var o = {};\r\n                o[solve_for] = 0;\r\n                evaluate(fn, o, 'numer');\r\n                add_to_result(new Symbol(0));\r\n            }\r\n            catch(e) {\r\n                // Do nothing;\r\n            }\r\n\r\n            return solutions;\r\n        }\r\n        if(eqns.group === CB) {\r\n            // It suffices to solve for the numerator\r\n            var num = eqns.getNum();\r\n\r\n            if(num.group === CB) {\r\n                var sf = String(solve_for); //everything else belongs to the coeff\r\n                //get the denominator and make sure it doesn't have x since we don't know how to solve for those\r\n                num.each(function (x) {\r\n                    if(x.contains(sf))\r\n                        solve(x, solve_for, solutions, depth, eqns);\r\n                });\r\n\r\n                return solutions;\r\n            }\r\n\r\n            return solve(num, solve_for, solutions, depth, fn);\r\n        }\r\n\r\n        if(eqns.group === FN && eqns.fname === 'sqrt') {\r\n            eqns = _.pow(Symbol.unwrapSQRT(eqns), new Symbol(2));\r\n        }\r\n        //pass in false to not expand equations such as (x+y)^5.\r\n        //It suffices to solve for the numerator since there's no value in the denominator which yields a zero for the function\r\n        var eq = (core.Utils.isSymbol(eqns) ? eqns : __.toLHS(eqns, false)).getNum(),\r\n                vars = core.Utils.variables(eq), //get a list of all the variables\r\n                numvars = vars.length;//how many variables are we dealing with\r\n\r\n        //it sufficient to solve (x+y) if eq is (x+y)^n since 0^n\r\n        if(core.Utils.isInt(eq.power) && eq.power > 0) {\r\n            eq = _.parse(eq).toLinear();\r\n        }\r\n\r\n        //if we're dealing with a single variable then we first check if it's a \r\n        //polynomial (including rationals).If it is then we use the Jenkins-Traubb algorithm.     \r\n        //Don't waste time\r\n        if(eq.group === S || eq.group === CB && eq.contains(solve_for)) {\r\n            return [new Symbol(0)];\r\n        }\r\n        //force to polynomial. We go through each and then we look at what it would \r\n        //take for its power to be an integer\r\n        //if the power is a fractional we divide by the fractional power\r\n        var fractionals = {},\r\n                cfact;\r\n\r\n        var correct_denom = function (symbol) {\r\n            symbol = _.expand(symbol, {\r\n                expand_denominator: true,\r\n                expand_functions: true\r\n            });\r\n            var original = symbol.clone(); //preserve the original\r\n\r\n            if(symbol.symbols) {\r\n                for(var x in symbol.symbols) {\r\n                    var sym = symbol.symbols[x];\r\n\r\n                    //get the denominator of the sub-symbol\r\n                    var den = sym.getDenom();\r\n\r\n                    if(!den.isConstant(true) && symbol.isComposite()) {\r\n                        var t = new Symbol(0);\r\n                        symbol.each(function (e) {\r\n                            t = _.add(t, _.multiply(e, den.clone()));\r\n                        });\r\n\r\n                        return correct_denom(_.multiply(_.parse(symbol.multiplier), t));\r\n                    }\r\n\r\n                    var parts = explode(sym, solve_for);\r\n                    var is_sqrt = parts[1].fname === core.Settings.SQRT;\r\n                    var v = Symbol.unwrapSQRT(parts[1]);\r\n                    var p = v.power.clone();\r\n                    //circular logic with sqrt. Since sqrt(x) becomes x^(1/2) which then becomes sqrt(x), this continues forever\r\n                    //this needs to be terminated if p = 1/2\r\n                    if(!isSymbol(p) && !p.equals(1 / 2)) {\r\n                        if(p.den.gt(1)) {\r\n                            if(is_sqrt) {\r\n                                symbol = _.subtract(symbol, sym.clone());\r\n                                symbol = _.add(symbol, _.multiply(parts[0].clone(), v));\r\n                                return correct_denom(symbol);\r\n                            }\r\n                            var c = fractionals[p.den];\r\n                            fractionals[p.den] = c ? c++ : 1;\r\n                        }\r\n                        else if(p.sign() === -1) {\r\n                            var factor = _.parse(solve_for + '^' + Math.abs(p)); //this\r\n                            //unwrap the symbol's denoniator\r\n                            symbol.each(function (y, index) {\r\n                                if(y.contains(solve_for)) {\r\n                                    symbol.symbols[index] = _.multiply(y, factor.clone());\r\n                                }\r\n                            });\r\n                            fractionals = {};\r\n                            return correct_denom(_.parse(symbol));\r\n                        }\r\n                        else if(sym.group === PL) {\r\n                            var min_p = core.Utils.arrayMin(core.Utils.keys(sym.symbols));\r\n                            if(min_p < 0) {\r\n                                var factor = _.parse(solve_for + '^' + Math.abs(min_p));\r\n                                var corrected = new Symbol(0);\r\n                                original.each(function (x) {\r\n                                    corrected = _.add(corrected, _.multiply(x.clone(), factor.clone()));\r\n                                }, true);\r\n                                return corrected;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return symbol;\r\n        };\r\n\r\n\r\n        //separate the equation\r\n        var separate = function (eq) {\r\n            var lhs = new Symbol(0),\r\n                    rhs = new Symbol(0);\r\n            eq.each(function (x) {\r\n                if(x.contains(solve_for, true))\r\n                    lhs = _.add(lhs, x.clone());\r\n                else\r\n                    rhs = _.subtract(rhs, x.clone());\r\n            });\r\n            return [lhs, rhs];\r\n        };\r\n\r\n        __.inverseFunctionSolve = function (name, lhs, rhs) {\r\n            //ax+b comes back as [a, x, ax, b];\r\n            var parts = explode(lhs.args[0], solve_for);\r\n            //check if x is by itself\r\n            var x = parts[1];\r\n            if(x.group === S) {\r\n                return _.divide(_.symfunction(name, [_.divide(rhs, _.parse(lhs.multiplier))]), parts[0]);\r\n            }\r\n\r\n        };\r\n\r\n        //first remove any denominators\r\n        eq = correct_denom(eq);\r\n\r\n        if(eq.equals(0))\r\n            return [eq];\r\n        //correct fractionals. I can only handle one type right now\r\n        var fkeys = core.Utils.keys(fractionals);\r\n        if(fkeys.length === 1) {\r\n            //make a note of the factor\r\n            cfact = fkeys[0];\r\n            eq.each(function (x, index) {\r\n                if(x.contains(solve_for)) {\r\n                    var parts = explode(x, solve_for);\r\n                    var v = parts[1];\r\n                    var p = v.power;\r\n                    if(p.den.gt(1)) {\r\n                        v.power = p.multiply(new core.Frac(cfact));\r\n                        eq.symbols[index] = _.multiply(v, parts[0]);\r\n                    }\r\n                }\r\n            });\r\n            eq = _.parse(eq);\r\n        }\r\n\r\n        //try for nested sqrts as per issue #486\r\n        add_to_result(__.sqrtSolve(eq, solve_for));\r\n\r\n        //polynomial single variable\r\n        if(numvars === 1) {\r\n            if(eq.isPoly(true)) {\r\n                //try to factor and solve\r\n                var factors = new core.Algebra.Classes.Factors();\r\n\r\n                core.Algebra.Factor.factor(eq, factors);\r\n                //if the equation has more than one symbolic factor then solve those individually\r\n                if(factors.getNumberSymbolics() > 1) {\r\n                    for(var x in factors.factors) {\r\n                        add_to_result(solve(factors.factors[x], solve_for));\r\n                    }\r\n                }\r\n                else {\r\n                    var coeffs = core.Utils.getCoeffs(eq, solve_for),\r\n                            deg = coeffs.length - 1,\r\n                            was_calculated = false;\r\n                    if(vars[0] === solve_for) {\r\n                        //check to see if all the coefficients are constant\r\n                        if(checkAll(coeffs, function (x) {\r\n                            return x.group !== core.groups.N;\r\n                        })) {\r\n                            var roots = core.Algebra.proots(eq);\r\n                            //if all the roots are integers then return those\r\n                            if(checkAll(roots, function (x) {\r\n                                return !core.Utils.isInt(x);\r\n                            })) {\r\n                                //roots have been calculates\r\n                                was_calculated = true;\r\n                                roots.map(function (x) {\r\n                                    add_to_result(new Symbol(x));\r\n                                });\r\n                            }\r\n                        }\r\n\r\n                        if(!was_calculated) {\r\n                            eqns = _.parse(eqns);\r\n                            if(eqns instanceof core.Equation)\r\n                                eqns = eqns.toLHS();\r\n\r\n                            //we can solve algebraically for degrees 1, 2, 3. The remainder we switch to Jenkins-\r\n                            if(deg === 1)\r\n                                add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\r\n                            else if(deg === 2) {\r\n                                add_to_result(_.expand(__.quad.apply(undefined, coeffs)));\r\n                            }\r\n\r\n                            else if(deg === 3) {\r\n                                var solutions = []; //set to blank\r\n                                //first try to factor and solve\r\n                                var factored = core.Algebra.Factor.factor(eqns);\r\n\r\n                                //if it was successfully factored\r\n                                var solutions = [];\r\n                                if(solutions.length > 0)\r\n                                    add_to_result(solutions);\r\n                                else\r\n                                    add_to_result(__.cubic.apply(undefined, coeffs));\r\n                            }\r\n\r\n                            else {\r\n                                /*\r\n                                 var sym_roots = csolve(eq, solve_for); \r\n                                 if(sym_roots.length === 0)\r\n                                 sym_roots = divnconsolve(eq, solve_for);\r\n                                 if(sym_roots.length > 0) \r\n                                 add_to_result(sym_roots);\r\n                                 else\r\n                                 */\r\n                                _A.proots(eq).map(add_to_result);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                try {\r\n                    // Attempt Newton\r\n                    // Since it's not a polynomial then we'll try to look for a solution using Newton's method\r\n                    var has_trig = eq.hasTrig();\r\n                    // we get all the points where a possible zero might exist.\r\n                    var points1 = __.getPoints(eq, 0.1);\r\n                    var points2 = __.getPoints(eq, 0.05);\r\n                    var points3 = __.getPoints(eq, 0.01);\r\n                    var points = core.Utils.arrayUnique(points1.concat(points2).concat(points3)).sort(function (a, b) {\r\n                        return a - b;\r\n                    });\r\n                    var i, point, solution;\r\n\r\n                    // Compile the function\r\n                    var f = build(eq.clone());\r\n\r\n                    // First try to eliminate some points using bisection\r\n                    var t_points = [];\r\n                    for(i = 0; i < points.length; i++) {\r\n                        point = points[i];\r\n\r\n                        // See if there's a solution at this point\r\n                        solution = __.bisection(point, f);\r\n\r\n                        // If there's no solution then add it to the array for further investigation\r\n                        if(typeof solution === 'undefined') {\r\n                            t_points.push(point);\r\n                            continue;\r\n                        }\r\n\r\n                        // Add the solution to the solution set\r\n                        add_to_result(solution, has_trig);\r\n                    }\r\n\r\n                    // Reset the points to the remaining points\r\n                    points = t_points;\r\n\r\n                    // Build the derivative and compile a function\r\n                    var d = _C.diff(eq.clone());\r\n                    var fp = build(d);\r\n                    for(i = 0; i < points.length; i++) {\r\n                        point = points[i];\r\n\r\n                        add_to_result(__.Newton(point, f, fp), has_trig);\r\n                    }\r\n                    solutions.sort();\r\n                }\r\n                catch(e) {\r\n                    console.log(e);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            //The idea here is to go through the equation and collect the coefficients\r\n            //place them in an array and call the quad or cubic function to get the results\r\n            if(!eq.hasFunc(solve_for) && eq.isComposite()) {\r\n                try {\r\n                    var factored = core.Algebra.Factor.factor(eq.clone());\r\n\r\n                    if(factored.group === CB) {\r\n                        factored.each(function (x) {\r\n                            add_to_result(solve(x, solve_for));\r\n                        });\r\n                    }\r\n                    else {\r\n                        var coeffs = core.Utils.getCoeffs(eq, solve_for);\r\n\r\n                        var l = coeffs.length,\r\n                                deg = l - 1; //the degree of the polynomial\r\n                        //get the denominator and make sure it doesn't have x\r\n\r\n                        //handle the problem based on the degree\r\n                        switch(deg) {\r\n                            case 0:\r\n                                var separated = separate(eq);\r\n                                var lhs = separated[0],\r\n                                        rhs = separated[1];\r\n                                \r\n                                if(lhs.group === core.groups.EX) {\r\n                                    var log = core.Settings.LOG;\r\n                                    var expr_str = `${log}((${rhs})/(${lhs.multiplier}))/${log}(${lhs.value})/${lhs.power.multiplier}`;\r\n                                    add_to_result(_.parse(expr_str));\r\n                                }\r\n                                break;\r\n                            case 1:\r\n                                //nothing to do but to return the quotient of the constant and the LT\r\n                                //e.g. 2*x-1\r\n                                add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\r\n                                break;\r\n                            case 2:\r\n                                add_to_result(__.quad.apply(undefined, coeffs));\r\n                                break;\r\n                            case 3:\r\n                                add_to_result(__.cubic.apply(undefined, coeffs));\r\n                                break;\r\n                            case 4:\r\n                                add_to_result(__.quartic.apply(undefined, coeffs));\r\n                                break;\r\n                            default:\r\n                                add_to_result(__.csolve(eq, solve_for));\r\n                                if(solutions.length === 0)\r\n                                    add_to_result(__.divideAndConquer(eq, solve_for));\r\n                        }\r\n\r\n                        if(solutions.length === 0) {\r\n                            //try factoring\r\n                            add_to_result(solve(factored, solve_for, solutions, depth));\r\n                        }\r\n                    }\r\n\r\n                }\r\n                catch(e) { /*something went wrong. EXITING*/\r\n                    ;\r\n                }\r\n            }\r\n            else {\r\n                try {\r\n                    var rw = __.rewrite(eq, null, solve_for);\r\n                    var lhs = rw[0];\r\n                    var rhs = rw[1];\r\n                    if(lhs.group === FN) {\r\n                        if(lhs.fname === 'abs') {\r\n                            add_to_result([rhs.clone(), rhs.negate()]);\r\n                        }\r\n                        else if(lhs.fname === 'sin') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('asin', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === 'cos') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('acos', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === 'tan') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('atan', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === core.Settings.LOG) {\r\n                            //ax+b comes back as [a, x, ax, b];\r\n                            var parts = explode(lhs.args[0], solve_for);\r\n                            //check if x is by itself\r\n                            var x = parts[1];\r\n                            if(x.group === S) {\r\n                                rhs = _.divide(_.subtract(_.pow(lhs.args.length > 1 ? lhs.args[1] : new Symbol('e'), _.divide(rhs, _.parse(lhs.multiplier))), parts[3]), parts[0]);\r\n                                var eq = new Equation(x, rhs).toLHS();\r\n                                add_to_result(solve(eq, solve_for));\r\n                            }\r\n                        }\r\n                        else\r\n                            add_to_result(_.subtract(lhs, rhs));\r\n                    }\r\n                    else {\r\n                        var neq = new Equation(lhs, rhs).toLHS(); //create a new equation\r\n\r\n                        if(neq.equals(eq))\r\n                            throw new Error('Stopping. No stop condition exists');\r\n                        add_to_result(solve(neq, solve_for));\r\n                    }\r\n                }\r\n                catch(error) {\r\n                    //Let's try this another way\r\n                    try {\r\n                        //1. if the symbol is in the form a*b*c*... then the solution is zero if \r\n                        //either a or b or c is zero.\r\n                        if(eq.group === CB)\r\n                            add_to_result(0);\r\n                        else if(eq.group === CP) {\r\n                            var separated = separate(eq);\r\n                            var lhs = separated[0],\r\n                                    rhs = separated[1];\r\n\r\n                            //reduce the equation\r\n                            if(lhs.group === core.groups.EX && lhs.value === solve_for) {\r\n                                //change the base of both sides\r\n                                var p = lhs.power.clone().invert();\r\n                                add_to_result(_.pow(rhs, p));\r\n                            }\r\n                        }\r\n                    }\r\n                    catch(error) {\r\n                        ;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(cfact) {\r\n            solutions = solutions.map(function (x) {\r\n                return _.pow(x, new Symbol(cfact));\r\n            });\r\n        }\r\n\r\n        // Perform some cleanup but don't do it agains arrays, etc\r\n        // Check it actually evaluates to zero\r\n        if(isSymbol(eqns)) {\r\n            var knowns = {};\r\n            solutions = solutions.filter(function (x) {\r\n                try {\r\n                    knowns[solve_for] = x;\r\n                    var zero = Number(evaluate(eqns, knowns));\r\n\r\n                    // Allow symbolic answers\r\n                    if(isNaN(zero)) {\r\n                        return true;\r\n                    }\r\n                    return true;\r\n                }\r\n                catch(e) {\r\n                    return false;\r\n                }\r\n            });\r\n        }\r\n\r\n        return solutions;\r\n    };\r\n\r\n    //Register the functions for external use\r\n    nerdamer.register([\r\n        {\r\n            name: 'solveEquations',\r\n            parent: 'nerdamer',\r\n            numargs: -1,\r\n            visible: true,\r\n            build: function () {\r\n                return solve; //comment out to return a vector\r\n                /*\r\n                 return function() {\r\n                 return core.Utils.convertToVector(solve.apply(null, arguments));\r\n                 };\r\n                 */\r\n            }\r\n        },\r\n        {\r\n            name: 'solve',\r\n            parent: 'Solve',\r\n            numargs: 2,\r\n            visible: true,\r\n            build: function () {\r\n                return core.Solve.solve;\r\n            }\r\n        },\r\n        {\r\n            name: 'setEquation',\r\n            parent: 'Solve',\r\n            visible: true,\r\n            build: function () {\r\n                return setEq;\r\n            }\r\n        }\r\n    ]);\r\n    nerdamer.updateAPI();\r\n})();"],"names":["nerdamer","require","core","getCore","_","PARSER","_A","Algebra","_C","Calculus","explode","integration","decompose_arg","evaluate","Utils","remove","format","build","knownVariable","Symbol","isSymbol","variables","S","groups","PL","CB","CP","FN","Settings","range","isArray","Equation","lhs","rhs","isConstant","equals","IMAGINARY","exceptions","NerdamerValueError","toString","this","LHS","RHS","SOLVE_RADIUS","ROOTS_PER_SIDE","make_pi_conversions","STEP_SIZE","EPSILON","MAX_NEWTON_ITERATIONS","MAX_NON_LINEAR_TRIES","NON_LINEAR_JUMP_AT","NON_LINEAR_JUMP_SIZE","NON_LINEAR_START","NEWTON_SLICES","NEWTON_EPSILON","Number","SOLUTION_PROXIMITY","FILTER_SOLUTIONS","MAX_SOLVE_DEPTH","ZERO_EPSILON","MAX_BISECTION_ITER","BI_SECTION_EPSILON","prototype","hasTrig","containsFunction","hasNegativeTerms","isComposite","x","symbols","sym","group","power","lessThan","text","option","toLHS","expand","eqn","a","removeDenom","clone","b","_t","subtract","retval","den","multiply","getDenom","t","multiplier","newRHS","each","y","divide","sym2","toLinear","sub","isZero","latex","join","simplify","functions","symbol","Expression","solveFor","solve","map","arrayUnique","concat","setEq","checkAll","args","test","i","length","__","Solve","version","solutions","eq","variable","solution","String","Vector","es","split","parse","solveCircle","eqns","vars","svars","deg","d","j","push","degree","arraySum","y_points","x_points","SOLUTIONS_AS_OBJECT","unshift","solveNonLinearSystem","tries","start","max_tries","halfway","Math","floor","o","iters","xn1","norm","lnorm","xn","jump_at","jump","found","create_subs","matrix","get","arrayGetVariables","jacobian","Matrix","max_iter","f_eqns","J","e","cMatrix","c","forEach","f","set","apply","m","fn","ans","invert","negate","add","sign","n","max","systemSolutions","round","result","expand_result","callback","idx","valueOf","call","solveSystemBySubstitution","vars_a","vars_b","arrayEqual","solveSystem","var_array","l","allLinear","DivisionByZero","sol","reduced","knowns","Array","all_zero","setVar","v","coeffs","contains","cf","num","stripVar","collectSymbols","k","term","check","z","err","tparts","determinant","SolveError","quad","discriminant","pow","det","cubic","d_o","c_o","b_o","a_o","u","w","quartic","p","q","D0","D1","Q","scope","divideAndConquer","solve_for","sols","factors","Factor","factor","unwrapPARENS","csolve","block","pn","pf","r","sr","roots","decompose_fn","root","str","toPolarFormArray","getPoints","step","points","last","last_sign","abs","rside","lside","LOG","left","right","test_side","side","num_roots","xi","val","hits","isNaN","isFinite","bisection","point","epsilon","middle","safety","x_point","Newton","fp","maxiter","iter","x0","fx0","rewrite","for_variable","isLinear","sqrts","rem","fname","unwrapSQRT","distributeMultiplier","Frac","sqrtSolve","filter","isImaginary","subs","depth","elements","undefined","arguments","existing","known","add_to_result","has_trig","r_is_symbol","PRE_ADD_SOLUTION","temp","PI","r_str","getNum","sf","numvars","isInt","cfact","fractionals","correct_denom","original","expand_denominator","expand_functions","parts","is_sqrt","SQRT","gt","index","min_p","arrayMin","keys","corrected","separate","inverseFunctionSolve","name","symfunction","fkeys","isPoly","Classes","Factors","getNumberSymbolics","getCoeffs","was_calculated","N","proots","factored","points1","points2","points3","sort","t_points","diff","console","log","hasFunc","separated","EX","expr_str","value","rw","neq","Error","error","zero","register","parent","numargs","visible","updateAPI"],"sourceRoot":""}